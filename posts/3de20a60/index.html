<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MIT6.830-Lab3 | LegGasai's CSLearning</title><meta name="author" content="LegGasai"><meta name="copyright" content="LegGasai"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="介绍在这个实验中，您将在 SimpleDB 的基础上实现一个查询优化器。主要任务包括实现一个选择性估算框架和一个基于成本的优化器。您在具体实现方面有一定的自由度，但我们建议使用类似于课堂上讨论的 Selinger 基于成本的优化器（第9讲）。 本文档的其余部分描述了添加优化器支持所涉及的内容，并提供了如何进行的基本概述。 与之前的实验一样，我们建议您尽早开始。 提示 实现 TableStats 类">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6.830-Lab3">
<meta property="og:url" content="https://leggasai.github.io/posts/3de20a60/index.html">
<meta property="og:site_name" content="LegGasai&#39;s CSLearning">
<meta property="og:description" content="介绍在这个实验中，您将在 SimpleDB 的基础上实现一个查询优化器。主要任务包括实现一个选择性估算框架和一个基于成本的优化器。您在具体实现方面有一定的自由度，但我们建议使用类似于课堂上讨论的 Selinger 基于成本的优化器（第9讲）。 本文档的其余部分描述了添加优化器支持所涉及的内容，并提供了如何进行的基本概述。 与之前的实验一样，我们建议您尽早开始。 提示 实现 TableStats 类">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leggasai.github.io/img/avatar.PNG">
<meta property="article:published_time" content="2024-02-01T02:39:04.000Z">
<meta property="article:modified_time" content="2024-03-24T14:40:30.979Z">
<meta property="article:author" content="LegGasai">
<meta property="article:tag" content="后端">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leggasai.github.io/img/avatar.PNG"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://leggasai.github.io/posts/3de20a60/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MIT6.830-Lab3',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-24 22:40:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.PNG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 博客</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/top.png')"><nav id="nav"><span id="blog-info"><a href="/" title="LegGasai's CSLearning"><span class="site-name">LegGasai's CSLearning</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 博客</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MIT6.830-Lab3</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-01T02:39:04.000Z" title="发表于 2024-02-01 10:39:04">2024-02-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-24T14:40:30.979Z" title="更新于 2024-03-24 22:40:30">2024-03-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/MIT6-830/">MIT6.830</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MIT6.830-Lab3"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在这个实验中，您将在 SimpleDB 的基础上实现一个查询优化器。主要任务包括实现一个选择性估算框架和一个基于成本的优化器。您在具体实现方面有一定的自由度，但我们建议使用类似于课堂上讨论的 Selinger 基于成本的优化器（第9讲）。</p>
<p>本文档的其余部分描述了添加优化器支持所涉及的内容，并提供了如何进行的基本概述。</p>
<p>与之前的实验一样，我们建议您尽早开始。</p>
<h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><ul>
<li>实现 <code>TableStats</code> 类中的方法，使其能够使用直方图（为 <code>IntHistogram</code> 类提供了框架）或您设计的其他形式的统计信息，估算过滤器的选择性和扫描成本。</li>
<li>实现 <code>JoinOptimizer</code> 类中的方法，使其能够估算连接的成本和选择性。</li>
<li>编写 <code>JoinOptimizer</code> 中的 <code>orderJoins</code> 方法。该方法必须针对一系列连接（可能使用 <code>Selinger</code> 算法），根据在前两个步骤中计算的统计信息生成最佳的连接顺序。</li>
</ul>
<h1 id="优化大纲"><a href="#优化大纲" class="headerlink" title="优化大纲"></a>优化大纲</h1><p>请记住，基于成本的优化器的主要思想是：</p>
<ul>
<li>利用关于表的统计信息来估算不同查询计划的“成本”。通常，计划的成本与中间连接和选择所产生的元组数量（基数），以及过滤和连接谓词的选择性相关。</li>
<li>利用这些统计信息以最佳方式对连接和选择进行排序，并从多个备选的连接算法中选择最佳实现。 在这个实验中，您将实现代码来执行这两个功能。</li>
</ul>
<p>优化器将从 <code>simpledb/Parser.java</code> 中调用。在开始本实验之前，您可能需要回顾一下<code>实验 2</code> 中的解析器练习。简而言之，如果你有一个描述表的目录文件 <code>catalog.txt</code>，你可以通过键入以下内容运行解析器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar dist/simpledb.jar parser catalog.txt</span><br></pre></td></tr></table></figure>

<p>调用解析器时，它将计算所有表的统计数据（使用您提供的统计代码）。当发出查询时，解析器会将查询转换为逻辑计划表示，然后调用查询优化器生成最优计划。</p>
<h2 id="优化器结构"><a href="#优化器结构" class="headerlink" title="优化器结构"></a>优化器结构</h2><p>在开始实施之前，您需要了解 SimpleDB 优化器的整体结构。SimpleDB 模块的<code>parser</code>和<code>optimizer</code>的整体控制流程如图 1 所示。</p>
<p><img src="/../../../../img/Pasted%20image%2020240201113135.png"></p>
<p>底部的键解释了这些符号；您将实现双边框的组件。在接下来的文本中，将更详细地解释类和方法（您可能希望参考这个图表），但基本操作如下：</p>
<ul>
<li>当<code>Parser.java</code>初始化时，它构造了一组表统计信息（存储在<code>statsMap</code>容器中）。然后，它等待输入查询，并在该查询上调用<code>parseQuery</code>方法。 </li>
<li><code>parseQuery</code>首先构造了一个表示解析查询的<code>LogicalPlan</code>。然后，<code>parseQuery</code>调用<code>LogicalPlan</code>实例上的<code>physicalPlan</code>方法。<code>physicalPlan</code>方法返回一个<code>DBIterator</code>对象，可用于实际运行查询。</li>
</ul>
<p>在即将进行的练习中，您将实现帮助<code>physicalPlan</code>设计最佳计划的方法。</p>
<h2 id="统计估算"><a href="#统计估算" class="headerlink" title="统计估算"></a>统计估算</h2><p>准确估算计划成本是相当棘手的。在这个实验中，我们将仅关注连接顺序和基表访问的成本。我们不会考虑访问方法的选择（因为我们只有一种访问方法，即表扫描）或其他运算符（如聚合）的成本。</p>
<p>在这个实验中，您只需要考虑左深度计划。有关额外的“奖励”优化器功能的描述，请参见第2.3节，其中包括您可以实现的处理杂乱计划的方法。</p>
<h3 id="整体计划成本"><a href="#整体计划成本" class="headerlink" title="整体计划成本"></a>整体计划成本</h3><p>我们将会编写<code>join</code>计划，以如下的形式<code>p=t1 join t2 join ... tn</code>。它表示一个左深连接。其中<code>t1</code>是最左边的连接（树中最深的连接）。给定一个如<code>p</code>的计划，其成本可以表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scancost(t1) + scancost(t2) + joincost(t1 join t2) +</span><br><span class="line">scancost(t3) + joincost((t1 join t2) join t3) +</span><br><span class="line">... </span><br></pre></td></tr></table></figure>

<p>这里，<code>scancost(t1)</code>表示扫描表<code>t1</code>的I&#x2F;O成本，<code>joincost(t1, t2)</code>表示将<code>t1</code>与<code>t2</code>连接的CPU成本。为了使I&#x2F;O和CPU成本可比较，通常会使用一个常数缩放因子，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cost(predicate application) = 1</span><br><span class="line">cost(pageScan) = SCALING_FACTOR x cost(predicate application)</span><br></pre></td></tr></table></figure>

<p>在这个实验中，您可以忽略缓存效应（例如，假设对表的每次访问都会产生完整的扫描成本）——同样，这是您可以在第2.3节中作为实验的可选奖励扩展添加的内容。因此，<code>scancost(t1)</code>简单地是<code>t1</code>中页面的数量 <code>x SCALING_FACTOR</code>。</p>
<h3 id="连接成本"><a href="#连接成本" class="headerlink" title="连接成本"></a>连接成本</h3><p>在使用嵌套循环连接时，请记住两个表 t1 和 t2（其中 t1 是外层表）之间的连接成本很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">joincost(t1 join t2) = scancost(t1) + ntups(t1) x scancost(t2) //IO cost</span><br><span class="line">                       + ntups(t1) x ntups(t2)  //CPU cost</span><br></pre></td></tr></table></figure>

<p>这里，<code>ntups(t1)</code>是表<code>t1</code>中的<code>tuples</code>数量。</p>
<h3 id="过滤器的选择性"><a href="#过滤器的选择性" class="headerlink" title="过滤器的选择性"></a>过滤器的选择性</h3><p><code>ntups</code> 可以通过扫描基表直接计算。对于具有一个或多个选择谓词的表来估算 <code>ntups</code> 可能会更加棘手 — 这是<em>过滤选择性估算</em>的问题。以下是您可能采用的一种方法，基于在表中的值上计算直方图：</p>
<ul>
<li><p>计算表中每个属性的最小值和最大值（通过一次扫描实现）。 </p>
</li>
<li><p>为表中的每个属性构建直方图。一种简单的方法是使用固定数量的桶（NumB），每个桶代表直方图属性域中固定范围内的记录数量。例如，如果字段 f 范围从 1 到 100，且有 10 个桶，那么桶 1 可能包含记录数，其值在 1 到 10 之间，桶 2 包含记录数，在 11 到 20 之间，依此类推。 </p>
</li>
<li><p>再次扫描表，选择所有元组的所有字段，并使用它们来填充每个直方图的桶计数。 </p>
</li>
<li><p>要估算相等表达式 f&#x3D;const 的选择性，请计算包含值 const 的桶。假设桶的宽度（值范围）为 w，高度（元组数量）为 h，表中的元组数量为 ntups。然后，假设值在整个桶中均匀分布，表达式的选择性大致为 (h &#x2F; w) &#x2F; ntups，因为 (h&#x2F;w) 代表具有值 const 的桶中的预期元组数量。 </p>
</li>
<li><p>要估算范围表达式 f&gt;const 的选择性，请计算包含 const 的桶 b，其宽度为 w_b，高度为 h_b。然后，b 包含总元组的分数 b_f &#x3D; h_b &#x2F; ntups。假设元组在 b 中均匀分布，则 b 中 &gt; const 的部分 b_part 为 (b_right - const) &#x2F; w_b，其中 b_right 是 b 桶的右端点。因此，桶 b 对谓词贡献了 (b_f x b_part) 的选择性。此外，桶 b+1…NumB-1 贡献了它们所有的选择性（可以使用类似于 b_f 的公式计算）。将所有桶的选择性贡献相加将得到表达式的整体选择性。图 2 阐明了这个过程。 </p>
</li>
<li><p>涉及小于的表达式的选择性可以类似于大于的情况，查看从 0 开始的桶。</p>
</li>
</ul>
<p><img src="/../../../../img/Pasted%20image%2020240201152356.png"></p>
<p>在接下来的两个练习中，您将用代码来执行连接和筛选器的选择性估计。</p>
<hr>
<h3 id="Exercise-1-IntHistogram-java"><a href="#Exercise-1-IntHistogram-java" class="headerlink" title="Exercise 1: IntHistogram.java"></a><strong>Exercise 1: IntHistogram.java</strong></h3><p>你需要实现某种记录表统计信息以进行选择性估算的方法。我们提供了一个骨架类 <code>IntHistogram</code> 用于执行此操作。我们的意图是让你使用上述描述的基于桶的方法来计算直方图，但只要提供合理的选择性估算，你可以自由选择其他方法。</p>
<p>我们提供了一个名为 <code>StringHistogram</code> 的类，它使用 <code>IntHistogram</code> 来计算字符串谓词的选择性。如果你希望实现更好的估算器，你可以修改 <code>StringHistogram</code>，尽管为完成此实验，你可能不需要这样做。</p>
<p>完成此练习后，你应该能够通过 <code>IntHistogramTest</code> 单元测试（如果选择不实现基于直方图的选择性估算，则不必通过此测试）。</p>
<hr>
<h3 id="Exercise-2-TableStats-java"><a href="#Exercise-2-TableStats-java" class="headerlink" title="Exercise 2: TableStats.java"></a><strong>Exercise 2: TableStats.java</strong></h3><p><code>TableStats</code>类包含一些计算表中元组和页数以及估算谓词在该表字段上的选择性的方法。我们已经创建的查询解析器为每个表创建一个<code>TableStats</code>实例，并将这些结构传递给你的查询优化器（在后续练习中会用到）。</p>
<p>你应该在TableStats中填充以下方法和类：</p>
<ol>
<li>实现<code>TableStats</code>构造函数：一旦你实现了跟踪直方图等统计信息的方法，就应该实现<code>TableStats</code>构造函数，添加代码来扫描表（可能多次）以构建你需要的统计信息。</li>
<li>实现<code>estimateSelectivity(int field, Predicate.Op op, Field constant)</code>：使用你的统计信息（例如，根据字段类型使用IntHistogram或StringHistogram），估算在表上对字段执行谓词操作<code>constant</code> 的选择性。</li>
<li>实现<code>estimateScanCost()</code>：此方法估算顺序扫描文件的成本，假设读取一页的成本是<code>costPerPageIO</code>。可以假设没有寻找，且没有页面在缓冲池中。该方法可能使用你在构造函数中计算的成本或大小。</li>
<li>实现estimateTableCardinality(double selectivityFactor)：此方法返回在应用具有选择性selectivityFactor的谓词时关系中的元组数量。该方法可能使用你在构造函数中计算的成本或大小。</li>
</ol>
<p>你可能需要修改<code>TableStats.java</code>的构造函数，例如，为了进行谓词选择性估算而计算字段上的直方图。</p>
<p>完成这些任务后，你应该能够通过<code>TableStatsTest</code>中的单元测试。</p>
<hr>
<h3 id="Join-Cardinality"><a href="#Join-Cardinality" class="headerlink" title="Join Cardinality"></a>Join Cardinality</h3><p>最后，注意到上述<code>join</code>计划 <code>p</code> 的成本包括形式为 <code>joincost((t1 join t2) join t3)</code>的表达式。要评估这个表达式，你需要一种估计 <code>t1 join t2</code>的大小（<code>ntups</code>）的方法。这个<code>join</code>基数估算问题比过滤选择性估算问题更为困难。在本实验中，你不需要为此做任何复杂的事情，尽管第2.4节中的一个可选练习包括基于直方图的联接选择性估算方法。</p>
<p>在实现简单解决方案时，你应该记住以下事项：</p>
<ul>
<li>对于等值连接，当其中一个属性是主键时，连接产生的元组数不能大于非主键属性的基数。</li>
<li>对于等值连接，当没有主键时，很难准确说输出的大小是多少，可能是表的基数的乘积的大小（如果两个表的所有元组都有相同的值）——或者可能是0。可以采用一个简单的启发式方法（例如，两个表中较大表的大小）。</li>
<li>对于范围扫描，关于大小准确说起来同样困难。输出的大小应与输入的大小成比例。可以假设范围扫描发出交叉乘积的固定分数（例如，30%）。通常情况下，范围连接的成本应大于两个大小相同的表的非主键等值连接的成本。</li>
</ul>
<h3 id="Exercise-3-Join-Cost-Estimation"><a href="#Exercise-3-Join-Cost-Estimation" class="headerlink" title="Exercise 3: Join Cost Estimation"></a><strong>Exercise 3: Join Cost Estimation</strong></h3><p> <code>JoinOptimizer.java</code> 类包含所有关于连接的排序和计算成本的方法。在这个练习中，你将编写用于估算连接选择性和成本的方法，具体包括：</p>
<ul>
<li>实现 <code>estimateJoinCost(LogicalJoinNode j, int card1, int card2, double cost1, double cost2)</code>：该方法估算连接 j 的成本，假设左输入的基数为 card1，右输入的基数为 card2，扫描左输入的成本为 cost1，访问右输入的成本为 cost2。你可以假设连接是一个NL连接，并应用前面提到的公式。</li>
<li>实现 <code>estimateJoinCardinality(LogicalJoinNode j, int card1, int card2, boolean t1pkey, boolean t2pkey)</code>：该方法估算连接 j 输出的元组数量，假设左输入的大小为 card1，右输入的大小为 card2，以及指示左和右字段是否唯一（分别是主键）的标志 t1pkey 和 t2pkey。</li>
</ul>
<p>完成这些方法的实现后，你应该能够通过 JoinOptimizerTest.java 中的单元测试 <code>estimateJoinCostTest</code> 和 <code>estimateJoinCardinality</code>。</p>
<h3 id="Join-Ordering"><a href="#Join-Ordering" class="headerlink" title="Join Ordering"></a><strong>Join Ordering</strong></h3><p>您已经实现了用于评估成本的方法，接下来你将要实现<code>Selinger optimizer</code>。对于这些方法，连接由一系列的<code>join nodes</code>来表达，比如两个表的谓词。而不是像课堂上描述的以连接关系的列表来表示。</p>
<p>将讲义中给出的算法转换成上述的连接节点列表形式，伪代码大纲就是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> j = set of join nodes</span><br><span class="line"><span class="number">2.</span> <span class="keyword">for</span> (i in <span class="number">1.</span>..|j|):</span><br><span class="line"><span class="number">3.</span>     <span class="keyword">for</span> s in &#123;all length i subsets of j&#125;</span><br><span class="line"><span class="number">4.</span>       bestPlan = &#123;&#125;</span><br><span class="line"><span class="number">5.</span>       <span class="keyword">for</span> s<span class="string">&#x27; in &#123;all length d-1 subsets of s&#125;</span></span><br><span class="line"><span class="string">6.            subplan = optjoin(s&#x27;</span>)</span><br><span class="line"><span class="number">7.</span>            plan = best way to <span class="title function_">join</span> <span class="params">(s-s<span class="string">&#x27;) to subplan</span></span></span><br><span class="line"><span class="string"><span class="params">8.            if (cost(plan) &lt; cost(bestPlan))</span></span></span><br><span class="line"><span class="string"><span class="params">9.               bestPlan = plan</span></span></span><br><span class="line"><span class="string"><span class="params">10.      optjoin(s) = bestPlan</span></span></span><br><span class="line"><span class="string"><span class="params">11. return optjoin(j)</span></span></span><br></pre></td></tr></table></figure>

<p>为了帮助您实现这个算法，我们已经提供了几个类和方法来协助你。首先在<code>JoinOptimizer.java</code>中的<code>enumerateSubsets(List v,int size)</code>方法会返回一系列大小为<code>size</code>的<code>v</code>的子集。这个方法十分低效对于大规模的集合。你可以获得额外的学分通过实现更高效的<code>enumertor</code>（提示：考考虑使用in-place生成算法和懒迭代器或流接口来避免将整个幂集具体化）。</p>
<p>此外，我们能提供了如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CostCard <span class="title function_">computeCostAndCardOfSubplan</span><span class="params">(Map&lt;String, TableStats&gt; stats, </span></span><br><span class="line"><span class="params">                                               Map&lt;String, Double&gt; filterSelectivities, </span></span><br><span class="line"><span class="params">                                               LogicalJoinNode joinToRemove,  </span></span><br><span class="line"><span class="params">                                               Set&lt;LogicalJoinNode&gt; joinSet,</span></span><br><span class="line"><span class="params">                                               <span class="type">double</span> bestCostSoFar,</span></span><br><span class="line"><span class="params">                                               PlanCache pc)</span></span><br></pre></td></tr></table></figure>

<p>给定连接的子集（<code>joinSet</code>）和要从该集合中移除的连接（<code>joinToRemove</code>），此方法计算将<code>joinToRemove</code>连接到<code>joinSet - &#123;joinToRemove&#125;</code> 的最佳方式。它以<code>CostCard</code>对象的形式返回这个最佳方法，其中包括成本、基数和最佳连接顺序（作为列表）。如果computeCostAndCardOfSubplan返回null，可能是因为找不到计划（例如，因为没有可能的左深连接），或者所有计划的成本都大于<code>bestCostSoFar</code>参数。该方法使用称为<code>pc</code>（上述伪代码中的optjoin）的先前连接的缓存来快速查找连接<code>joinSet - &#123;joinToRemove&#125;</code>的最快方式。其他参数（<code>stats</code> 和 <code>filterSelectivities</code>）传递到你必须作为练习4的一部分实现的<code>orderJoins</code>方法中，并在下面进行解释。该方法基本上执行先前描述的伪代码的第6到8行。</p>
<p>接下来，我们提供了方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printJoins</span><span class="params">(List&lt;LogicalJoinNode&gt; js, </span></span><br><span class="line"><span class="params">                        PlanCache pc,</span></span><br><span class="line"><span class="params">                        Map&lt;String, TableStats&gt; stats,</span></span><br><span class="line"><span class="params">                        Map&lt;String, Double&gt; selectivities)</span></span><br></pre></td></tr></table></figure>

<p>这个方法可用于显示连接计划的图形表示（例如，当通过优化器的“-explain”选项设置“explain”标志时）。</p>
<p>第四，我们提供了一个名为<code>PlanCache</code>的类，它可以用于缓存到目前为止在你的<code>Selinger</code>实现中考虑的连接子集的最佳连接方式（使用<code>computeCostAndCardOfSubplan</code>需要此类的一个实例）。</p>
<hr>
<h3 id="Exercise-4-Join-Ordering"><a href="#Exercise-4-Join-Ordering" class="headerlink" title="Exercise 4: Join Ordering"></a><strong>Exercise 4: Join Ordering</strong></h3><p>在<code>JoinOptimizer.java</code>中实现方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;LogicalJoinNode&gt; <span class="title function_">orderJoins</span><span class="params">(Map&lt;String, TableStats&gt; stats, </span></span><br><span class="line"><span class="params">                   Map&lt;String, Double&gt; filterSelectivities,  </span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> explain)</span></span><br></pre></td></tr></table></figure>

<p>这个方法应该操作 <code>joins</code> 类成员，返回一个新的列表，指定连接应该执行的顺序。列表的第一个项指示左侧最底部的连接在左深计划中的位置。返回的列表中相邻的连接应该共享至少一个字段，以确保计划是左深的。其中，<code>stats</code> 是一个允许你查找查询的 <code>FROM</code> 列表中出现的给定表名的 <code>TableStats</code> 的对象。<code>filterSelectivities</code>允许你查找任何谓词在表上的选择性；它保证对于查询的 <code>FROM</code> 列表中的每个表名都有一个条目。最后，<code>explain</code> 指定你应该输出连接顺序的表示，用于信息目的。</p>
<p>你可能希望使用上述描述的辅助方法和类来帮助实现。大致而言，你的实现应该遵循上述伪代码，循环遍历子集大小、子集和子集的子计划，调用 <code>computeCostAndCardOfSubplan</code> 并构建一个 PlanCache 对象，用于存储执行每个子集连接的最小成本方式。</p>
<p>在实现了这个方法之后，你应该能够通过 <code>JoinOptimizerTest</code> 中的所有单元测试。你还应该通过系统测试 <code>QueryTest</code>。</p>
<h3 id="额外挑战"><a href="#额外挑战" class="headerlink" title="额外挑战"></a>额外挑战</h3><p>在本节中，我们将介绍几个可选练习，您可以通过这些练习获得额外学分。这些练习没有前面的练习那么明确，但可以让您有机会展示您对查询优化的掌握！请在报告中明确标出您选择完成的练习，并简要说明您的实施情况和结果（基准数据、经验报告等）。</p>
<hr>
<p>奖励练习。每项奖励最多可获得 5%的额外学分：</p>
<ul>
<li>添加代码来执行更先进的连接基数估计。而不是使用简单的启发式搜索来评估连接基数，设计一个更复杂的算法：<ul>
<li>一种方法是在每对表 t1 和 t2 中的每对属性 a 和 b 之间使用联合直方图。我们的想法是创建属性a的桶，并为每个 a桶中的桶 A 创建一个与 A 中的 a 值共同出现的 b 值直方图。</li>
<li>估计连接基数的另一种方法是假设较小表中的每个值都与较大表中的一个匹配值相对应。然后，连接选择性的计算公式为：<code>1 /(Max( num-distinct(t1，column1)</code>，<code>num-distinct(t2，column2)))</code>。这里，column1 和 column2 是连接的属性。连接的基数然后是 t1 和 t2 的基数乘以选择性的乘积。</li>
</ul>
</li>
<li>改进子集迭代器。我们的<code>enumerateSubsets</code>实现效率相当低，因为每次调用都会创建大量的Java对象。在这个附加练习中，您将提高enumerateSubsets的性能，以便系统可以在包含20个或更多连接的计划上执行查询优化（目前这样的计划需要几分钟甚至几小时来计算）。</li>
<li>考虑缓存的成本模型。用于估算扫描和连接成本的方法并未考虑缓存在缓冲池中的影响。您应该扩展成本模型以考虑缓存效果。由于多个连接同时运行，这是一个棘手的问题，因此可能难以预测每个连接将使用先前实现的简单缓冲池时将访问多少内存。</li>
<li>改进连接算法和算法选择。我们当前的成本估算和连接操作选择算法（请参见JoinOptimizer.java中的instantiateJoin()）仅考虑嵌套循环连接。扩展这些方法以使用一个或多个附加的连接算法（例如，使用HashMap进行内存哈希）。</li>
<li>丛生计划。改进提供的<code>orderJoins()</code>和其他辅助方法以生成丛生连接。我们的查询计划生成和可视化算法完全能够处理丛生计划；例如，如果<code>orderJoins()</code>返回列表（t1 join t2；t3 join t4；t2 join t3），则对应于一个具有(t2 join t3)节点在顶部的丛生计划。</li>
</ul>
<hr>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/../../../../img/Pasted%20image%2020240206203213.png"><br>查询优化器：优化器的目的是按照一定原则来得到她认为的目标SQL在当前情形下最有效的执行路径,优化器的目的是为了得到目标SQL的执行计划。</p>
<p>传统关系型数据库里面的优化器分为<strong>CBO</strong>和<strong>RBO</strong>两种。<br>**RBO— Rule_Based Potimizer基于规则的优化器:</p>
<p>RBO所用的判断规则是一组内置的规则，这些规则是硬编码在数据库的编码中的，RBO会根据这些规则去从SQL诸多的路径中来选择一条作为执行计划（比如在RBO里面，有这么一条规则：有索引使用索引。那么所有带有索引的表在任何情况下都会走索引）所以，RBO现在被很多数据库抛弃（oracle默认是CBO，但是仍然保留RBO代码，MySQL只有CBO）</p>
<p>RBO最大问题在于硬编码在数据库里面的一系列固定规则，来决定执行计划。并没有考虑目标SQL中所涉及的对象的实际数量，实际数据的分布情况，这样一旦规则不适用于该SQL，那么很可能选出来的执行计划就不是最优执行计划了。</p>
<p>**CBO—Cost_Based Potimizer基于成本的优化器:</p>
<p>CBO在会从目标诸多的执行路径中选择一个成本最小的执行路径来作为执行计划。这里的成本他实际代表了MySQL根据相关统计信息计算出来目标SQL对应的步骤的IO，CPU等消耗。也就是意味着数据库里的成本实际上就是对于执行目标SQL所需要IO,CPU等资源的一个估计值。而成本值是根据索引，表，行的统计信息计算出来的。(计算过程比较复杂)</p>
<p>本实验是基于CBO的，即评估成本。包括CPU，I&#x2F;O。Lab3主要针对SQL查询中的查询优化器部分实现。本实验仅需要实现<code>过滤选择性</code>和<code>连接成本</code>。</p>
<h2 id="构建直方图"><a href="#构建直方图" class="headerlink" title="构建直方图"></a>构建直方图</h2><p>构建直方图的思想是对于表的每个属性都基于属性的值建立一张直方图，并假设属性的取值尽可能均匀。以此来大致估算在某个谓词下，可能的过滤选择性值为多少。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">estimateSelectivity</span><span class="params">(Predicate.Op op, <span class="type">int</span> v)</span> &#123;  </span><br><span class="line">    <span class="keyword">switch</span> (op)&#123;  </span><br><span class="line">        <span class="keyword">case</span> EQUALS:&#123;  </span><br><span class="line">            <span class="keyword">return</span> estimateEqual(v);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">case</span> GREATER_THAN:&#123;  </span><br><span class="line">            <span class="keyword">return</span> estimateGreat(v);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">case</span> LESS_THAN:&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>-(estimateSelectivity(Predicate.Op.GREATER_THAN_OR_EQ,v));  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">case</span> LESS_THAN_OR_EQ:&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>-estimateGreat(v);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">case</span> GREATER_THAN_OR_EQ:&#123;  </span><br><span class="line">            <span class="keyword">return</span> estimateGreat(v)+estimateEqual(v);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">case</span> LIKE:&#123;  </span><br><span class="line">            <span class="keyword">return</span> estimateEqual(v);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">case</span> NOT_EQUALS:&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span> - estimateEqual(v);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   <span class="comment">// some code goes here  </span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1.0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.bctNum; i++) &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> i== <span class="built_in">this</span>.bctNum-<span class="number">1</span>?<span class="built_in">this</span>.max-<span class="built_in">this</span>.min+<span class="number">1</span>-<span class="built_in">this</span>.interval*(<span class="built_in">this</span>.bctNum-<span class="number">1</span>):<span class="built_in">this</span>.interval;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="built_in">this</span>.min + i*interval;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + w -<span class="number">1</span>;  </span><br><span class="line">        sb.append(String.format(<span class="string">&quot;[%d,%d]:%d\n&quot;</span>,left,right,<span class="built_in">this</span>.backets[i]));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> sb.toString();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> <span class="title function_">estimateGreat</span><span class="params">(<span class="type">int</span> v)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (v&lt;<span class="built_in">this</span>.min)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (v&gt;=<span class="built_in">this</span>.max)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> vToIdx(v);  </span><br><span class="line">    <span class="comment">// to solve difference the width of last backet  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> idx == <span class="built_in">this</span>.bctNum-<span class="number">1</span>?<span class="built_in">this</span>.max-<span class="built_in">this</span>.min+<span class="number">1</span>-<span class="built_in">this</span>.interval*(<span class="built_in">this</span>.bctNum-<span class="number">1</span>):<span class="built_in">this</span>.interval;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="built_in">this</span>.backets[idx];  </span><br><span class="line">    <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> (v-<span class="built_in">this</span>.min)-idx*<span class="built_in">this</span>.interval;  </span><br><span class="line">    <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0.0</span>;  </span><br><span class="line">    res += ((w-mod-<span class="number">1</span>)/(w*<span class="number">1.0</span>)) * (h*<span class="number">1.0</span>)/(<span class="built_in">this</span>.total*<span class="number">1.0</span>);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx+<span class="number">1</span>; i &lt; <span class="built_in">this</span>.bctNum; i++) &#123;  </span><br><span class="line">        res += (<span class="built_in">this</span>.backets[i]*<span class="number">1.0</span>)/(<span class="built_in">this</span>.total*<span class="number">1.0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述实现假定某属性取值最大为<code>max</code>,最小为<code>min</code>，桶的数量为<code>bctNum</code>。因此每个桶的区间长度为<code>(max-min+1)/bctNum</code>。如果不能够整除，则最后一个桶的长度会比其他桶多<code>(max-min+1)/%bctNum</code>。比如<code>min=0,max=10,bctNum=3</code>则每个桶负责的区间依次为<code>[0,1,2],[3,4,5],[6,7,8,9,10]</code>。在实现的时候需要特别考虑数落到最后一个桶的情况。</p>
<p>不同的谓词实现技巧：比如大于号和小于等于号的关系。</p>
<h2 id="计算连接成本"><a href="#计算连接成本" class="headerlink" title="计算连接成本"></a>计算连接成本</h2><p>连接基数估计<br>连接基数估计是指在按某些谓词条件下<code>join</code>两个表时，结果中的行数估计值。显而易见，这个值应该不大于<code>M * N</code>，<code>M</code>和<code>N</code>分别指两表的行数。</p>
<ul>
<li>对于等值连接，即 <code>join on t1.field1=t2.field2</code>。如果<code>field1</code>或<code>field2</code>是主键，那么连接后的指不可能超过非主键表的数量。因为对于非主键表中的每条记录，在主键表中最多只有一条和他匹配。（因为主键不可能重复）。</li>
<li>对于等值连接，且都不是主键的情况。这种情况很难估计，采用了额外挑战中<code>1 /(Max( num-distinct(t1，column1)</code>，<code>num-distinct(t2，column2)))</code>的实现。这里<code>num-distinct</code>指表1中column1去重取值后的集合，也就是有多少个不同的取值。这个评估基于一个前提，认为该属性取每个值的数量是尽可能平衡的。那么对于另一个表中的每条记录，最多有<code>M/num-distinct(t1，column1)*N</code>条记录和它匹配。反之，如果以另一表作为基准，最多有<code>N/num-distinct(t2，column2)*M</code>。取两者的较小值作为评估值即可。（为什么取较小值，因为假设连接的数量为<code>res</code>，<code>res&lt;res1且res&lt;res2</code>即<code>res</code>小于两者较小值。）</li>
<li>对于非等值的连接，同样很难估计。输出的大小应该与输入的大小成正比。假设范围扫描会产生固定比例的交叉积（例如 **30%**）也是可以的。一般来说，范围连接的成本应该大于两个相同大小表的非主键相等连接的成本。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">estimateTableJoinCardinality</span><span class="params">(Predicate.Op joinOp,  </span></span><br><span class="line"><span class="params">                                               String table1Alias, </span></span><br><span class="line"><span class="params">                                               String table2Alias,String field1PureName,  </span></span><br><span class="line"><span class="params">                                               String field2PureName, </span></span><br><span class="line"><span class="params">                                               <span class="type">int</span> card1, <span class="type">int</span> card2,</span></span><br><span class="line"><span class="params">                                               <span class="type">boolean</span> t1pkey,<span class="type">boolean</span> t2pkey, </span></span><br><span class="line"><span class="params">                                               Map&lt;String, TableStats&gt; stats,  </span></span><br><span class="line"><span class="params">                                               Map&lt;String, Integer&gt; tableAliasToId)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">card</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line">    <span class="comment">// some code goes here  </span></span><br><span class="line">    <span class="keyword">if</span> (joinOp.equals(Predicate.Op.EQUALS))&#123;  </span><br><span class="line">        <span class="keyword">if</span> (t1pkey || t2pkey)&#123;  </span><br><span class="line">            <span class="keyword">if</span> (t1pkey &amp;&amp; !t2pkey)&#123;  </span><br><span class="line">                card = card2;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!t1pkey &amp;&amp; t2pkey)&#123;  </span><br><span class="line">                card = card1;  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                card = Math.min(card1,card2);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="comment">// improved method  </span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">tabldId1</span> <span class="operator">=</span> tableAliasToId.get(table1Alias);  </span><br><span class="line">            <span class="type">Integer</span> <span class="variable">tabldId2</span> <span class="operator">=</span> tableAliasToId.get(table2Alias);  </span><br><span class="line">            <span class="type">String</span> <span class="variable">tableName1</span> <span class="operator">=</span> Database.getCatalog().getTableName(tabldId1);  </span><br><span class="line">            <span class="type">String</span> <span class="variable">tableName2</span> <span class="operator">=</span> Database.getCatalog().getTableName(tabldId2);  </span><br><span class="line">            <span class="type">TableStats</span> <span class="variable">stats1</span> <span class="operator">=</span> stats.get(tableName1);  </span><br><span class="line">            <span class="type">TableStats</span> <span class="variable">stats2</span> <span class="operator">=</span> stats.get(tableName2);  </span><br><span class="line">            <span class="type">int</span> <span class="variable">distinct1</span> <span class="operator">=</span> stats1.getFieldDistinct(Database.getCatalog().getTupleDesc(tabldId1).fieldNameToIndex(field1PureName));  </span><br><span class="line">            <span class="type">int</span> <span class="variable">distinct2</span> <span class="operator">=</span> stats2.getFieldDistinct(Database.getCatalog().getTupleDesc(tabldId2).fieldNameToIndex(field2PureName));  </span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>)((card1 * card2 * <span class="number">1.0</span>)/(Math.max(distinct1,distinct2)));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Math.max((<span class="type">int</span>)(<span class="number">0.3</span>*(card1 * card2)),Math.max(card1,card2));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> card &lt;= <span class="number">0</span> ? <span class="number">1</span> : card;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计算连接顺序"><a href="#计算连接顺序" class="headerlink" title="计算连接顺序"></a>计算连接顺序</h2><p>考虑到不同的连接顺序产生的成本不同。<br>比如<code>t1 join t2</code>的成本大致为：<br><code>card1 * card2 * 1.0 + cost1 + card1 * cost2</code><br>而<code>t2 join t1</code>的成本大致为：<br><code>card1 * card2 * 1.0 + cost2 + card2 * cost1</code><br>我们需要计算给定的查询计划中，可能的连接顺序成本最小的方案。这里通过DFS枚举了所有连接顺序，然后通过DP算法来计算每种连接次序所需的成本。假设对于需要<code>join</code>的三个节点<code>A,B,C</code>,我们如果知道了<code>A,B</code>连接（可能的其中一个子计划）具有最小成本的顺序为<code>AB</code>,那么只需要考虑<code>C(AB),(AB)C</code>，当然还需要考虑将<code>BC</code>或<code>AC</code>先连接的情况。我们称<code>AB,BC,AC</code>为子计划，将他们进行缓存，之后就可以快速得到<code>A和B</code>，<code>B和C</code>，<code>A和C</code>连接的最佳顺序。源文件提供了给定连接的子集（<code>joinSet</code>）和要从该集合中移除的连接（<code>joinToRemove</code>），此方法计算将<code>joinToRemove</code>连接到<code>joinSet - &#123;joinToRemove&#125;</code> 的最佳方式。上述的<code>C</code><br>节点在这是<code>joinToRemove</code>，<code>s</code>是指集合<code>&#123;A,B,C&#125;</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;LogicalJoinNode&gt; <span class="title function_">orderJoins</span><span class="params">(  </span></span><br><span class="line"><span class="params">        Map&lt;String, TableStats&gt; stats,  </span></span><br><span class="line"><span class="params">        Map&lt;String, Double&gt; filterSelectivities, <span class="type">boolean</span> explain)</span>  </span><br><span class="line">        <span class="keyword">throws</span> ParsingException &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// some code goes here  </span></span><br><span class="line">    <span class="comment">//Replace the following    PlanCache pc = new PlanCache();  </span></span><br><span class="line">    <span class="type">CostCard</span> <span class="variable">bCard</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="built_in">this</span>.joins.size(); i++) &#123;  </span><br><span class="line">        Set&lt;Set&lt;LogicalJoinNode&gt;&gt; jsSets = enumerateSubsets(<span class="built_in">this</span>.joins, i);  </span><br><span class="line">        <span class="keyword">for</span> (Set&lt;LogicalJoinNode&gt; s : jsSets) &#123;  </span><br><span class="line">            <span class="type">CostCard</span> <span class="variable">bestCard</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">            <span class="keyword">for</span> (LogicalJoinNode remove : s) &#123;  </span><br><span class="line">                <span class="type">CostCard</span> <span class="variable">costCard</span> <span class="operator">=</span> computeCostAndCardOfSubplan(stats, filterSelectivities, remove, s, bestCard==<span class="literal">null</span>?Double.MAX_VALUE:bestCard.cost, pc);  </span><br><span class="line">                <span class="keyword">if</span> (costCard!=<span class="literal">null</span>)&#123;  </span><br><span class="line">                    <span class="keyword">if</span> (bestCard==<span class="literal">null</span> || (bestCard!=<span class="literal">null</span>&amp;&amp;costCard.cost&lt;bestCard.cost))&#123;  </span><br><span class="line">                        bestCard = costCard;  </span><br><span class="line">                        <span class="keyword">if</span> (i==<span class="built_in">this</span>.joins.size())&#123;  </span><br><span class="line">                            bCard = costCard;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (bestCard!=<span class="literal">null</span>)&#123;  </span><br><span class="line">                pc.addPlan(s,bestCard.cost,bestCard.card,bestCard.plan);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    List&lt;LogicalJoinNode&gt; js = <span class="built_in">this</span>.joins;  </span><br><span class="line">    <span class="keyword">if</span> (bCard!=<span class="literal">null</span>)&#123;  </span><br><span class="line">        js = bCard.plan;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (explain)&#123;  </span><br><span class="line">        printJoins(js,pc,stats,filterSelectivities);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> js;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://leggasai.github.io">LegGasai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://leggasai.github.io/posts/3de20a60/">https://leggasai.github.io/posts/3de20a60/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://leggasai.github.io" target="_blank">LegGasai's CSLearning</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF/">后端</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.PNG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/4ae53af6/" title="MIT6.830-Lab2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MIT6.830-Lab2</div></div></a></div><div class="next-post pull-right"><a href="/posts/a3869fc3/" title="MIT6.830-Lab4"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MIT6.830-Lab4</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/968190ef/" title="UCB CS186"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-17</div><div class="title">UCB CS186</div></div></a></div><div><a href="/posts/51e51a3e/" title="CMU 15-445"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-17</div><div class="title">CMU 15-445</div></div></a></div><div><a href="/posts/7700681/" title="MIT6.830"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-29</div><div class="title">MIT6.830</div></div></a></div><div><a href="/posts/d3ec6b4c/" title="MIT6.830-Lab1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-25</div><div class="title">MIT6.830-Lab1</div></div></a></div><div><a href="/posts/4ae53af6/" title="MIT6.830-Lab2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-29</div><div class="title">MIT6.830-Lab2</div></div></a></div><div><a href="/posts/d481af55/" title="MIT6.830-Lab5"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-09</div><div class="title">MIT6.830-Lab5</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LegGasai</div><div class="author-info__description">作者描述</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LegGasai"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/LegGasai" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:jyc132780208@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_56522574" target="_blank" title="'#hdhfbb'"><i class="fa-solid fa-blog"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to my blog☺</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA"><span class="toc-number">2.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%A4%A7%E7%BA%B2"><span class="toc-number">3.</span> <span class="toc-text">优化大纲</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">优化器结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E4%BC%B0%E7%AE%97"><span class="toc-number">3.2.</span> <span class="toc-text">统计估算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E8%AE%A1%E5%88%92%E6%88%90%E6%9C%AC"><span class="toc-number">3.2.1.</span> <span class="toc-text">整体计划成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%88%90%E6%9C%AC"><span class="toc-number">3.2.2.</span> <span class="toc-text">连接成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E9%80%89%E6%8B%A9%E6%80%A7"><span class="toc-number">3.2.3.</span> <span class="toc-text">过滤器的选择性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercise-1-IntHistogram-java"><span class="toc-number">3.2.4.</span> <span class="toc-text">Exercise 1: IntHistogram.java</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercise-2-TableStats-java"><span class="toc-number">3.2.5.</span> <span class="toc-text">Exercise 2: TableStats.java</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Join-Cardinality"><span class="toc-number">3.2.6.</span> <span class="toc-text">Join Cardinality</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercise-3-Join-Cost-Estimation"><span class="toc-number">3.2.7.</span> <span class="toc-text">Exercise 3: Join Cost Estimation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Join-Ordering"><span class="toc-number">3.2.8.</span> <span class="toc-text">Join Ordering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercise-4-Join-Ordering"><span class="toc-number">3.2.9.</span> <span class="toc-text">Exercise 4: Join Ordering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E6%8C%91%E6%88%98"><span class="toc-number">3.2.10.</span> <span class="toc-text">额外挑战</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E7%9B%B4%E6%96%B9%E5%9B%BE"><span class="toc-number">4.1.</span> <span class="toc-text">构建直方图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E8%BF%9E%E6%8E%A5%E6%88%90%E6%9C%AC"><span class="toc-number">4.2.</span> <span class="toc-text">计算连接成本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E8%BF%9E%E6%8E%A5%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.3.</span> <span class="toc-text">计算连接顺序</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/6c92115f/" title="Spring">Spring</a><time datetime="2024-03-21T06:21:09.000Z" title="发表于 2024-03-21 14:21:09">2024-03-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/bcab05d2/" title="实现RPC框架——gsRPC">实现RPC框架——gsRPC</a><time datetime="2024-03-19T14:12:22.000Z" title="发表于 2024-03-19 22:12:22">2024-03-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1c6ba3e2/" title="Netty">Netty</a><time datetime="2024-03-10T06:30:59.000Z" title="发表于 2024-03-10 14:30:59">2024-03-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/a0419e9f/" title="CSAPP">CSAPP</a><time datetime="2024-03-09T07:49:06.000Z" title="发表于 2024-03-09 15:49:06">2024-03-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/364ea8cc/" title="设计模式">设计模式</a><time datetime="2024-03-04T13:40:29.000Z" title="发表于 2024-03-04 21:40:29">2024-03-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/footer.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By LegGasai</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-vercel-aspa.vercel.app',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>