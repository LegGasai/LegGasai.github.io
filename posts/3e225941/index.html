<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java并发编程 | LegGasai's CSLearning</title><meta name="author" content="LegGasai"><meta name="copyright" content="LegGasai"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="一、基本概念1.1 概念串行、并行、并发串行：多个程序按序执行。上一个做完，接着做下一个。并行：多个程序同时执行，一般需要多核处理器的支持。并发：多个程序交错执行，就像看上去是同时执行的一样。 同步异步、阻塞非阻塞同步和异步：当前线程是否需要等待方法调用执行完毕。 1234567891011121314&#x2F;&#x2F; 同步isFinished &#x3D; doTask();&#x2F;&#x2F; wait for finished">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程">
<meta property="og:url" content="https://leggasai.github.io/posts/3e225941/index.html">
<meta property="og:site_name" content="LegGasai&#39;s CSLearning">
<meta property="og:description" content="一、基本概念1.1 概念串行、并行、并发串行：多个程序按序执行。上一个做完，接着做下一个。并行：多个程序同时执行，一般需要多核处理器的支持。并发：多个程序交错执行，就像看上去是同时执行的一样。 同步异步、阻塞非阻塞同步和异步：当前线程是否需要等待方法调用执行完毕。 1234567891011121314&#x2F;&#x2F; 同步isFinished &#x3D; doTask();&#x2F;&#x2F; wait for finished">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leggasai.github.io/img/avatar.PNG">
<meta property="article:published_time" content="2024-02-19T13:28:56.000Z">
<meta property="article:modified_time" content="2024-03-24T14:40:30.971Z">
<meta property="article:author" content="LegGasai">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leggasai.github.io/img/avatar.PNG"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://leggasai.github.io/posts/3e225941/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java并发编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-24 22:40:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.PNG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 博客</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/top.png')"><nav id="nav"><span id="blog-info"><a href="/" title="LegGasai's CSLearning"><span class="site-name">LegGasai's CSLearning</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 博客</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-19T13:28:56.000Z" title="发表于 2024-02-19 21:28:56">2024-02-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-24T14:40:30.971Z" title="更新于 2024-03-24 22:40:30">2024-03-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java并发编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p><strong>串行、并行、并发</strong><br>串行：多个程序按序执行。上一个做完，接着做下一个。<br>并行：多个程序同时执行，一般需要多核处理器的支持。<br>并发：多个程序交错执行，就像看上去是同时执行的一样。</p>
<p><strong>同步异步、阻塞非阻塞</strong><br>同步和异步：当前线程是否需要等待方法调用执行完毕。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步</span></span><br><span class="line">isFinished = doTask();</span><br><span class="line"><span class="comment">// wait for finished </span></span><br><span class="line"><span class="keyword">if</span> isFinished&#123;</span><br><span class="line">	<span class="comment">// 任务完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步</span></span><br><span class="line">doTask(&#123;</span><br><span class="line">	<span class="comment">// 任务完成</span></span><br><span class="line">	<span class="comment">// 执行回调</span></span><br><span class="line">	send a message</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在异步调用下的代码逻辑相对而言不太直观，需要借助回调或事件通知，这在复杂逻辑下对编码能力的要求较高。而同步调用就是直来直去，等待执行完毕然后拿到结果紧接着执行下面的逻辑，对编码能力的要求较低，也更不容易出错。<br>所以你会发现有很多方法它是异步调用的方式，但是最终的使用还是异步转同步。<br>比如你向线程池提交一个任务，得到一个<code>future</code>，此时是异步的，然后你在紧接着在代码里调用 <code>future.get()</code>，那就变成等待这个任务执行完成，这就是所谓的异步转同步，像 Dubbo RPC 调用同步得到返回结果就是这样实现的。</p>
<p>阻塞和非阻塞：当前接口数据还未准备就绪时，线程是否被阻塞挂起。<br>何为阻塞挂起？就是当前线程还处于 CPU 时间片当中，调用了阻塞的方法，由于数据未准备就绪，则时间片还未到就让出 CPU。所以阻塞和同步看起来都是等，但是本质上它们不一样，同步的时候可没有让出 CPU。一旦同步结束，CPU可立马执行接下去的代码。</p>
<p>而非阻塞就是当前接口数据还未准备就绪时，线程不会被阻塞挂起，可以不断轮询请求接口，看看数据是否已经准备就绪。</p>
<h2 id="1-2-线程的状态"><a href="#1-2-线程的状态" class="headerlink" title="1.2 线程的状态"></a>1.2 线程的状态</h2><p><img src="/../../../img/Pasted%20image%2020240220120821.png"></p>
<ul>
<li>NEW：Thread对象被创建出来了，但是还没有执行start方法。</li>
<li>RUNNABLE：Thread对象调用了start方法，就为RUNNABLE状态（CPU调度&#x2F;没有调度）</li>
<li>BLOCKED、WAITING、TIME_WAITING：都可以理解为是阻塞、等待状态，因为处在这三种状态下，CPU不会调度当前线程</li>
<li>BLOCKED：synchronized没有拿到同步锁，被阻塞的情况</li>
<li>WAITING：调用wait方法就会处于WAITING状态，需要被手动唤醒（notify或notifyAll）</li>
<li>TIME_WAITING：调用sleep方法、join方法、wait(long timeout)，会被自动唤醒，无需手动唤醒</li>
<li>TERMINATED：run方法执行完毕，线程生命周期到头了</li>
</ul>
<h1 id="二、线程的创建"><a href="#二、线程的创建" class="headerlink" title="二、线程的创建"></a>二、线程的创建</h1><h2 id="2-1-继承Thread类"><a href="#2-1-继承Thread类" class="headerlink" title="2.1 继承Thread类"></a>2.1 继承Thread类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leggasai.concurrent;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">// thread 1  </span></span><br><span class="line">        <span class="type">MyJob</span> <span class="variable">worker1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyJob</span>();  </span><br><span class="line">        worker1.start();  </span><br><span class="line">        <span class="comment">// thread 2  </span></span><br><span class="line">        <span class="type">MyJob</span> <span class="variable">worker2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyJob</span>();  </span><br><span class="line">        worker2.start();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// error!  </span></span><br><span class="line">        <span class="comment">// 调用run方法只会在当前线程执行执行run方法内部代码  </span></span><br><span class="line">        <span class="comment">// 调用start方法才会新建一个线程，去执行  </span></span><br><span class="line">        <span class="comment">// worker1.run();  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyJob</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">&quot;:&quot;</span>+<span class="string">&quot;I am working!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-实现Runnable"><a href="#2-2-实现Runnable" class="headerlink" title="2.2 实现Runnable"></a>2.2 实现Runnable</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leggasai.concurrent;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRun</span>());  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">&quot;:&quot;</span> + <span class="string">&quot;I am working!&quot;</span>);  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">                System.out.println(Thread.currentThread().getId() + <span class="string">&quot;:&quot;</span> + <span class="string">&quot;I am working!&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        worker1.start();  </span><br><span class="line">        worker2.start();  </span><br><span class="line">        worker3.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRun</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">&quot;:&quot;</span>+<span class="string">&quot;I am working!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-实现Callable"><a href="#2-3-实现Callable" class="headerlink" title="2.3 实现Callable"></a>2.3 实现Callable</h2><p>实现Callable接口，可以创建具有返回值的线程。需要配合<code>FutureTask</code>使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCall</span>());  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);  </span><br><span class="line">        worker1.start();  </span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> (String)futureTask.get();  </span><br><span class="line">        System.out.println(res);  </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCall</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getId()+<span class="string">&quot;:&quot;</span>+<span class="string">&quot;I am working!&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-线程池"><a href="#2-4-线程池" class="headerlink" title="2.4 线程池"></a>2.4 线程池</h2><p>在大型应用中，一般都是使用线程池去并发执行多个任务，因为线程池实际上已经创建好了若干个活跃的线程，省去了创建线程的时间，具有更高的效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">threadPoolDemo</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="comment">// 创建大小为3的线程池  </span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);  </span><br><span class="line">    <span class="comment">// 提交多个任务给线程池执行  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;  </span><br><span class="line">        <span class="type">MyRun</span> <span class="variable">myRun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRun</span>();  </span><br><span class="line">        executorService.execute(myRun);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 关闭线程池  </span></span><br><span class="line">    executorService.shutdown();  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRun</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">&quot;:&quot;</span>+<span class="string">&quot;I am working!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、线程的使用"><a href="#三、线程的使用" class="headerlink" title="三、线程的使用"></a>三、线程的使用</h1><h3 id="3-1-获取线程信息"><a href="#3-1-获取线程信息" class="headerlink" title="3.1 获取线程信息"></a>3.1 获取线程信息</h3><p>获取当前线程<code>Thread.currentThread()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Thread.currentThread());</span><br><span class="line"><span class="comment">// Thread[Thread-0,5,main]</span></span><br></pre></td></tr></table></figure>

<p>获取线程相关信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(thread.getId());  </span><br><span class="line">System.out.println(thread.getName());  </span><br><span class="line">System.out.println(thread.getState());  </span><br><span class="line">System.out.println(thread.getPriority());  </span><br><span class="line">System.out.println(thread.getUncaughtExceptionHandler());  </span><br><span class="line">System.out.println(thread.getThreadGroup());</span><br><span class="line"></span><br><span class="line"><span class="number">20</span></span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line">RUNNABLE</span><br><span class="line"><span class="number">5</span></span><br><span class="line">java.lang.ThreadGroup[name=main,maxpri=<span class="number">10</span>]</span><br><span class="line">java.lang.ThreadGroup[name=main,maxpri=<span class="number">10</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-2-设置线程相关信息"><a href="#3-2-设置线程相关信息" class="headerlink" title="3.2 设置线程相关信息"></a>3.2 设置线程相关信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread.setName(<span class="string">&quot;my thread&quot;</span>);  </span><br><span class="line">thread.setPriority(<span class="number">10</span>);  </span><br><span class="line">System.out.println(thread.getName());  </span><br><span class="line">System.out.println(thread.getPriority());</span><br><span class="line"></span><br><span class="line">t1.setDaemon(<span class="literal">true</span>);  </span><br><span class="line">System.out.println(t1.isDaemon());</span><br></pre></td></tr></table></figure>

<p>线程的优先级：范围1-10。数值越高意味着优先级越高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="number">1</span>);  </span><br><span class="line">    &#125;);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="number">2</span>);  </span><br><span class="line">    &#125;);  </span><br><span class="line">    t1.setPriority(<span class="number">1</span>);  </span><br><span class="line">    t2.setPriority(<span class="number">10</span>);  </span><br><span class="line">    t1.start();  </span><br><span class="line">    t2.start();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本先执行t2,后执行t1</span></span><br></pre></td></tr></table></figure>


<p>线程让步<code>Thread.yield()</code>：当前线程向处理器表明自己可以让步，放弃CPU使用权让给其他<strong>相同优先级</strong>线程。这并不是一个强制性的指令，而是一个建议，具体实现依赖于底层操作系统的线程调度器。该方法一般很少使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">50</span>)&#123;  </span><br><span class="line">                Thread.<span class="keyword">yield</span>();  </span><br><span class="line">            &#125;  </span><br><span class="line">            System.out.println(<span class="string">&quot;t1:&quot;</span> + i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;t2:&quot;</span> + i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    t2.start();  </span><br><span class="line">    t1.start();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// t1大概率输出到49时，会让t2执行一段时间,比如输出大致如下</span></span><br><span class="line">...</span><br><span class="line">t1:<span class="number">47</span></span><br><span class="line">t1:<span class="number">48</span></span><br><span class="line">t1:<span class="number">49</span></span><br><span class="line">t2:<span class="number">0</span></span><br><span class="line">t2:<span class="number">1</span></span><br><span class="line">t2:<span class="number">2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面这种情况，<code>yield</code>无法生效，因为<code>yield()</code>不会释放锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;  </span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">50</span>)&#123;  </span><br><span class="line">                    Thread.<span class="keyword">yield</span>();  </span><br><span class="line">                &#125;  </span><br><span class="line">                System.out.println(<span class="string">&quot;t1:&quot;</span> + i);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;t2:&quot;</span> + i);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    t1.start();  </span><br><span class="line">    t2.start();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程休眠<code>Thread.sleep()</code>：使得线程暂停执行一段时间进入时间等待状态，会让出CPU，但不会让出锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    System.out.println(System.currentTimeMillis());  </span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">    System.out.println(System.currentTimeMillis());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程<code>join()</code>方法：使得当前线程等待被调用<code>join()</code>方法的线程执行结束。<br>下面代码中，由于设置<code>t1</code>为守护线程，<code>main</code>线程不会等待<code>t1</code>执行结束才结束，因此会直接结束运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    t1.setDaemon(<span class="literal">true</span>);  </span><br><span class="line">    t1.start();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>t1.join()</code>方法后，<code>main</code>线程会等待<code>t1</code>执行结束后，在继续运行。因此控制台可输出1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">            System.out.println(<span class="number">1</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    t1.setDaemon(<span class="literal">true</span>);  </span><br><span class="line">    t1.start();  </span><br><span class="line">    <span class="comment">// 等待t1执行结束  </span></span><br><span class="line">    t1.join();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>守护线程 vs 非守护线程</p>
<ul>
<li>默认情况下，线程都是非守护线程。</li>
<li>守护线程是一种在程序运行时，在后台提供服务的线程，随着非守护线程的结束而自动退出。</li>
<li>主线程默认是非守护线程，如果主线程执行结束，需要查看当前JVM内是否还有非守护线程，如果没有JVM直接停止</li>
<li>可以通过<code>setDaemon和isDaemon</code>来设置守护线程和查看是否是守护线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">            System.out.println(<span class="string">&quot;非守护线程执行结束:&quot;</span>+System.currentTimeMillis());  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    t1.start();  </span><br><span class="line">    System.out.println(<span class="string">&quot;等待非守护线程执行结束:&quot;</span>+System.currentTimeMillis());  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待非守护线程执行结束:1708408152713</span></span><br><span class="line"><span class="comment">//     非守护线程执行结束:1708408153719</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-3-线程的等待和唤醒（重点）"><a href="#3-3-线程的等待和唤醒（重点）" class="headerlink" title="3.3 线程的等待和唤醒（重点）"></a>3.3 线程的等待和唤醒（重点）</h3><p><code>wait()/wait(timeout)</code>：使得当前线程释放锁资源，进入等待状态，并加入<strong>等待队列</strong>。<br><code>notify()</code>：唤醒在同一个对象上调用<code>wait()</code>而进入等待队列中的某个线程，进入到<strong>锁队列</strong>。<br><code>notifyAll()</code>：唤醒在同一个对象上调用<code>wait()</code>而进入等待队列中的所有线程，进入到<strong>锁队列</strong>。<br>上述关键词必须在<code>synchronized</code>代码块内或方法体内才能调用，因为他们是基于某个对象锁的。</p>
<ol>
<li>线程A调用 <code>wait()</code> 方法，释放对象的锁，进入等待队列。</li>
<li>线程B执行一些操作，然后调用 <code>notify()</code> 方法，唤醒等待队列中的线程A。</li>
<li>线程A被唤醒后，它将进入锁队列，等待获取对象的锁。</li>
<li>当线程B释放对象的锁（例如，退出同步块或同步方法）时，线程A将有机会竞争锁，成功获取锁后继续执行。</li>
</ol>
<h3 id="3-4-线程结束"><a href="#3-4-线程结束" class="headerlink" title="3.4 线程结束"></a>3.4 线程结束</h3><p>方法一：<code>stop()</code>方法，但由于<code>stop()</code>方法会产生不可预测行为使得程序进入不一致状态，已被弃用。<br>方法二：自然结束<br>方法三：修改共享变量。务必使用<code>volatile</code>修饰共享变量，如下面的flag。原因见4.2可见性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">  </span><br><span class="line">    t1.start();  </span><br><span class="line">    Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">    System.out.println(t1.getState());  </span><br><span class="line">    flag = <span class="literal">false</span>;  </span><br><span class="line">    <span class="comment">// be sure the Thread t1 has terminated.  </span></span><br><span class="line">    Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">    System.out.println(t1.getState());  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法四：<code>interrupt()</code>方法（推荐使用）。<br>通过打断WAITING或者TIMED_WAITING状态的线程，从而抛出异常自行处理<br>这种停止线程方式是最常用的一种，在框架和JUC中也是最常见的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;  </span><br><span class="line">            <span class="comment">// 获取任务  </span></span><br><span class="line">            <span class="comment">// 拿到任务，执行任务  </span></span><br><span class="line">            <span class="comment">// 没有任务了，让线程休眠  </span></span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;基于打断形式结束当前线程&quot;</span>);  </span><br><span class="line">                <span class="keyword">return</span>;            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    t1.start();  </span><br><span class="line">    Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">    t1.interrupt();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标记法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;  </span><br><span class="line">            <span class="comment">// 获取任务  </span></span><br><span class="line">            <span class="comment">// 拿到任务，执行任务  </span></span><br><span class="line">            <span class="comment">// 没有任务了，让线程休眠  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程被打断&quot;</span>);  </span><br><span class="line">    &#125;);  </span><br><span class="line">    t1.start();  </span><br><span class="line">    Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">    t1.interrupt();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="四、并发编程"><a href="#四、并发编程" class="headerlink" title="四、并发编程"></a>四、并发编程</h1><p>三大特性：原子性、可见性、有序性。这三大特性是并发编程中需要特别关注和处理的问题，保证它们的正确性有助于避免并发引起的一系列问题，如竞态条件、死锁、活锁等。</p>
<h2 id="4-1-原子性"><a href="#4-1-原子性" class="headerlink" title="4.1 原子性"></a>4.1 原子性</h2><p><strong>原子性指一个操作是不可分割的，不可中断的，一个线程在执行时，另一个线程不会影响到他。</strong></p>
<p>JMM（Java Memory Model）。不同的硬件和不同的操作系统在内存上的操作有一定差异的。Java为了解决相同代码在不同操作系统上出现的各种问题，用JMM屏蔽掉各种硬件和操作系统带来的差异。让Java的并发编程可以做到跨平台。</p>
<p>JMM规定所有变量都会存储在主内存中，在操作的时候，需要从主内存中复制一份到线程内存（CPU内存），在线程内部做计算。然后再写回主内存中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">10</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;  </span><br><span class="line">                increment();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;  </span><br><span class="line">                increment();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">        t1.join();  </span><br><span class="line">        t2.join();  </span><br><span class="line">        System.out.println(count);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序按理应该输出200（两个线程各调用了<code>increment()</code>方法一百次），但实际最终结果往往小于200。其原因在于<code>count++</code>不满足原子性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count++不满足原子性，其可分为三步</span><br><span class="line">(<span class="number">1</span>)从内存读取count的值到CPU寄存器</span><br><span class="line">(<span class="number">2</span>)ADD操作</span><br><span class="line">(<span class="number">3</span>)将寄存器的值再写回内存中</span><br></pre></td></tr></table></figure>

<p><img src="/../../../img/Pasted%20image%2020240220162403.png"></p>
<p>考虑多线程并发执行的情况：可能会发生如下情景<br>线程#1在执行<code>count++</code>但是在写回内存之前，有另外一个线程#2也开始执行<code>count++</code>。于是对于线程#2读取到的实际可以被认为<strong>脏值</strong>，因为线程#1还没将更新值写回内存。最后线程#2将<code>count</code>+1后的新值<code>a+1</code>写回内存。明显不符合预期<code>count=a+2</code>。因为丢失了更新。<br><img src="/../../../img/Pasted%20image%2020240220162544.png"></p>
<p>如果加上<code>synchronized</code>关键词，则同一时间最多只能有一个线程访问<code>increment()</code>方法，这时流程图就变为了如下所示：这时最终值能够符合预期，因为锁的机制，使得<code>count++</code>变为了原子操作。<br><img src="/../../../img/Pasted%20image%2020240220163454.png"></p>
<p>解决方法二：原子类</p>
<p>目前Java中提供的原子类大部分底层使用了CAS锁（CompareAndSet自旋锁），如AtomicInteger、AtomicLong等；也有使用了分段锁+CAS锁的原子类，如LongAdder等。</p>
<p>解决方法三：Lock锁<br>如<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>。详见锁章节</p>
<p>解决方法四：<code>ThreadLocal类</code><br>这个类提供线程局部变量。这些变量与普通变量的不同之处在于，访问一个变量的每个线程都有自己的、独立初始化的变量副本。</p>
<p><img src="/../../../img/Pasted%20image%2020240221114630.png"></p>
<p><code>Thread</code>、<code>ThreadLocalMap</code>、<code>ThreadLocal</code>的关系如上图所示。</p>
<ul>
<li>每个<code>Thread</code>实例对象都有其各自的<code>ThreadLocalMap</code>映射，该Map存放了<code>ThreadLocal</code>到<code>Object</code>的映射</li>
<li>可以创建多个<code>ThreadLocal</code>来为每个线程存储多个线程独立的变量。</li>
<li>每个<code>Thread</code>的变量是独立的，因为<code>ThreadLocalMap</code>是每个线程独有的。而<code>ThreadLocal</code>只是作为<code>Key</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">ThreadLocal</span> <span class="variable">tl1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">ThreadLocal</span> <span class="variable">tl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">// belong to main thread  </span></span><br><span class="line">        tl1.set(<span class="string">&quot;123&quot;</span>);  </span><br><span class="line">        tl2.set(<span class="string">&quot;456&quot;</span>);  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;t1:&quot;</span> + tl1.get());  </span><br><span class="line">            System.out.println(<span class="string">&quot;t1:&quot;</span> + tl2.get());  </span><br><span class="line">        &#125;);  </span><br><span class="line">        t1.start();  </span><br><span class="line">  </span><br><span class="line">        System.out.println(<span class="string">&quot;main:&quot;</span> + tl1.get());  </span><br><span class="line">        System.out.println(<span class="string">&quot;main:&quot;</span> + tl2.get());  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">main:<span class="number">123</span></span><br><span class="line">main:<span class="number">456</span></span><br><span class="line">t1:<span class="literal">null</span></span><br><span class="line">t1:<span class="literal">null</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>ThreadLocal</code>：</p>
<ul>
<li><code>set()</code>：在当前线程上绑定一个变量。也就是在当前线程的<code>ThreadLocalMap</code>中添加了一个映射，<code>ThreadLocal</code>-&gt;<code>Object</code></li>
<li><code>get()</code>：获取此<code>ThreadLocal</code>在当前线程上绑定的值。</li>
<li><code>remove()</code>：删除此<code>ThreadLocal</code>在当前线程上绑定的值，避免内存泄漏。</li>
</ul>
<p><strong>内存泄漏问题</strong><br>内存泄漏：JVM创建的对象永远都无法访问到，但是GC又不能回收对象所占用的内存。<br>Java中的使用引用类型分别是<strong>强，软，弱，虚</strong>。<br>在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个<strong>强引用</strong>。强引用不会被JVM的GC回收。因此是造成内存泄漏的主要原因之一。</p>
<p>其次是<strong>软引用</strong>，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中，作为缓存使用。</p>
<p>然后是<strong>弱引用</strong>，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。可以解决内存泄漏问题，ThreadLocal就是基于弱引用解决内存泄漏的问题。</p>
<p>最后是<strong>虚引用</strong>，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。不过在开发中，我们用的更多的还是强引用。</p>
<p><code>ThreadLocalMap</code>中的<code>Entry</code>的<code>key</code>被设计成弱引用。<br><img src="/../../../img/Pasted%20image%2020240221125816.png"></p>
<p>如果当我们不再使用<code>ThreadLocal</code>变量时，依旧有一条强引用路径指向<code>entry</code><br><img src="/../../../img/Pasted%20image%2020240221130514.png">为了解决这个问题，<code>ThreadLocal</code>的作者就把<code>entry</code>中的<code>key</code>设计成弱引用的形式，一旦栈中的<code>ref-threadlocal</code>强引用消失，在下一次GC时就会清除堆中的<code>threadlocal</code>对象。此时，该<code>entry</code>的<code>key</code>值为<code>null</code>。此外，<code>ThreadLocal</code>还有些额外的逻辑清除整个<code>entry</code>的指针。其通过判断<code>entry</code>的<code>key</code>值是否为<code>null</code>来判断该<code>entry</code>是否过时。</p>
<h2 id="4-2-可见性"><a href="#4-2-可见性" class="headerlink" title="4.2 可见性"></a>4.2 可见性</h2><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即看到这个修改。在多线程环境中，由于线程之间的缓存机制，每个线程的工作内存（CPU三级缓存）都是独立的，会导致每个线程中做修改时，只改自己的工作内存，没有及时的同步到主内存，导致数据不一致问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;  </span><br><span class="line">                <span class="comment">// ....  </span></span><br><span class="line">            &#125;  </span><br><span class="line">            System.out.println(<span class="string">&quot;t1线程结束&quot;</span>);  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        t1.start();  </span><br><span class="line">        Thread.sleep(<span class="number">10</span>);  </span><br><span class="line">        flag = <span class="literal">false</span>;  </span><br><span class="line">        System.out.println(<span class="string">&quot;主线程将flag改为false&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码线程<code>t1</code>永远不会结束，因为它无法观察到<code>flag</code>已被修改。不同线程可能在各自的缓存中保存了相同变量的不同副本。如果一个线程修改了共享变量，其他线程可能不会立即看到这个修改。在上述代码中<code>main</code>线程修改了自己缓冲区中的<code>flag = false</code>，并写回主内存。但<code>t1</code>线程的<code>while(flag)</code>读取的依旧是自己缓冲区中的<code>flag(true)</code>因此无法退出循环。</p>
<p>解决方法一：(不推荐)在<code>while</code>循环中，使用<strong>某些语句</strong>读取一次<code>flag</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;  </span><br><span class="line">        <span class="comment">// ....  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;flag[t1]:&quot;</span>+flag);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    System.out.println(<span class="string">&quot;t1线程结束&quot;</span>);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个具体的语句中，由于涉及字符串拼接和 <code>System.out.println</code> 的操作，Java 的虚拟机可能会进行一些特殊处理，例如强制从主内存中读取 <code>flag</code> 的最新值，而不使用线程的本地缓存。因此可以通过重新读取<code>flag</code>的方式刷新缓存。</p>
<p>解决方法二：使用<code>volatile</code>关键词<br><code>volatile</code>是一个关键字，用来修饰成员变量。<br>如果属性被volatile修饰，相当于会告诉CPU，对当前属性的操作，不允许使用CPU的缓存，必须去和主内存操作。</p>
<ul>
<li>volatile属性被写：当写一个volatile变量，JMM会将当前线程对应的CPU缓存及时的刷新到主内存中</li>
<li>volatile属性被读：当读一个volatile变量，JMM会将对应的CPU缓存中的内存设置为无效，必须去主内存中重新读取共享变量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>解决方法三：使用<code>synchronized</code>。<br>如果涉及到了<code>synchronized</code>的同步代码块或者是同步方法，获取锁资源之后，将内部涉及到的变量从CPU缓存中移除，必须去主内存中重新拿数据，而且在释放锁之后，会立即将CPU缓存中的数据同步到主内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;  </span><br><span class="line">                <span class="keyword">synchronized</span> (TestDemo.class)&#123;&#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            System.out.println(<span class="string">&quot;t1线程结束&quot;</span>);  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        t1.start();  </span><br><span class="line">        Thread.sleep(<span class="number">10</span>);  </span><br><span class="line">        flag = <span class="literal">false</span>;  </span><br><span class="line">        System.out.println(<span class="string">&quot;主线程将flag改为false&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;flag[main]:&quot;</span>+flag);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法四：使用锁<br>Lock锁保证可见性的方式和synchronized完全不同，synchronized基于他的内存语义，在获取锁和释放锁时，对CPU缓存做一个同步到主内存的操作。<br>Lock锁是基于volatile实现的。Lock锁内部再进行加锁和释放锁时，会对一个由volatile修饰的state属性进行加减操作。<br>如果对volatile修饰的属性进行写操作，CPU会执行带有lock前缀的指令，CPU会将修改的数据，从CPU缓存立即同步到主内存，同时也会将其他的属性也立即同步到主内存中。还会将其他CPU缓存行中的这个数据设置为无效，必须重新从主内存中拉取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;  </span><br><span class="line">                lock.lock();  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">  </span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;  </span><br><span class="line">                    lock.unlock();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            System.out.println(<span class="string">&quot;t1线程结束&quot;</span>);  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        t1.start();  </span><br><span class="line">        Thread.sleep(<span class="number">10</span>);  </span><br><span class="line">        flag = <span class="literal">false</span>;  </span><br><span class="line">        System.out.println(<span class="string">&quot;主线程将flag改为false&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;flag[main]:&quot;</span>+flag);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-有序性"><a href="#4-3-有序性" class="headerlink" title="4.3 有序性"></a>4.3 有序性</h2><p>有序性是指程序执行的顺序按照代码的先后顺序执行。在并发编程中，由于编译器的优化、指令重排等原因，程序的执行顺序可能被改变，导致程序的实际执行顺序与代码的顺序不一致。</p>
<p>一个指令重排的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> a,b,x,y;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;  </span><br><span class="line">            a = <span class="number">0</span>;  </span><br><span class="line">            b = <span class="number">0</span>;  </span><br><span class="line">            x = <span class="number">0</span>;  </span><br><span class="line">            y = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">                a = <span class="number">1</span>;  </span><br><span class="line">                x = b;  </span><br><span class="line">            &#125;);  </span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">                b = <span class="number">1</span>;  </span><br><span class="line">                y = a;  </span><br><span class="line">            &#125;);  </span><br><span class="line">            t1.start();  </span><br><span class="line">            t2.start();  </span><br><span class="line">            t1.join();  </span><br><span class="line">            t2.join();  </span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>)&#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次，x = &quot;</span>+ x + <span class="string">&quot;,y = &quot;</span> + y);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">第<span class="number">208802</span>次，x = <span class="number">0</span>,y = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>上述代码在正常情况下，<code>x</code>和<code>y</code>不同时为0。只有发生指令重排，即先执行了x&#x3D;b和y&#x3D;a，才会导致<code>x</code>和<code>y</code>同时为0。</p>
<p><code>happens-before</code> 规则：在如下规则下不允许指令重排</p>
<ol>
<li>单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。</li>
<li>锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。</li>
<li>volatile的happen-before原则： 对一个volatile变量的写操作happen-before对此变量的任意操作。</li>
<li>happen-before的传递性原则： 如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。</li>
<li>线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。</li>
<li>线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。</li>
<li>线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。</li>
<li>对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。</li>
</ol>
<p><code>volatile</code>修饰：被该关键词修饰的属性不会被指令重排。通过写前StoreStore 屏障和读后LoadLoad 屏障实现。</p>
<h1 id="五、锁"><a href="#五、锁" class="headerlink" title="五、锁"></a>五、锁</h1><p>重要！！！</p>
<h2 id="5-1-锁的分类"><a href="#5-1-锁的分类" class="headerlink" title="5.1 锁的分类"></a>5.1 锁的分类</h2><h3 id="可重入锁、不可重入锁"><a href="#可重入锁、不可重入锁" class="headerlink" title="可重入锁、不可重入锁"></a><strong>可重入锁、不可重入锁</strong></h3><p><strong>重入</strong>：当前线程获取到A锁，在获取之后尝试再次获取A锁是可以直接拿到的。<br><strong>不可重入</strong>：当前线程获取到A锁，在获取之后尝试再次获取A锁，无法获取到的，因为A锁被当前线程占用着，需要等待自己释放锁再获取锁。<br>Java中提供的synchronized，ReentrantLock，ReentrantReadWriteLock都是可重入锁。</p>
<h3 id="乐观锁、悲观锁"><a href="#乐观锁、悲观锁" class="headerlink" title="乐观锁、悲观锁"></a>乐观锁、悲观锁</h3><p><strong>悲观锁</strong>：悲观锁的基本思想是在整个操作过程中，将数据处于锁定状态，以确保在这个期间数据不会被其他线程修改。获取不到锁资源时，会将当前线程挂起（进入BLOCKED、WAITING），线程挂起会涉及到用户态和内核的太的切换，而这种切换是比较消耗资源的。<br><strong>乐观锁</strong>：乐观锁的基本思想是假设在并发访问的情况下，数据不会发生冲突，因此不对数据加锁，而是在更新时检查数据是否被其他线程修改。获取不到锁资源，可以再次让CPU调度，重新尝试获取锁资源。</p>
<p>Java中提供的synchronized，ReentrantLock，ReentrantReadWriteLock都是悲观锁。<br>Java中提供的CAS操作，就是乐观锁的一种实现。Atomic原子性类中，也是基于CAS乐观锁实现的。</p>
<h3 id="公平锁、非公平锁"><a href="#公平锁、非公平锁" class="headerlink" title="公平锁、非公平锁"></a>公平锁、非公平锁</h3><p>公平锁是指多个线程按照请求的顺序依次获取锁，而非公平锁则允许线程插队。<br>Java中提供的<code>synchronized</code>是非公平锁。<br>Java中提供的<code>ReentrantLock</code>，<code>ReentrantReadWriteLock</code>可以实现公平锁和非公平锁</p>
<h3 id="互斥锁、共享锁、读写锁"><a href="#互斥锁、共享锁、读写锁" class="headerlink" title="互斥锁、共享锁、读写锁"></a>互斥锁、共享锁、读写锁</h3><p><strong>互斥锁</strong>：同一时间点，只会有一个线程持有者当前互斥锁。<br><strong>共享锁</strong>：同一时间点，当前共享锁可以被多个线程同时持有。<br><strong>读写锁</strong>：读锁-读锁共享、写锁和其他锁互斥<br>Java中提供的synchronized、ReentrantLock是互斥锁。<br>Java中提供的ReentrantReadWriteLock，有互斥锁也有共享锁。</p>
<h2 id="5-2-synchronized详解"><a href="#5-2-synchronized详解" class="headerlink" title="5.2 synchronized详解"></a>5.2 synchronized详解</h2><h3 id="同步代码块和同步方法"><a href="#同步代码块和同步方法" class="headerlink" title="同步代码块和同步方法"></a>同步代码块和同步方法</h3><p>同步代码块：锁住<code>&#123;&#125;</code>之间的代码。锁可以使用某个对象或类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(xxx) &#123; </span><br><span class="line">	<span class="comment">// todo some thing </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步方法：声明某个方法是同步方法，同一时间最多被一个线程访问。</p>
<ul>
<li>静态方法：此时使用的是当前类.class作为锁（类锁）</li>
<li>非静态方法：此时使用的是当前对象做为锁（对象锁）<br>类锁和其某个类实例的锁是相互独立的。下面代码中的两个线程可以同时执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">syncDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">LockDemo</span> <span class="variable">lockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockDemo</span>();  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            lockDemo.staticMethod();  </span><br><span class="line">        &#125;);  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            lockDemo.instanceMethod();  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        thread1.start();  </span><br><span class="line">        thread2.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockDemo</span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 静态方法上的类锁  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// synchronized code  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">formattedTime</span> <span class="operator">=</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));  </span><br><span class="line">        System.out.println(<span class="string">&quot;staticMethod() start Time: &quot;</span> + formattedTime);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;staticMethod() end Time: &quot;</span> + LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 实例方法上的对象锁  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">instanceMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// synchronized code  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">formattedTime</span> <span class="operator">=</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));  </span><br><span class="line">        System.out.println(<span class="string">&quot;instanceMethod() start Time: &quot;</span> + formattedTime);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;instanceMethod() end Time: &quot;</span> + LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="JIT优化方式"><a href="#JIT优化方式" class="headerlink" title="JIT优化方式"></a>JIT优化方式</h3><p><strong>锁消除</strong>：在synchronized修饰的代码中，如果不存在操作临界资源的情况，会触发锁消除，此时synchronized无效。比如只有一些局部变量。</p>
<p><strong>锁粗化</strong>：如果在一个循环中，频繁的获取和释放做资源，这样带来的消耗很大，锁膨胀就是将锁的范围扩大，避免频繁的竞争和获取锁资源带来不必要的消耗。(不一定会触发)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">999999</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这是上面的代码会触发锁膨胀</span></span><br><span class="line">    <span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">999999</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lockElimination</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">                method1();  </span><br><span class="line">            &#125;);  </span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">                method2();  </span><br><span class="line">            &#125;);  </span><br><span class="line">            thread1.start();  </span><br><span class="line">            thread2.start();  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (syncDemo.class)&#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;method1:&quot;</span>+i);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (syncDemo.class)&#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;method2:&quot;</span>+i);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 从控制台的输出看到</span></span><br><span class="line"><span class="comment">// thread1和thread2还是交错执行的，并没有触发锁膨胀</span></span><br></pre></td></tr></table></figure>

<p><strong>锁升级</strong>：锁的状态总共有四种，无锁状态、偏向锁、轻量级锁、重量级锁。<br>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。但是锁的升级是单向的，只能升级不能降级。</p>
<ul>
<li>无锁、匿名偏向：当前对象没有作为锁存在。</li>
<li>偏向锁：如果当前锁资源，只有一个线程在频繁的获取和释放，那么这个线程过来，只需要判断，当前指向的线程是否是当前线程 。<ul>
<li>如果是，直接拿着锁资源走。</li>
<li>如果当前线程不是我，基于CAS的方式，尝试将偏向锁指向当前线程。如果获取不到，触发锁升级，升级为轻量级锁。（偏向锁状态出现了锁竞争的情况）</li>
</ul>
</li>
<li>轻量级锁：会采用自旋锁的方式去频繁的以CAS的形式获取锁资源（采用的是自适应自旋锁）<ul>
<li>如果成功获取到，拿着锁资源走</li>
<li>如果自旋了一定次数，没拿到锁资源，锁升级。</li>
</ul>
</li>
<li>重量级锁：就是最传统的synchronized方式，拿不到锁资源，就挂起当前线程。（用户态&amp;内核态）</li>
</ul>
<p><img src="/../../../img/Pasted%20image%2020240221162748.png"></p>
<p>synchronized是基于对象实现的，那这些锁的信息存储在哪？<br><img src="/../../../img/Pasted%20image%2020240222102622.png"><br>实例数据：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。<br>内存填充：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。<br>Java<strong>头对象</strong>是是实现synchronized锁对象的基础，一般而言，synchronized使用的锁对象是存储在Java对象头里的，jvm中采用2个字节来存储对象头（数组是三个字节），其主要结构是由Mark Word和Class Metadata Address组成，其结构说明如下表：</p>
<table>
<thead>
<tr>
<th>头对象结构</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Mark Word</td>
<td>存储对象的hashCode、锁信息或分代年龄或GC标志等信息</td>
</tr>
<tr>
<td>Class Metadata Address</td>
<td>类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。</td>
</tr>
<tr>
<td>Mark Word结构</td>
<td></td>
</tr>
<tr>
<td><img src="/../../../img/Pasted%20image%2020240222103301.png"></td>
<td></td>
</tr>
<tr>
<td>锁状态转变流程</td>
<td></td>
</tr>
<tr>
<td><img src="/../../../img/Pasted%20image%2020240222103620.png"></td>
<td></td>
</tr>
</tbody></table>
<h2 id="5-3-ReentrantLock详解"><a href="#5-3-ReentrantLock详解" class="headerlink" title="5.3 ReentrantLock详解"></a>5.3 ReentrantLock详解</h2><h3 id="ReentrantLock和synchronized区别"><a href="#ReentrantLock和synchronized区别" class="headerlink" title="ReentrantLock和synchronized区别"></a>ReentrantLock和synchronized区别</h3><ul>
<li>ReentrantLock是类，而synchronized是关键词。</li>
<li>底层都是基于JVM层面实现互斥锁</li>
<li>实现原理：ReentrantLock是基于AQS实现，而synchronized是关基于ObjectMonitor</li>
<li>ReentrantLock功能更全面，支持公平锁和非公平锁，支持限制等待时间。</li>
<li>效率区别：ReentranLock不存在锁升级概念；synchronized存在锁升级概念；</li>
</ul>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AbstractQueuedSynchronizer，即抽象的队列同步器，是一种用来构建锁和同步器的框架。JUC下的很多内容都是基于AQS实现了部分功能，比如ReentrantLock，ThreadPoolExecutor，BlockingQueue，CountDownLatch，Semaphore，CyclicBarrier等等都是基于AQS实现。</p>
<p>首先AQS中提供了一个由volatile修饰，并且采用CAS方式修改的int类型的state变量。<br>其次AQS中维护了一个双向链表，有head，有tail，并且每个节点都是Node对象。</p>
<h2 id="5-4-ReentrantReadWriteLock详解"><a href="#5-4-ReentrantReadWriteLock详解" class="headerlink" title="5.4 ReentrantReadWriteLock详解"></a>5.4 ReentrantReadWriteLock详解</h2><p>读写锁，多个线程可以同时进行读操作，提高了并发效率。读-读不互斥，读-写互斥，写-写互斥。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>ReentrantReadWriteLock还是基于AQS实现的，还是对state进行操作，拿到锁资源就去干活，如果没有拿到，依然去AQS队列中排队。</p>
<p>读锁操作：基于state的高16位进行操作。<br>写锁操作：基于state的低16位进行操作。</p>
<p>ReentrantReadWriteLock依然是<strong>可重入锁</strong>。</p>
<h1 id="六、阻塞队列"><a href="#六、阻塞队列" class="headerlink" title="六、阻塞队列"></a>六、阻塞队列</h1><p>阻塞队列基于生产者消费者模式。<br>生产者存储方法：</p>
<ul>
<li><code>add(E)</code> : 添加数据到队列，如果队列满了，无法存储，抛出异常</li>
<li><code>offer(E)</code> : 添加数据到队列，如果队列满了，返回false</li>
<li><code>offer(E,timeout,unit)</code> : 添加数据到队列，如果队列满了，阻塞timeout时间，如果阻塞一段时间，依然没添加进入，返回false</li>
<li><code>put(E)</code> : 添加数据到队列，如果队列满了，挂起线程，等到队列中有位置，再扔数据进去，死等！</li>
</ul>
<p>消费者读取方法：</p>
<ul>
<li><code>remove()</code> : 从队列中移除数据，如果队列为空，抛出异常</li>
<li><code>poll()</code> : 从队列中移除数据，如果队列为空，返回null</li>
<li><code>poll(timeout,unit)</code> : 从队列中移除数据，如果队列为空，挂起线程timeout时间，等生产者存入数据，再获取</li>
<li><code>take()</code> ：从队列中移除数据，如果队列为空，线程挂起，一直等到生产者扔数据，再获取</li>
</ul>
<h2 id="6-1-ArrayBlockingQueue"><a href="#6-1-ArrayBlockingQueue" class="headerlink" title="6.1 ArrayBlockingQueue"></a>6.1 ArrayBlockingQueue</h2><p><strong>ArrayBlockingQueue</strong>在初始化的时候，必须指定当前队列的长度。它是循环使用固定长度的数组实现，通过两个属性，<code>putIndex</code>和<code>takeIndex</code>来控制放入和取出元素的下标。</p>
<h2 id="6-2-LinkedBlockingQueue"><a href="#6-2-LinkedBlockingQueue" class="headerlink" title="6.2 LinkedBlockingQueue"></a>6.2 LinkedBlockingQueue</h2><p><strong>LinkedBlockingQueue</strong>是基于链表的，通过头节点和尾节点控制放入和取出。可以指定最大容量，也可以不指定。</p>
<h2 id="6-3-PriorityBlockingQueue"><a href="#6-3-PriorityBlockingQueue" class="headerlink" title="6.3 PriorityBlockingQueue"></a>6.3 PriorityBlockingQueue</h2><p>首先PriorityBlockingQueue是一个优先级队列，他不满足先进先出的概念。<br>会将查询的数据进行排序，排序的方式就是基于插入数据值的本身。<br>实现原理是基于<strong>数组</strong>实现的二叉堆。</p>
<h2 id="6-4-DelayQueue"><a href="#6-4-DelayQueue" class="headerlink" title="6.4 DelayQueue"></a>6.4 DelayQueue</h2><p>DelayQueue就是一个延迟队列，生产者写入一个消息，这个消息还有直接被消费的延迟时间。<br>DelayQueue会更具延迟时间进行排序，其本身也是一个PriorityBlockingQueue<br>其放入的元素需要实现<code>Delayed</code>接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外卖订单超时自动取消场景</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">delayQ</span><span class="params">()</span>&#123;  </span><br><span class="line">    DelayQueue&lt;DelayTask&gt; delayQueue = <span class="keyword">new</span> <span class="title class_">DelayQueue</span>&lt;DelayTask&gt;();  </span><br><span class="line">    <span class="type">DelayTask</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelayTask</span>(<span class="string">&quot;A&quot;</span>, <span class="number">2000l</span>);  </span><br><span class="line">    delayQueue.add(task1);  </span><br><span class="line">    delayQueue.add(<span class="keyword">new</span> <span class="title class_">DelayTask</span>(<span class="string">&quot;B&quot;</span>,<span class="number">1000l</span>));  </span><br><span class="line">    delayQueue.add(<span class="keyword">new</span> <span class="title class_">DelayTask</span>(<span class="string">&quot;C&quot;</span>,<span class="number">3000l</span>));  </span><br><span class="line">    <span class="comment">// 只有到延迟时间才会取出，应用场景，订单超时自动取消。  </span></span><br><span class="line">    <span class="comment">// 商家正常接单，从超时队列中移除，走正常消费逻辑  </span></span><br><span class="line">    delayQueue.remove(task1);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 不断移除超时订单  </span></span><br><span class="line">    <span class="keyword">while</span> (delayQueue.size()&gt;<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            System.out.println(delayQueue.take());  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DelayTask</span> <span class="keyword">implements</span> <span class="title class_">Delayed</span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> Long delayTime;  </span><br><span class="line">    <span class="keyword">private</span> Long executeTime;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DelayTask</span><span class="params">(String name, Long delayTime)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">        <span class="built_in">this</span>.delayTime = delayTime;  </span><br><span class="line">        <span class="built_in">this</span>.executeTime = System.currentTimeMillis() + delayTime;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getExecuteTime</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> executeTime;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> unit.convert(executeTime - System.currentTimeMillis(),TimeUnit.MILLISECONDS);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Delayed o)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (<span class="built_in">this</span>.executeTime - ((DelayTask)o).getExecuteTime());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DelayTask&#123;&quot;</span> +  </span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +  </span><br><span class="line">                <span class="string">&quot;, delayTime=&quot;</span> + delayTime +  </span><br><span class="line">                <span class="string">&quot;, executeTime=&quot;</span> + executeTime +  </span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-5-SynchronousQueue"><a href="#6-5-SynchronousQueue" class="headerlink" title="6.5 SynchronousQueue"></a>6.5 SynchronousQueue</h2><p>这个队列比较特殊，它不存储元素。因为SynchronousQueue没有容量。与其他BlockingQueue（阻塞队列）不同,SynchronousQueue是一个不存储元素的BlockingQueue。只是它维护一组线程，这些线程在等待着把元素加入或移出队列。</p>
<p>可以理解为给线程“配对”。入和出必须是配对的，否则阻塞。<br>注意：有两种模式，分别为公平模式和非公平模式。公平模式按照先来先配对原则（TransferQueue），非公平按照后来先配对（TransferStack）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">syncBlockQ</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;  </span><br><span class="line">    SynchronousQueue&lt;String&gt; syncq = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(<span class="literal">false</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            syncq.put(<span class="string">&quot;生1&quot;</span>);  </span><br><span class="line">            System.out.println(<span class="string">&quot;生1放入数据&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;).start();  </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            syncq.put(<span class="string">&quot;生2&quot;</span>);  </span><br><span class="line">            System.out.println(<span class="string">&quot;生2放入数据&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;).start();  </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            syncq.put(<span class="string">&quot;生3&quot;</span>);  </span><br><span class="line">            System.out.println(<span class="string">&quot;生3放入数据&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;).start();  </span><br><span class="line">  </span><br><span class="line">    Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;消1：&quot;</span> + syncq.poll());  </span><br><span class="line">    &#125;).start();  </span><br><span class="line">    Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;消2：&quot;</span> + syncq.poll());  </span><br><span class="line">    &#125;).start();  </span><br><span class="line">    Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;消3：&quot;</span> + syncq.poll());  </span><br><span class="line">    &#125;).start();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">输出</span><br><span class="line">消<span class="number">1</span>：生<span class="number">3</span></span><br><span class="line">消<span class="number">2</span>：生<span class="number">2</span></span><br><span class="line">消<span class="number">3</span>：生<span class="number">1</span></span><br><span class="line"></span><br><span class="line">如果改为公平模式则输出</span><br><span class="line">消<span class="number">1</span>：生<span class="number">3</span></span><br><span class="line">消<span class="number">2</span>：生<span class="number">2</span></span><br><span class="line">消<span class="number">3</span>：生<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/CoderTnT/article/details/112685116">Java多线程基础知识_waitset entrylist-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_48321993/article/details/131475435?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170834835116800192213848%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170834835116800192213848&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-131475435-null-null.142%5Ev99%5Epc_search_result_base5&utm_term=java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B&spm=1018.2226.3001.4187">java并发编程(荣耀典藏版)-CSDN博客</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://leggasai.github.io">LegGasai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://leggasai.github.io/posts/3e225941/">https://leggasai.github.io/posts/3e225941/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://leggasai.github.io" target="_blank">LegGasai's CSLearning</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.PNG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/3fdc6854/" title="MIT6.S081"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MIT6.S081</div></div></a></div><div class="next-post pull-right"><a href="/posts/cdcc4eae/" title="分布式事务"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">分布式事务</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LegGasai</div><div class="author-info__description">作者描述</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LegGasai"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/LegGasai" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:jyc132780208@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_56522574" target="_blank" title="'#hdhfbb'"><i class="fa-solid fa-blog"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to my blog☺</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">一、基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 线程的状态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.</span> <span class="toc-text">二、线程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 继承Thread类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%AE%9E%E7%8E%B0Runnable"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 实现Runnable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%AE%9E%E7%8E%B0Callable"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 实现Callable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 线程池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">三、线程的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">3.0.1.</span> <span class="toc-text">3.1 获取线程信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="toc-number">3.0.2.</span> <span class="toc-text">3.2 设置线程相关信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AD%89%E5%BE%85%E5%92%8C%E5%94%A4%E9%86%92%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">3.0.3.</span> <span class="toc-text">3.3 线程的等待和唤醒（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F"><span class="toc-number">3.0.4.</span> <span class="toc-text">3.4 线程结束</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">四、并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 原子性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 可见性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 有序性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">五、锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 锁的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">5.1.1.</span> <span class="toc-text">可重入锁、不可重入锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">5.1.2.</span> <span class="toc-text">乐观锁、悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E3%80%81%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">5.1.3.</span> <span class="toc-text">公平锁、非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E3%80%81%E5%85%B1%E4%BA%AB%E9%94%81%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">5.1.4.</span> <span class="toc-text">互斥锁、共享锁、读写锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-synchronized%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 synchronized详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.1.</span> <span class="toc-text">同步代码块和同步方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JIT%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.2.</span> <span class="toc-text">JIT优化方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-ReentrantLock%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 ReentrantLock详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock%E5%92%8Csynchronized%E5%8C%BA%E5%88%AB"><span class="toc-number">5.3.1.</span> <span class="toc-text">ReentrantLock和synchronized区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS"><span class="toc-number">5.3.2.</span> <span class="toc-text">AQS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 ReentrantReadWriteLock详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">5.4.1.</span> <span class="toc-text">实现原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">六、阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-ArrayBlockingQueue"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 ArrayBlockingQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-LinkedBlockingQueue"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 LinkedBlockingQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-PriorityBlockingQueue"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 PriorityBlockingQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-DelayQueue"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 DelayQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-SynchronousQueue"><span class="toc-number">6.5.</span> <span class="toc-text">6.5 SynchronousQueue</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/68588a2b/" title="服务网格">服务网格</a><time datetime="2024-09-25T05:20:04.000Z" title="发表于 2024-09-25 13:20:04">2024-09-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/45c4147f/" title="搭建Kubernetes集群">搭建Kubernetes集群</a><time datetime="2024-09-25T05:16:57.000Z" title="发表于 2024-09-25 13:16:57">2024-09-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/f2b5cbd9/" title="Golang入门">Golang入门</a><time datetime="2024-06-08T09:19:14.000Z" title="发表于 2024-06-08 17:19:14">2024-06-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/fa82b526/" title="高性能大作业">高性能大作业</a><time datetime="2024-05-18T02:43:14.000Z" title="发表于 2024-05-18 10:43:14">2024-05-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/9acacb00/" title="Kubernetes">Kubernetes</a><time datetime="2024-04-27T03:18:26.000Z" title="发表于 2024-04-27 11:18:26">2024-04-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/footer.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By LegGasai</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-vercel-aspa.vercel.app',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>