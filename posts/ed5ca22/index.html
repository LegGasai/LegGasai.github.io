<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Lab 4.ShardKV | LegGasai's CSLearning</title><meta name="author" content="LegGasai"><meta name="copyright" content="LegGasai"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Lab 4 - Sharded Key&#x2F;Value Service介绍在本实验中，你将建立一个Key&#x2F;Value存储系统，将Key “分片 “或分区到一组副本组中。分片是键&#x2F;值对的一个子集；例如，所有以 “a “开头的键可能是一个分片，所有以 “b “开头的键可能是另一个分片，等等。分片的原因在于性能。每个副本组只处理几个分片的put和get，各组并行运行；因此，系统">
<meta property="og:type" content="article">
<meta property="og:title" content="Lab 4.ShardKV">
<meta property="og:url" content="https://leggasai.github.io/posts/ed5ca22/index.html">
<meta property="og:site_name" content="LegGasai&#39;s CSLearning">
<meta property="og:description" content="Lab 4 - Sharded Key&#x2F;Value Service介绍在本实验中，你将建立一个Key&#x2F;Value存储系统，将Key “分片 “或分区到一组副本组中。分片是键&#x2F;值对的一个子集；例如，所有以 “a “开头的键可能是一个分片，所有以 “b “开头的键可能是另一个分片，等等。分片的原因在于性能。每个副本组只处理几个分片的put和get，各组并行运行；因此，系统">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leggasai.github.io/img/avatar.PNG">
<meta property="article:published_time" content="2023-12-21T10:02:39.000Z">
<meta property="article:modified_time" content="2024-01-29T12:13:36.423Z">
<meta property="article:author" content="LegGasai">
<meta property="article:tag" content="分布式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leggasai.github.io/img/avatar.PNG"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://leggasai.github.io/posts/ed5ca22/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Lab 4.ShardKV',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-29 20:13:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.PNG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 博客</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/top.png')"><nav id="nav"><span id="blog-info"><a href="/" title="LegGasai's CSLearning"><span class="site-name">LegGasai's CSLearning</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 博客</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Lab 4.ShardKV</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-21T10:02:39.000Z" title="发表于 2023-12-21 18:02:39">2023-12-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-29T12:13:36.423Z" title="更新于 2024-01-29 20:13:36">2024-01-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F/">微服务和分布式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F/6-824/">6.824</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Lab 4.ShardKV"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Lab-4-Sharded-Key-Value-Service"><a href="#Lab-4-Sharded-Key-Value-Service" class="headerlink" title="Lab 4 - Sharded Key&#x2F;Value Service"></a>Lab 4 - Sharded Key&#x2F;Value Service</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在本实验中，你将建立一个Key&#x2F;Value存储系统，将Key “分片 “或分区到一组副本组中。分片是键&#x2F;值对的一个子集；例如，所有以 “a “开头的键可能是一个分片，所有以 “b “开头的键可能是另一个分片，等等。分片的原因在于性能。每个副本组只处理几个分片的put和get，各组并行运行；因此，系统总吞吐量（单位时间内的put和get）与组的数量成正比增长。</p>
<p>你的Key&#x2F;Value存储将有两个主要组件。首先是一系列副本组。每个副本组负责一部分分片。一个副本由几个使用 Raft 来复制该组分片的服务器组成。第二个组件是“分片控制器”。分片控制器决定哪个副本组应该服务于哪个分片；这个信息被称为配置。配置会随着时间的推移而变化。客户端询问分片控制器以找到与某个键相关的副本组，而副本组则会咨询控制器以了解应该服务哪些分片。整个系统只有一个分片控制器，通过使用 Raft 实现为一个容错的服务。</p>
<p>一个分片式存储系统必须能够在副本组之间转移分片。一个原因是某些组可能会比其他组的负载更高，因此需要移动分片以平衡负载。另一个原因是副本组可能加入和离开系统：新的副本组可能会被添加以增加容量，或者现有的副本组可能会被下线进行修复或淘汰。</p>
<p>这个实验的主要挑战将是处理重新配置 —— 即分配给副本组的分片发生变化。在单个副本组内，所有组成员必须就何时发生重新配置与客户端 <code>Put/Append/Get</code> 请求达成一致。例如，一个 Put 请求可能与导致副本组不再负责保存 <code>Put</code> 涉及的键的分片的重新配置几乎同时到达。组内的所有副本必须就 Put 请求是在重新配置之前还是之后发生达成一致。如果在之前，<code>Put</code> 请求应该生效，并且分片的新所有者将看到其效果；如果在之后，<code>Put</code> 请求将不会生效，客户端必须在新的所有者处重试。推荐的方法是让每个副本组使用 Raft 记录不仅 Put、Append 和 Get 操作的顺序，还有重新配置的顺序。您需要确保每个分片在任何时候最多只有一个副本组为其服务。</p>
<p>重新配置还需要副本组之间的交互。例如，在配置 10 中，组 G1 可能负责分片 S1。在配置 11 中，组 G2 可能负责分片 S1。在从配置 10 到配置 11 的重新配置期间，G1 和 G2 必须使用 RPC 将分片 S1 的内容（键&#x2F;值对）从 G1 移动到 G2。</p>
<p>注意：</p>
<ul>
<li>客户端和服务器之间的交互只能使用 RPC。例如，不允许服务器的不同实例共享 Go 变量或文件。</li>
<li>本实验室使用 “配置 “来指代将碎片分配到副本组。这与 Raft 群集成员变更不同。您不必实施 Raft 群集成员资格变更。</li>
<li>Lab 4 分片服务器、Lab 4 分片控制器和 Lab 3 kvraft 都必须使用相同的 Raft 实现。</li>
</ul>
<p>本实验的总体架构（一个配置服务和一系列副本组）与 Flat Datacenter Storage、BigTable、Spanner、FAWN、Apache HBase、Rosebud、Spinnaker 等系统的总体模式相同。不过，这些系统在很多细节上都与本实验室不同，通常也更加复杂和强大。例如，该实验不会在每个 Raft 组中演化对等集，其数据和查询模型非常简单，分片的切换速度很慢，而且不允许客户端并发访问。</p>
<p>我们会在 <code>src/shardctrler</code> 和 <code>src/shardkv</code> 中为您提供骨架代码和测试。</p>
<h2 id="PartA：The-Shard-controller"><a href="#PartA：The-Shard-controller" class="headerlink" title="PartA：The Shard controller"></a>PartA：The Shard controller</h2><p>首先，你要在 <code>shardctrler/server.go</code> 和 <code>client.go</code> 中实现分块控制器。完成后，你应该能通过 shardctrler 目录中的所有测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span></span><br><span class="line">Test: Basic leave/join ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Historical queries ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Move ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Concurrent leave/join ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Minimal transfers after joins ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Minimal transfers after leaves ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Multi-group <span class="built_in">join</span>/leave ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Concurrent multi leave/join ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Minimal transfers after multijoins ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Minimal transfers after multileaves ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Check Same config on servers ...</span><br><span class="line">  ... Passed</span><br><span class="line">PASS</span><br><span class="line">ok  	6.5840/shardctrler	5.863s</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;0..10&#125;; <span class="keyword">do</span> go <span class="built_in">test</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><code>shardctrler</code> 管理着一系列编号的配置。每个配置描述了一组副本组以及分片到副本组的分配情况。每当这个分配需要改变时，分配控制器就会创建一个新的配置，其中包含了新的分片分配情况。Key&#x2F;Value客户端和服务器在想要获取当前（或过去）的配置信息时会联系 <code>shardctrler</code>。</p>
<p>你的实现必须支持<code>shardctrler/common.go</code>中描述的RPC接口，其中包括<code>Join</code>、<code>Leave</code>、<code>Move</code>和<code>Query</code> RPC。这些 RPC 的目的是允许管理员（和测试）控制 <code>shardctrler</code>：添加新的副本组、删除副本组，以及在副本组之间移动碎片。</p>
<ul>
<li><p><code>Join</code> RPC 被管理员用来添加新的副本组。其参数是从唯一、非零副本组标识符（GIDs）到服务器名称列表的映射集。<code>shardctrler</code> 应该通过创建一个新的配置来包含新的副本组来做出反应。新的配置应该尽可能均匀地将分片分配给完整的副本组集，并且应该尽可能少地移动分片以达到该目标。如果 GID 不是当前配置的一部分（即 GID 允许加入后离开再次加入），则 shardctrler 应该允许 GID 的重复使用。</p>
</li>
<li><p><code>Leave</code> RPC 的参数是先前加入的副本组的 GIDs 列表。<code>shardctrler</code> 应该创建一个不包含这些组的新配置，并且将这些组的分片分配给剩余的副本组。新的配置应该尽可能均匀地将分片分配给副本组，并且应该尽可能少地移动分片以达到该目标。</p>
</li>
<li><p><code>Move</code> RPC 的参数是一个分片编号和一个 GID。shardctrler 应该创建一个新的配置，在该配置中将分片分配给该组。Move 的目的是允许我们测试你的软件。在 Move 之后进行 Join 或 Leave 操作可能会撤销 Move 操作，因为 Join 和 Leave 会重新平衡。</p>
</li>
<li><p><code>Query</code> RPC 的参数是一个配置编号。shardctrler 将回复具有该编号的配置。如果编号为 -1 或大于已知的最大配置编号，则 <code>shardctrler</code> 应该回复最新的配置。<code>Query(-1)</code> 的结果应该反映 shardctrler 在收到 Query(-1) RPC 之前完成处理的每个 Join、Leave 或 Move RPC。</p>
</li>
</ul>
<p>第一个配置应该编号为零。它不包含任何组，所有分片都应分配给 GID 为0的组（无效的 GID）。下一个配置（响应于 <code>Join</code> RPC 创建的）应编号为 1，等等。通常情况下，分片的数量会远远<strong>多于</strong>组的数量（即每个组会服务多个分片），以便可以在相当精细的粒度上进行负载平衡调整。</p>
<p>你的任务是在 shardctrler&#x2F; 目录下的 client.go 和 server.go 中实现上面指定的接口。你的 shardctrler 必须是容错的，使用 Lab 2&#x2F;3 中的 Raft 库。当你通过了 shardctrler&#x2F; 目录中的所有测试后，你就完成了这项任务。</p>
<p>提示：</p>
<ul>
<li>请先从你的 kvraft 服务器的简化版本开始。</li>
<li>你应该对分块控制器的 RPC 实现客户端请求的重复检测。<code>shardctrler</code>测试并不测试这一点，但<code>shardkv</code>测试稍后会在不可靠的网络上使用你的<code>shardctrler</code>；如果你的<code>shardctrler</code>没有过滤掉重复的RPC，你可能很难通过shardkv测试。</li>
<li>执行分片重新平衡的状态机中的代码需要是确定性的。在 Go 语言中，map 的迭代顺序是不确定的。</li>
<li>Go 中的 map 是引用类型。如果你将一个 map 类型的变量赋值给另一个变量，那么两个变量都指向同一个 map。因此，如果你想要基于先前的配置创建一个新的 Config，你需要创建一个新的 map 对象（使用 make()），并逐个复制键和值。</li>
<li>Go 语言中的竞态检测器（go test -race）可以帮助你找出潜在的 bug。</li>
</ul>
<p>几个概念：</p>
<ul>
<li>replica group：副本组</li>
<li>shards：分片，只是一个说法，没有实体对象<br>分片和副本组的关系：一般来说根据Key来划分为不同的分片，参考MapReduce中的做法，可以是<code>Hash(Key)%Nshards</code>来划分，这样不同的Key-Value会被分配到不同的分片上，尽可能存储均匀。<br>一般副本组负责管理若干个分片，而且每个副本组负责的分片数量均匀（由分片控制器维护）。当收到请求时，Client会根据Key来计算它实际所处的分片号，然后查询Config，向负责该分片的副本组中所有的节点发送RPC<br><img src="/../../../../img/Pasted%20image%2020231208180816.png"></li>
</ul>
<p>shardctrler维护了当前以及历史的配置Config列表<br>Config结构：</p>
<ul>
<li>num:int 索引号，对应Config切片中的索引。可以通过<code>config[num]</code>获得指定位置的配置Config</li>
<li>shards:[Nshards]int，分片号-&gt;Gid的映射。表示某个分片是由Gid的Grounps那个组负责的。</li>
<li>groups:map[int]  []string，Gid到Servers的映射，记录了Replica group中各个节点是哪些。这样在shardkv发送对于某个分片的请求时，就知道要往哪些负责这个分片节点发送RPC了。</li>
</ul>
<p><img src="/../../../../img/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%9B%BE%20(2).png"></p>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>由于需要保证请求的幂等性，服务端可以通过<code>ClientId</code>和<code>CommandId</code>来唯一标识一次请求。那么就需要在客户端发送请求的时候带上这两个字段。、</p>
<p><code>ClientId</code>：客户端标识，可以用项目中自带的<code>nrand()</code>函数实现。<br><code>CommandId</code>：请求标识，来唯一的标识某个客户端发送的请求。可以每次递增。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeClerk</span><span class="params">(servers []*labrpc.ClientEnd)</span></span> *Clerk &#123;</span><br><span class="line">	ck := <span class="built_in">new</span>(Clerk)</span><br><span class="line">	ck.servers = servers</span><br><span class="line">	<span class="comment">// Your code here.</span></span><br><span class="line">	ck.clientId = nrand()</span><br><span class="line">	ck.commandId = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> ck</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Move(shard <span class="type">int</span>, gid <span class="type">int</span>) &#123;</span><br><span class="line">	args := &amp;MoveArgs&#123;&#125;</span><br><span class="line">	<span class="comment">// Your code here.</span></span><br><span class="line">	atomic.AddInt64(&amp;ck.commandId,<span class="number">1</span>)</span><br><span class="line">	args.Shard = shard</span><br><span class="line">	args.GID = gid</span><br><span class="line">	args.ClientId = ck.clientId</span><br><span class="line">	args.CommandId = ck.commandId</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// try each known server.</span></span><br><span class="line">		<span class="keyword">for</span> _, srv := <span class="keyword">range</span> ck.servers &#123;</span><br><span class="line">			<span class="keyword">var</span> reply MoveReply</span><br><span class="line">			ok := srv.Call(<span class="string">&quot;ShardCtrler.Move&quot;</span>, args, &amp;reply)</span><br><span class="line">			<span class="keyword">if</span> ok &amp;&amp; reply.WrongLeader == <span class="literal">false</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他的<code>Query</code>,<code>Join</code>,<code>Leave</code>都类似</p>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>Server端需要做的就是针对不同的请求来操作分片配置。</p>
<h3 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h3><h3 id="Leave"><a href="#Leave" class="headerlink" title="Leave"></a>Leave</h3><h3 id="Move"><a href="#Move" class="headerlink" title="Move"></a>Move</h3><h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h3><h2 id="PartB：Sharded-Key-Value-Server"><a href="#PartB：Sharded-Key-Value-Server" class="headerlink" title="PartB：Sharded Key&#x2F;Value Server"></a>PartB：Sharded Key&#x2F;Value Server</h2><p>现在，你将构建一个分片容错的键&#x2F;值存储系统–shardkv。你将修改 <code>shardkv/client.go</code>、<code>shardkv/common.go</code> 和 <code>shardkv/server.go</code>。</p>
<p>每个 shardkv 服务器作为副本组的一部分运行。每个副本组为某些键空间分片提供 <code>Get</code>、<code>Put</code> 和 <code>Append</code> 操作。在 client.go 中使用 <code>key2shard()</code> 函数来找出一个键属于哪个分片。多个副本组协同工作以服务完整的分片集合。shardctrler 服务的单个实例负责将分片分配给副本组；当这个分配发生变化时，副本组必须彼此交接分片，同时确保客户端不会看到不一致的响应。</p>
<p>您的存储系统必须为使用其客户端接口的应用程序提供线性化接口。也就是说，在 shardkv&#x2F;client.go 中的 Clerk.Get()、Clerk.Put() 和 Clerk.Append() 方法完成的应用程序调用必须以相同顺序影响到所有副本。Clerk.Get() 应该能够看到由最近的 Put&#x2F;Append 写入的相同键的值。即使 Gets 和 Puts 几乎同时到达配置更改，这个要求也必须成立。</p>
<p>您的存储系统必须为使用其客户端接口的应用程序提供线性化接口。也就是说，在 <code>shardkv/client.go</code> 中的 <code>Clerk.Get()</code>、<code>Clerk.Put()</code> 和<code>Clerk.Append()</code> 方法完成的应用程序调用必须以相同顺序影响到所有副本。<code>Clerk.Get()</code> 应该能够看到由最近的 <code>Put/Append</code> 写入的相同键的值。即使 Gets 和 Puts 几乎同时和配置更改一起到达，这个要求也必须成立。</p>
<p>每个分片只需要在该分片的 Raft 副本组中的大多数服务器是活动的、能够相互通信，并且能够与 shardctrler 服务器的大多数通信时才能取得进展。即使某些副本组中的少数服务器已经停止、暂时不可用或速度较慢，您的实现也必须运行（处理请求并在需要时重新配置）。</p>
<p>shardkv服务器只是一个单独副本组的成员。给定副本组中的服务器集合将永远不会改变。</p>
<p>我们提供了 <code>client.go</code> 代码，它会将每个 RPC 发送到负责处理该 RPC 键的副本组。如果副本组表示不负责该键，则客户端代码将进行重试；在这种情况下，客户端代码会向 shard 控制器请求最新的配置，然后再次尝试。您需要修改 <code>client.go</code> 以支持处理重复客户端 RPC，类似 kvraft 实验中的处理方式。</p>
<p>完成后，你的代码应能通过除挑战测试外的所有 shardkv 测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/<span class="number">6.824</span>/src/shardkv</span><br><span class="line">$ <span class="keyword">go</span> test -race</span><br><span class="line">Test: static shards ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: join then leave ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: snapshots, join, and leave ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: servers miss configuration changes...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: concurrent puts and configuration changes...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: more concurrent puts and configuration changes...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: concurrent configuration change and restart...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: unreliable <span class="number">1.</span>..</span><br><span class="line">  ... Passed</span><br><span class="line">Test: unreliable <span class="number">2.</span>..</span><br><span class="line">  ... Passed</span><br><span class="line">Test: unreliable <span class="number">3.</span>..</span><br><span class="line">  ... Passed</span><br><span class="line">Test: shard deletion (challenge <span class="number">1</span>) ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: unaffected shard access (challenge <span class="number">2</span>) ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: partial migration shard access (challenge <span class="number">2</span>) ...</span><br><span class="line">  ... Passed</span><br><span class="line">PASS</span><br><span class="line">ok  	<span class="number">6.824</span>/shardkv	<span class="number">101.503</span>s</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>请注意：服务器不应调用分片控制器的 <code>Join()</code> 处理程序。测试器会在适当的时候调用 Join()。</p>
<p>任务一：<br>您的第一个任务是通过最初的 shardkv 测试。在这个测试中，只有一个分片的分配，因此您的代码应该与第三次实验（Lab 3）中的服务器代码非常相似。最大的修改将是让您的服务器检测配置变化，并开始接受那些与它现在拥有的分片匹配的键的请求。</p>
<p>现在您的解决方案已经适用于静态分片情况，现在是时候解决配置更改的问题了。您需要让服务器监视配置更改，一旦检测到变化，就开始分片迁移过程。如果一个副本组失去了一个分片，它必须立即停止为该分片中的键提供服务，并开始将该分片的数据迁移到接管所有权的副本组。如果一个副本组获得了一个分片，它需要等待前一所有者将旧分片数据发送过来，然后才能接受该分片的请求。</p>
<p>在配置更改期间实施分片迁移非常关键。确保副本组中的所有服务器在执行操作序列时同时进行迁移，这样它们就可以一致地接受或拒绝并发客户端的请求。在处理后续测试之前，着重通过第二个测试（”join then leave”）非常重要。只有通过 TestDelete 之前（不包括 TestDelete）的所有测试，您才能完成这项任务。</p>
<p>注意：</p>
<ul>
<li>你的服务器需要定期轮询分片服务器以了解新的配置。测试希望你的代码大约每 100 毫秒轮询一次；频率高一些没问题，但频率低一些可能会导致问题。</li>
<li>在配置更改期间，服务器需要相互发送RPC以在分片迁移过程中传输分片。shardctrler 的 Config 结构包含服务器名称，但您需要一个 labrpc.ClientEnd 来发送 RPC。您应该使用传递给 StartServer() 的 make_end() 函数，将服务器名称转换为 ClientEnd。shardkv&#x2F;client.go 包含执行此操作的代码。</li>
</ul>
<p>提示：</p>
<ul>
<li>在 <code>server.go</code> 中添加代码，以便定期从分片控制器那里获取最新配置，并添加代码，以便在接收组不负责客户端key的分片时拒绝客户端请求。你应该可以通过第一个测试。</li>
<li>服务器在处理客户端RPC时，如果收到的key不是服务器负责的（即键的分片未分配给服务器的组），应该用 <code>ErrWrongGroup</code> 错误来响应。确保在并发重新配置的情况下，您的 <code>Get</code>、<code>Put</code> 和 <code>Append</code> 处理程序能够正确做出这个决定。</li>
<li>按顺序逐个处理重新配置。</li>
<li>如果测试失败，请检查是否有 gob 错误（例如 “gob: type not registered for interface …”）。尽管对于 Go 来说，gob 错误不被视为致命错误，但在本实验中它们是致命的。</li>
<li>您需要为跨分片移动的客户端请求提供至多一次语义（重复检测）。</li>
<li>想一想 shardkv 客户端和服务器应该如何处理 <code>ErrWrongGroup</code>。如果客户端收到 <code>ErrWrongGroup</code>，是否应该更改序列号？如果服务器在执行<code> Get/Put</code> 请求时返回 <code>ErrWrongGroup</code>，是否应该更新客户端状态？</li>
<li>在服务器已经移动到新配置之后，它可以继续存储它不再拥有的分片（尽管在实际系统中这可能不是理想的）。这可能有助于简化服务器的实现。</li>
<li>当组 G1 在配置更改期间需要从 G2 获取分片时，G2 在处理日志条目时何时将分片发送给 G1 是否重要？</li>
<li>您可以在 RPC 请求或回复中发送整个 map，这可能有助于使分片传输的代码简单化。</li>
<li>如果您的某个 RPC 处理程序在回复中包含了服务器状态的某个 map（例如键&#x2F;值 map），可能会出现由于竞争而导致的 bug。RPC 系统需要读取 map 来将其发送给调用者，但它并没有持有该 map 的锁。然而，服务器可能在 RPC 系统读取 map 时继续修改同一个 map。解决方案是让 RPC 处理程序在回复中包含 map 的副本。</li>
<li>如果您将 map 或 slice 放入 Raft 日志条目中，并且您的键&#x2F;值服务器随后在 applyCh 上看到该条目并将 map&#x2F;slice 的引用保存在键&#x2F;值服务器的状态中，那么可能会出现竞争。请复制 map&#x2F;slice，并将副本存储在键&#x2F;值服务器的状态中。竞争发生在键&#x2F;值服务器修改 map&#x2F;slice 时以及 Raft 在持久化其日志时读取 map&#x2F;slice 之间。</li>
<li>在配置更改期间，两个组之间可能需要在彼此之间双向移动分片。如果出现死锁，请考虑这个可能是一个源头。</li>
</ul>
<h2 id="额外挑战"><a href="#额外挑战" class="headerlink" title="额外挑战"></a>额外挑战</h2><p>如果要建立这样一个用于生产的系统，这两个功能是必不可少的。</p>
<h3 id="状态的垃圾收集"><a href="#状态的垃圾收集" class="headerlink" title="状态的垃圾收集"></a>状态的垃圾收集</h3><p>当副本组失去对一个分片的所有权时，该副本组应该从其数据库中删除与该分片相关的键，因为它不再为该分片提供服务。然而，这对于迁移会带来一些问题。假设有两个组，G1和G2，并且有一个新的配置C，将分片S从G1移动到G2。如果G1在切换到C时从其数据库中清除了分片S中的所有键，那么当G2尝试切换到C时，它该如何获取分片S的数据呢？</p>
<p>导致每个副本组保留旧分片的时间不要超过绝对必要的时间。即使像上面的副本组G1中的所有服务器都崩溃然后重新启动，您的解决方案也必须能够正常工作。只要通过了<code>TestChallenge1Delete</code>测试，您就已经完成了这项任务。</p>
<h3 id="配置更改期间的客户请求"><a href="#配置更改期间的客户请求" class="headerlink" title="配置更改期间的客户请求"></a>配置更改期间的客户请求</h3><p>处理配置更改的最简单方法是在转换完成之前禁止所有客户端操作。虽然在概念上简单，但这种方法在生产级系统中并不可行；每当机器进入或退出时，它会导致所有客户端的长时间暂停。最好的做法是继续为未受正在进行的配置更改影响的分片提供服务。</p>
<p>修改您的解决方案，使对未受影响的分块中的键的客户端操作在配置更改期间继续执行。通过 <code>TestChallenge2Unaffected</code> 时，您就完成了这项挑战。</p>
<p>虽然上述优化很好，但我们仍然可以做得更好。假设某个副本组 G3 在转换到 C 时需要来自 G1 的分片 S1，以及来自 G2 的分片 S2。我们真正希望的是，一旦 G3 接收到必要的状态，即使它仍在等待其他分片，也能立即开始为该分片提供服务。例如，如果 G1 宕机，那么一旦 G3 从 G2 接收到了来自 S2 的适当数据，它应该立即开始为 S2 处理请求，尽管转换到 C 尚未完成。</p>
<p>修改您的解决方案，使复制组在能够为分片提供服务时立即开始服务，即使配置仍在进行中。通过 <code>TestChallenge2Partial</code> 时，您就完成了这项挑战。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>1.需要实现定期轮询分片服务器获取最新<code>config</code>。由Leader进行，然后通过提交日志更新到其他节点。<br>使用一个后台goroutine实现，每隔50ms查询一次。</p>
<p>2.添加函数实现判断当前的<code>key</code>是否是自己负责的。</p>
<p>3.添加服务器之间进行map交换的代码<br>这里可能需要进行注册gob</p>
<p>4.map或slice一定要使用<code>深拷贝</code>。</p>
<p>5.快照等其他实现，只需要保留服务器的一些额外状态即可。</p>
<p>6.添加检测config是否改变的代码。比对<code>configNum</code>即可。</p>
<h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>可以完全按照LAB3的代码，并且实现定期轮询分片服务器更新Config和拒绝不属于当前gid的分片请求即可通过第一个测试。</p>
<h3 id="分片结构"><a href="#分片结构" class="headerlink" title="分片结构"></a>分片结构</h3><p>由于<code>TestChallenge2Unaffected</code>和<code>TestChallenge2Partial</code>任务，我们需要对分片进行单独的管理。也就是说某个<code>Group</code>负责的分片与分片之间互不影响。可能其负责的分片1正在从其他组拉取数据，分片2正常，那么它必须能够响应对应分片2的所有请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ShardData <span class="keyword">struct</span> &#123;</span><br><span class="line">	State	ShardState</span><br><span class="line">	DB	    <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ShardState <span class="type">string</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	READY ShardState =<span class="string">&quot;Ready&quot;</span>    <span class="comment">//就绪状态，默认。(可以提供服务)</span></span><br><span class="line">	WAITING			 =<span class="string">&quot;Waiting&quot;</span>  <span class="comment">//等待从其他group拉取数据</span></span><br><span class="line">	RECEIVED	     =<span class="string">&quot;Received&quot;</span> <span class="comment">//已经从其他group拉取数据，但等待发送分片清除请求。(可以提供服务)</span></span><br><span class="line">	GC 				 =<span class="string">&quot;GC&quot;</span>       <span class="comment">//等待被其他节点拉取，并等待接收清除请求以便被GC</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分片状态机<br><img src="/../../../../img/Pasted%20image%2020240123144020.png"><br><code>Ready-&gt;Waiting</code>：加载新分片配置后，当前group发现自己分配到了新的分片，意味着需要向原来管理该分片的group拉取分片数据。<br><code>Ready-&gt;GC</code>：加载新分片配置后，当前group发现自己不再负责该分片，等待其他group来拉取数据后，进行回收该分片数据。<br><code>Waiting-&gt;Received</code>：向原来管理该分片的group获取到了分片数据，等待向原来group发送GC请求，告诉它已经获取到了数据，可以GC了。<br><code>Received-&gt;Ready</code>：GC请求返回成功，原来group已经成功回收了GC，恢复Ready状态。<br><code>GC-&gt;Ready</code>：不再负责该分片的group，接收到了发来的GC请求，表示对方已获取到分片数据，你可以进行分片回收了，分片回收后，恢复到Ready状态（并情况分片数据）。</p>
<h3 id="配置检测"><a href="#配置检测" class="headerlink" title="配置检测"></a>配置检测</h3><p>服务器需要定时拉取最新配置，并更新自己的分片配置信息。同样可以使用后台线程进行监控。</p>
<p>所有服务器的配置只允许逐次更新，不可以跨级更新。比如从<code>config.num=1更新到config.num=3</code>，跳过某些配置。原因是如果在<code>config.num=1</code>时，group管理着该分片，但是在<code>config.num=2</code>时，该分片被其他group管理，假设分片数据在该配置下发送了修改。那么当<code>config.num=3</code>，该分片又恢复到原先的<code>config.num=1</code>时的group管理。如果直接从<code>config.num=1更新到config.num=3</code>，该group无法检测到变化，则就不会从<code>config.num=2</code>的group处拉取分片数据，那么就丢失了<code>config.num=2</code>时该分片的变化。</p>
<p>当所有分片状态都是<code>Ready</code>时，才可以更新配置。否则如果有分片状态如下：</p>
<ul>
<li><code>Waiting</code>：意味着该分片还未拉取数据，此时更新配置，会丢失修改。</li>
<li><code>GC</code>：分片数据还未清理，更新配置会产生额外分片垃圾。</li>
<li><code>Received</code>：还未向原来group发送GC请求，那么原先的group无法进行GC，同上。</li>
</ul>
<h3 id="分片移动"><a href="#分片移动" class="headerlink" title="分片移动"></a>分片移动</h3><p>务必清楚</p>
<ul>
<li>某个gid中的分片移动必须先提交日志，等待集群的raft达成一致后，以raft日志的形式去更新，这样才能保证同一集群的状态一致。</li>
<li>分片移动的操作由Leader进行还是Follower进行？统一由Leader</li>
<li>分片获取的操作是Push还是Pull？都可以，但我认为Pull效率高，仅在必要时拉取自己需要的部分</li>
</ul>
<p>Leader在更获取最新配置时，需要检测分片管理关系是否发生了变化<br>Case1：<code>newConfig.Shard[index] == gid &amp;&amp; oldConfig.Shard[index] != gid</code>：<br>那么说明需要从targetGid &#x3D; oldConfig.Shard[index]处获取shard为index的分片</p>
<p>实现1：group1如何从其他group2中拉取分片信息。这个group之间的RPC如何定义？为了方便起见，直接把整个分片信息传过去就好了，也就是整个map。即KVStateMachine中的KVData，注意深拷贝。</p>
<ul>
<li>定义一个ShardMigration RPC的args和reply</li>
<li>定义一个ShardMigrationHandler：来返回其他group需要的分片信息</li>
<li>定义一个ShardMigration：从其他Server拉取需要的分片信息</li>
</ul>
<p>实现2：上述分片移动的过程，是否要阻塞原来的进程。这边感觉是要的，只有拿到最新的分片后，才能继续提供服务。也就是让Leader负责去拿分片，然后通过日志，提交给集群中的其他节点。这样所有节点的分片信息才能保持一致。</p>
<p>更新配置过程：</p>
<ol>
<li>后台线程定期拉取最新配置</li>
<li>如果拉取配置的Num比当前的大，说明需要更新了<ol>
<li>需要拉取分片<ol>
<li>发送RPC拉取分片</li>
<li>提交分片数据到raft</li>
<li>更新config</li>
</ol>
</li>
<li>不需要拉取分片，提交config到raft即可。</li>
</ol>
</li>
</ol>
<p>实现3：定义两种command，用来提交给raft。一个是更新config。一个是更新分片KV数据<br>实现4：思考先更新Config还是等待Shard移动完毕后，再更新Config<br>先更新Config，再检查是否需要拉取分片数据，</p>
<p>重新定义状态机结构，这样就不必把整个分片数据都传过去。只传递对应<code>Shard</code>的<code>ShardData</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map[int] ShardData // shard -&gt; ShardData</span><br><span class="line"></span><br><span class="line">ShardData&#123;</span><br><span class="line">	State  ShardState  //ready / updating / gc</span><br><span class="line">	DB     map[string]string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>checkConfig后台线程:每50ms拉取最新配置</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1.如果当前配置已经是最新，直接返回</span><br><span class="line"></span><br><span class="line">// 2.拉取到最新配置</span><br><span class="line">	2.1 通过Raft同步最新的Config。</span><br><span class="line">	2.2 检查分片修改,同样通过Raft进行分片信息的修改。</span><br><span class="line">		// 需要从targetGid拉取分片,提交给Raft</span><br><span class="line">		// 需要进行GC,提交给Raft</span><br><span class="line">		// Shard:分片号,newState:新状态</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><code>updateShardData后台线程:定期刷新分片数据</code>，这个感觉的用nodify机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 不断检查ShardData的状态</span><br><span class="line">	1.updating:说明需要更新，向targetGid发送RPC拉取分片数据。</span><br><span class="line">	2.GC:说明这个分片后续不再需要了,这个需要收到远程RPC后在进行，确保另外服务器已经更新了DB</span><br><span class="line">	3.ready:正常状态，只有GC/ready的状态才可以响应客户端。</span><br></pre></td></tr></table></figure>

<p><code>applier后台线程:处理Raft应用到状态机命令</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 收到快照或其他消息，这边先不讨论</span><br><span class="line"></span><br><span class="line">// 1.updateConfig Msg:更新配置</span><br><span class="line">kv.cfg = newConfig</span><br><span class="line"></span><br><span class="line">// 2.updateShardState Msg:更新分片状态，由checkConfig线程触发</span><br><span class="line">kv.KVStateMachine.ShardData[shard].state = newState</span><br><span class="line"></span><br><span class="line">// 3.updateShardData Msg:更新分片数据，由updateShardData线程触发</span><br><span class="line">1.kv.KVStateMachine.ShardData[shard].DB : 需要对两个map进行合并</span><br><span class="line">2.更新cacheMap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Msg结构</span><br><span class="line">Type</span><br><span class="line">NewConfig</span><br><span class="line">Shard</span><br><span class="line">NewState</span><br><span class="line">DB</span><br><span class="line">CacheMap</span><br></pre></td></tr></table></figure>


<h3 id="分片回收"><a href="#分片回收" class="headerlink" title="分片回收"></a>分片回收</h3><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><ol>
<li><p>无法通过<code>TestConcurrent</code>以及<code>TestUnreliable</code>的所有子测试。似乎put操作有缺失<br>分片拉取的时候没有判断是否是leader,只有leader才能发送分片数据给其他节点。大部分是没有进行幂等性设计，导致重复执行了某个非幂等操作。</p>
</li>
<li><p>空指针异常&#x2F;无效地址</p>
</li>
<li><p>某个节点进行了Append操作，但是后来又收到了分片数据，覆盖了整个Append操作。导致修改丢失了。<br>接收分片的时候没有进行<strong>幂等性</strong>设计，导致如果第一次接收后，分片已经Ready了，此时进行了Append操作，然后又收到了一次接受分片的信息，那么这个Append操作就被覆盖了。</p>
</li>
<li><p><code>configNum</code>一定要逐次加1，这个思考一下为什么。</p>
</li>
<li><p><code>TestConcurrent3</code>无法推进<br>原因如out日志，27119行-27227行左右。各组之间不断相互Ask Shard Data导致互相等待。原因是不能仅通过<code>kv.rf.Start(Command)</code>进行修改，而是等确保<code>Command</code>一定被执行后再返回ok，因为<code>kv.rf.Start(Command)</code>不是一定执行成功的。可能此时Leader掉线了或不是Leader。如果要保证指令执行成功需要通过<code>ApplyCh</code>监听到该指令被应用于状态机才行。<br><strong>这个问题还是没解决</strong></p>
</li>
</ol>
<p>更新分片状态的时机</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> ShardGCHandler(args *ShardMigrationArgs, reply * ShardMigrationReply)&#123;</span><br><span class="line">	<span class="keyword">if</span> _,isLeader := kv.rf.GetState();!isLeader&#123;</span><br><span class="line">		reply.Err = ErrWrongLeader</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	kv.mu.RLock()</span><br><span class="line">	<span class="keyword">if</span> args.ConfigNum &gt; kv.config.Num&#123;</span><br><span class="line">		DPrintf(<span class="string">&quot;[Delete ShardData Fail][ShardGCHandler] Server[%d]-[%d] send shard[%d] with config[%d] : [%d] | %s\n&quot;</span>, kv.gid,kv.me,args.Shard,args.ConfigNum,kv.config.Num,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">		reply.Err = OK</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	kv.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Bug</span></span><br><span class="line">	<span class="comment">//kv.rf.Start(ShardOp&#123;</span></span><br><span class="line">	<span class="comment">//	Type: GC_SHARD,</span></span><br><span class="line">	<span class="comment">//	Shard: args.Shard,</span></span><br><span class="line">	<span class="comment">//	ConfigNum: args.ConfigNum,</span></span><br><span class="line">	<span class="comment">//&#125;)</span></span><br><span class="line">	<span class="keyword">var</span> commandReply CommandReply</span><br><span class="line">	kv.ShardCommand(&amp;ShardOp&#123;</span><br><span class="line">		Type: GC_SHARD,</span><br><span class="line">		Shard: args.Shard,</span><br><span class="line">		ConfigNum: args.ConfigNum,</span><br><span class="line">	&#125;,&amp;commandReply)</span><br><span class="line">	reply.Shard = args.Shard</span><br><span class="line">	reply.ConfigNum = args.ConfigNum</span><br><span class="line">	reply.Err = commandReply.Err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bug代码如上，考虑到如果<code>GC_SHARD</code>操作没有执行成功，此时RPC返回OK，那么发送请求的Server已经认为目标Server成功删除了分片（实际未成功），此时发送请求的Server修改分片状态。但目标Server的状态还是<code>GC</code>，导致它无法更新<code>Config</code></p>
<p>参考<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f5c8ab9cd577">8.MIT 6.824 LAB 4B(分布式shard database) - 简书 (jianshu.com)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45938441/article/details/125566763">MIT-6.824-lab4B-2022(万字思路讲解-代码构建）_6.824 lab-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://github.com/OneSizeFitsQuorum/MIT6.824-2021/blob/master/docs/lab4.md">MIT6.824-2021&#x2F;docs&#x2F;lab4.md at master · OneSizeFitsQuorum&#x2F;MIT6.824-2021 (github.com)</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://leggasai.github.io">LegGasai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://leggasai.github.io/posts/ed5ca22/">https://leggasai.github.io/posts/ed5ca22/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://leggasai.github.io" target="_blank">LegGasai's CSLearning</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.PNG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/82d7eaa9/" title="Lab 3.KVRaft"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Lab 3.KVRaft</div></div></a></div><div class="next-post pull-right"><a href="/posts/3fe7f195/" title="工程硕士数学复习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">工程硕士数学复习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/1906f3d9/" title="MIT6.824"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-29</div><div class="title">MIT6.824</div></div></a></div><div><a href="/posts/c1c1f0d5/" title="凤凰架构笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-24</div><div class="title">凤凰架构笔记</div></div></a></div><div><a href="/posts/dd2fb3f1/" title="谷粒商城笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-24</div><div class="title">谷粒商城笔记</div></div></a></div><div><a href="/posts/afaac1c/" title="Lab 2.Raft"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-21</div><div class="title">Lab 2.Raft</div></div></a></div><div><a href="/posts/ddf70eb0/" title="Lab 1.MapReduce"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-19</div><div class="title">Lab 1.MapReduce</div></div></a></div><div><a href="/posts/82d7eaa9/" title="Lab 3.KVRaft"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-21</div><div class="title">Lab 3.KVRaft</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LegGasai</div><div class="author-info__description">作者描述</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LegGasai"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/LegGasai" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:jyc132780208@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_56522574" target="_blank" title="'#hdhfbb'"><i class="fa-solid fa-blog"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to my blog☺</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab-4-Sharded-Key-Value-Service"><span class="toc-number">1.</span> <span class="toc-text">Lab 4 - Sharded Key&#x2F;Value Service</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PartA%EF%BC%9AThe-Shard-controller"><span class="toc-number">1.2.</span> <span class="toc-text">PartA：The Shard controller</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Client"><span class="toc-number">1.2.1.</span> <span class="toc-text">Client</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Server"><span class="toc-number">1.2.2.</span> <span class="toc-text">Server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Join"><span class="toc-number">1.2.3.</span> <span class="toc-text">Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leave"><span class="toc-number">1.2.4.</span> <span class="toc-text">Leave</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Move"><span class="toc-number">1.2.5.</span> <span class="toc-text">Move</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Query"><span class="toc-number">1.2.6.</span> <span class="toc-text">Query</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PartB%EF%BC%9ASharded-Key-Value-Server"><span class="toc-number">1.3.</span> <span class="toc-text">PartB：Sharded Key&#x2F;Value Server</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E6%8C%91%E6%88%98"><span class="toc-number">1.4.</span> <span class="toc-text">额外挑战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">状态的垃圾收集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%9B%B4%E6%94%B9%E6%9C%9F%E9%97%B4%E7%9A%84%E5%AE%A2%E6%88%B7%E8%AF%B7%E6%B1%82"><span class="toc-number">1.4.2.</span> <span class="toc-text">配置更改期间的客户请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">1.5.</span> <span class="toc-text">实现思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.1.</span> <span class="toc-text">基本实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%89%87%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.2.</span> <span class="toc-text">分片结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%A3%80%E6%B5%8B"><span class="toc-number">1.5.3.</span> <span class="toc-text">配置检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%89%87%E7%A7%BB%E5%8A%A8"><span class="toc-number">1.5.4.</span> <span class="toc-text">分片移动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%89%87%E5%9B%9E%E6%94%B6"><span class="toc-number">1.5.5.</span> <span class="toc-text">分片回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Debug"><span class="toc-number">1.6.</span> <span class="toc-text">Debug</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/0/" title="无题">无题</a><time datetime="2024-01-29T12:13:15.351Z" title="发表于 2024-01-29 20:13:15">2024-01-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/7700681/" title="MIT6.830">MIT6.830</a><time datetime="2024-01-29T11:50:38.000Z" title="发表于 2024-01-29 19:50:38">2024-01-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/7700681/" title="MIT6.830">MIT6.830</a><time datetime="2024-01-25T14:11:32.000Z" title="发表于 2024-01-25 22:11:32">2024-01-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/906041f/" title="SchemaN">SchemaN</a><time datetime="2024-01-19T02:22:02.000Z" title="发表于 2024-01-19 10:22:02">2024-01-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/51e51a3e/" title="CMU 15-445">CMU 15-445</a><time datetime="2024-01-17T13:39:32.000Z" title="发表于 2024-01-17 21:39:32">2024-01-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/footer.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By LegGasai</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-vercel-aspa.vercel.app',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>