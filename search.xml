<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>服务网格</title>
      <link href="/posts/68588a2b/"/>
      <url>/posts/68588a2b/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>是一种用于处理微服务架构中服务间通信的基础设施层，负责管理服务之间的网络流量。它解耦了应用逻辑与网络层的通信细节，并通过代理实现服务发现、负载均衡、故障恢复、安全（如 mTLS 加密通信）、监控和策略执行等功能。</p><p>在云原生架构中，服务网格由一组轻量级的<strong>代理（sidecar）</strong>组成，这些代理与每个微服务实例一起运行。服务网格通常包括两个主要部分：</p><ol><li><p><strong>数据平面（Data Plane）</strong>：由部署在每个服务实例旁边的代理组成，它们拦截所有入站和出站的流量，负责实现服务之间的通信。</p></li><li><p><strong>控制平面（Control Plane）</strong>：负责配置和管理数据平面中的代理，提供服务发现、负载均衡、健康检查、安全等功能。</p></li></ol><p>  <img src="/../../../img/1280X1280.png"></p><h1 id="服务网格工作原理的例子"><a href="#服务网格工作原理的例子" class="headerlink" title="服务网格工作原理的例子"></a>服务网格工作原理的例子</h1><p>假设你有两个微服务：</p><ul><li><p><strong>ServiceA</strong>：一个订单服务。</p></li><li><p><strong>ServiceB</strong>：一个支付服务。</p></li></ul><p>在没有服务网格的情况下，ServiceA 直接调用 ServiceB，依赖 DNS 或服务发现机制来找到 ServiceB 的地址，可能需要自行处理重试、超时、日志、负载均衡、安全等逻辑。这种直接通信的耦合使得管理、监控和排查问题变得复杂。</p><p>引入服务网格之后，服务间的通信通过服务网格代理进行。以下是具体场景：</p><h4 id="场景描述："><a href="#场景描述：" class="headerlink" title="场景描述："></a>场景描述：</h4><ol><li><p><strong>ServiceA</strong> 想要调用 <strong>ServiceB</strong> 完成支付操作。</p></li><li><p>ServiceA 和 ServiceB 分别运行在 Kubernetes 集群中，并且被服务网格代理（比如 <strong>Envoy</strong>）接管流量。</p></li></ol><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol><li><p><strong>ServiceA 调用 ServiceB</strong>：</p><ol><li><p>ServiceA 发出请求时，请求不会直接到达 ServiceB。</p></li><li><p>ServiceA 的请求首先通过 ServiceA 旁边的服务网格代理 (sidecar)，这个代理会对请求进行处理。</p></li></ol></li><li><p><strong>服务发现与****负载均衡</strong>：</p><ol><li><p>ServiceA 的代理会通过服务网格的控制平面来查询 ServiceB 的服务信息，找到可用的 ServiceB 实例。</p></li><li><p>假设有多个 ServiceB 实例（副本），服务网格会根据策略进行负载均衡，比如轮询或基于流量的智能负载均衡。</p></li></ol></li><li><p><strong>安全与加密</strong>：</p><ol><li>服务网格会自动处理通信的安全性问题。比如它会通过 <strong>mTLS（双向</strong> <strong>TLS****）</strong> 为 ServiceA 和 ServiceB 之间的通信建立安全连接，确保数据加密和身份验证，不需要开发人员手动配置加密。</li></ol></li><li><p><strong>请求发送****到 ServiceB</strong>：</p><ol><li><p>代理处理完这些逻辑后，安全地将请求转发给 ServiceB 的代理。</p></li><li><p>ServiceB 的代理接收到流量并将其传递给 ServiceB。</p></li></ol></li><li><p><strong>监控与追踪</strong>：</p><ol><li>在通信过程中，服务网格的代理会自动收集指标（如延迟、请求成功率等）并上报给监控系统。这些代理还会注入分布式追踪信息，帮助运维人员更好地理解请求是如何在多个服务之间流动的。</li></ol></li><li><p><strong>失败处理与重试</strong>：</p><ol><li>如果调用失败，比如 ServiceB 某个实例不可用，服务网格代理可以根据定义好的策略自动进行重试或切换到其他 ServiceB 实例。</li></ol></li></ol><h4 id="服务网格提供的功能"><a href="#服务网格提供的功能" class="headerlink" title="服务网格提供的功能"></a>服务网格提供的功能</h4><ol><li><p><strong>自动****负载均衡</strong>：服务网格可以根据配置的负载均衡策略，将流量合理分配到多个服务实例上。</p></li><li><p><strong>故障恢复</strong>：服务网格支持自动重试和熔断机制。如果某个服务无法响应，服务网格会自动切换到其他健康的服务。</p></li><li><p><strong>流量管理</strong>：服务网格支持流量控制和智能路由，可以通过策略控制流量的分发，比如蓝绿部署、金丝雀发布等。</p></li><li><p><strong>安全性</strong>：通过 mTLS 自动实现双向认证和加密，无需开发人员在代码中手动处理证书和加密逻辑。</p></li><li><p><strong>可观测性</strong>：服务网格会自动收集大量的运行时指标和日志信息，提供分布式追踪功能，帮助开发者和运维人员分析和诊断系统性能。</p></li><li><p><strong>策略执行</strong>：服务网格允许定义策略，比如访问控制、限流和配额，来管理服务之间的交互。</p></li></ol><h1 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h1><p>Istio是一个服务网络的开源实现。</p><p><a href="https://istio.io/">https://istio.io/</a></p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p><strong>流量管理</strong></p><p>利用配置，我们可以控制服务间的流量。设置断路器、超时或重试都可以通过简单的配置改变来完成。</p><p><strong>可观测性</strong></p><p>Istio 通过跟踪、监控和记录让我们更好地了解你的服务，它让我们能够快速发现和修复问题。</p><p><strong>安全性</strong></p><p>Istio 可以在代理层面上管理认证、授权和通信的加密。我们可以通过快速的配置变更在各个服务中执行政策。</p><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>Istio服务网格有两部分构成：<strong>数据平面</strong>和<strong>控制平面</strong>。<br><img src="/../../../img/0d610611-4a56-4ea5-ad64-8282b217f0cb.png"></p><h3 id="Envoy（数据平面）"><a href="#Envoy（数据平面）" class="headerlink" title="Envoy（数据平面）"></a>Envoy（数据平面）</h3><p>Envoy 是一个用 C++ 开发的高性能代理。Istio 服务网格将 Envoy 代理作为一个 <strong>sidecar</strong> 容器注入到你的应用容器旁边。然后该代理拦截该服务的所有入站和出站流量。注入的代理一起构成了服务网格的数据平面。</p><p>Envoy 代理也是唯一与流量进行交互的组件。除了前面提到的功能 —— 负载均衡、断路器、故障注入、重试等。Envoy 还支持基于 WebAssembly（WASM）的可插拔扩展模型。这种可扩展性使我们能够执行自定义策略，并为网格中的流量生成遥测数据。</p><p>  <img src="/../../../img/d60b94eb-06d6-4fb7-9e19-96ae354ad8ed.png"></p><h3 id="Istiod（控制平面）"><a href="#Istiod（控制平面）" class="headerlink" title="Istiod（控制平面）"></a>Istiod（控制平面）</h3><p>Istiod 是控制平面组件，提供服务发现、配置和证书管理功能。Istiod 采用 YAML 编写的高级规则，并将其转换为 Envoy 的可操作配置。然后，它把这个配置传播给网格中的所有 sidecar。</p><p>Istiod 内部的 Pilot 组件抽象出特定平台的服务发现机制（Kubernetes、Consul 或 VM），并将其转换为 sidecar 可以使用的标准格式。</p><p>使用内置的身份和凭证管理，我们可以实现强大的服务间和终端用户认证。通过授权功能，我们可以控制谁可以访问你的服务。</p><p>控制平面的部分以前被称为 Citadel，作为一个证书授权机构，生成证书，允许数据平面中的代理之间进行安全的 mTLS 通信。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 云原生 </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Kubernetes集群</title>
      <link href="/posts/45c4147f/"/>
      <url>/posts/45c4147f/</url>
      
        <content type="html"><![CDATA[<h1 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h1><ol><li>安装docker</li></ol><p><a href="https://www.cnblogs.com/lqqgis/p/18276118">Ubuntu安装docker</a></p><p>配置镜像</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://docker.m.daocloud.io&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://dockerproxy.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://mirror.baidubce.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://docker.nju.edu.cn&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://docker.mirrors.sjtug.sjtu.edu.cn&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://mirror.iscas.ac.cn&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、搭建集群"><a href="#二、搭建集群" class="headerlink" title="二、搭建集群"></a>二、搭建集群</h1><table><thead><tr><th>角色</th><th>主机名</th><th>IP</th></tr></thead><tbody><tr><td>master</td><td>i-0dkz1eq2</td><td>172.21.11.19</td></tr><tr><td>workder1</td><td>i-canxuquv</td><td>172.21.11.37</td></tr></tbody></table><p>搭建过程参考：</p><p><a href="https://blog.csdn.net/m0_53928179/article/details/139068769">【Kubernetes k8s】(两万字超详细)Ubuntu-22.04搭建 k8s-1.30.1集群，开启Dashboard-2.7.0、部署ingress-nginx-1.10.1_ubuntu</a></p><p><a href="https://www.cnblogs.com/xuweiweiwoaini/p/13884112.html">从零搭建k8s集群 - 许大仙 - 博客园</a></p><p>K8S相关组件apt install下载失败的话，请配置阿里云镜像源</p><p><a href="https://developer.aliyun.com/mirror/kubernetes/">kubernetes镜像_kubernetes下载地址_kubernetes安装教程-阿里巴巴开源镜像站</a></p><h2 id="初始化Master节点"><a href="#初始化Master节点" class="headerlink" title="初始化Master节点"></a>初始化Master节点</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo kubeadm init \</span><br><span class="line">--apiserver-advertise-address=<span class="number">172.21</span><span class="number">.11</span><span class="number">.19</span> \</span><br><span class="line">--image-repository=registry.aliyuncs.com/google_containers \</span><br><span class="line">--control-plane-endpoint=i<span class="number">-0</span>dkz1eq2 \</span><br><span class="line">--kubernetes-version=v1<span class="number">.28</span><span class="number">.14</span> \</span><br><span class="line">--service-cidr=<span class="number">10.50</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> \</span><br><span class="line">--pod-network-cidr=<span class="number">10.60</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> \</span><br><span class="line">--cri-socket=unix:<span class="comment">///run/containerd/containerd.sock</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意以下几个配置：</p><ul><li><p>apiserver-advertise-address：主机地址</p></li><li><p>control-plane-endpoint&#x3D;i-0dkz1eq2：主机名称，可以修改为类似k8s-master、k8s-worker</p></li><li><p>service-cidr：<strong>Service</strong> 的虚拟 IP 地址范围。</p></li><li><p>pod-network-cidr：<strong>Pod</strong> 的网络地址范围。后续配置CNI还会用到，需要一致。Flannel默认10.244.0.0&#x2F;16</p></li></ul><p>master节点初始化完成后，会输出如下的内容，用于worker节点加入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubeadm <span class="built_in">join</span> i-0dkz1eq2:6443 --token x84vbt.8dnhwxyxn111f1cb \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:fc6e72dc3d74d9a7ff5168614f1368773a39a4125b780904b6db3b009e0daef4</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 生成一个永不过期的token</span></span><br><span class="line">kubeadm token create --ttl 0 </span><br><span class="line">hpcimj.mivikhgk5vzjdfe4</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> i-0dkz1eq2:6443 --token hpcimj.mivikhgk5vzjdfe4 \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:fc6e72dc3d74d9a7ff5168614f1368773a39a4125b780904b6db3b009e0daef4</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="Worker节点加入集群"><a href="#Worker节点加入集群" class="headerlink" title="Worker节点加入集群"></a>Worker节点加入集群</h2><p>在worker节点上运行刚才master节点kubeadm join最后输出的内容，包括token和ca证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm <span class="built_in">join</span> i-0dkz1eq2:6443 --token hpcimj.mivikhgk5vzjdfe4 \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:fc6e72dc3d74d9a7ff5168614f1368773a39a4125b780904b6db3b009e0daef4</span><br></pre></td></tr></table></figure><p>CNI插件镜像无法下载解决方案：</p><p>一：手动拉取并使用tag标记</p><p><a href="https://docker.aityp.com/image/docker.io/flannel/flannel:v0.25.6">docker.io&#x2F;flannel&#x2F;flannel:v0.25.6</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo ctr -n k8s.io images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/flannel/flannel-cni-plugin:v1.5.1-flannel2 </span><br><span class="line"></span><br><span class="line">sudo ctr -n k8s.io images tag swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/flannel/flannel-cni-plugin:v1.5.1-flannel2 docker.io/flannel/flannel-cni-plugin:v1.5.1-flannel2</span><br><span class="line"></span><br><span class="line">sudo ctr -n k8s.io images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/flannel/flannel:v0.25.6</span><br><span class="line"></span><br><span class="line">sudo ctr -n k8s.io images tag  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/flannel/flannel:v0.25.6  docker.io/flannel/flannel:v0.25.6</span><br><span class="line"></span><br><span class="line">sudo ctr -n k8s.io images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/registry.k8s.io/pause:3.6-linuxarm64</span><br><span class="line">sudo ctr -n k8s.io images tag  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/registry.k8s.io/pause:3.6-linuxarm64  registry.k8s.io/pause:3.6</span><br></pre></td></tr></table></figure><p><a href="https://blog.51cto.com/liuzhengwei521/2382257">blog.51cto.com</a></p><p>二：配置Containerd镜像源</p><p><a href="https://juejin.cn/post/7312330825206693939">Containerd配置国内镜像源</a></p><p>CNI插件相关</p><p><a href="https://www.yangxingzhen.com/9835.html">重置后重新加入k8s集群报cni plugin not initialized解决方法</a></p><p>最终效果：显示Ready表示节点正常运行中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@i-0dkz1eq2:~<span class="comment"># kubectl get node</span></span><br><span class="line">NAME         STATUS   ROLES           AGE     VERSION</span><br><span class="line">i-0dkz1eq2   Ready    control-plane   3h56m   v1.28.14</span><br><span class="line">i-canxuquv   Ready    &lt;none&gt;          10m     v1.28.14</span><br></pre></td></tr></table></figure><h1 id="三、安装K8S-Dashboard"><a href="#三、安装K8S-Dashboard" class="headerlink" title="三、安装K8S Dashboard"></a>三、安装K8S Dashboard</h1><p>按照<a href="https://blog.csdn.net/m0_53928179/article/details/139068769">【Kubernetes k8s】(两万字超详细)Ubuntu-22.04搭建 k8s-1.30.1集群，开启Dashboard-2.7.0、部署ingress-nginx-1.10.1-CSDN博客</a></p><p>登录的TOKEN记得保存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJSUzI1NiIsImtpZCI6IjlsVm5CUUdiQ2ZHenVBRjlxNklnSmQ2eXZsUEFPdmtRRWphdkhfRHN0OWsifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VyLXRva2VuIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJiMjU1NzBjMi02YTMyLTQ5OTMtYWFmMy04Nzk1ODRlOGE5MTYiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZXJuZXRlcy1kYXNoYm9hcmQ6YWRtaW4tdXNlciJ9.fiOYGCZHI3jYSU9Qs5EUujaqbRoJ0G0E7389tccO3bwk3k7LuxYcZus73pn1ra7wRMdbdmXK1ZSvwNtFbkZfJfS8GUGorFa3k3XQYm056V1lN6IpyaB7w7iaNCmNUgyc-7t2ifDYXR7s01utPS7UmfutVtkHhAp8Pp6s5XB9VrCT4cHzOeX8kclg9nugNcRGHJ1TgUTDFh0TnyKacSM53Jhx6rXsqb32yzSfvGxpQORzj4T4Y5WQrh7rQsc0F7F__YZX_xWNnRfBYt1yG0iJ7iD1XoiCCREYNzUaUCiSY3KWy2PoZA4wnAiD3BrWZEzFPRF9NnHNMj7FpXA6KMyW6w</span><br></pre></td></tr></table></figure><p><img src="/../../../img/Pasted%20image%2020240925131934.png"></p><blockquote><p>为什么可以通过集群中任意一台节点IP：Port访问dashboard，既然dashboard仅部署在Master上？</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br></pre></td></tr></table></figure><p>我们可以看到dashboard是一个service，Kubernetes 使用 <strong>Service</strong> 对 Pod 提供访问入口，抽象了 Pod 的 IP 地址，使得集群内的任何节点都可以访问服务。Dashboard 作为一个在 Kubernetes 内部运行的应用，也通过一个 Service 来暴露访问接口。并且它是NodePort类型的，每个节点的特定端口都能直接访问 Dashboard。</p><h1 id="四、常用命令"><a href="#四、常用命令" class="headerlink" title="四、常用命令"></a>四、常用命令</h1><p>查看所有Pod信息</p><p><code>kubectl get pods -A -o wide</code></p><p>重启命令</p><p><code>systemctl restart kubelet</code></p><p><code>systemctl restart containerd</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 云原生 </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang入门</title>
      <link href="/posts/f2b5cbd9/"/>
      <url>/posts/f2b5cbd9/</url>
      
        <content type="html"><![CDATA[<p>互动教程<br><a href="https://go.dev/tour/list">A Tour of Go</a></p><h1 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h1><p><code>go mod</code> 是 Go 语言中的模块管理工具，用于处理 Go 项目的依赖关系和版本控制。它和Maven比较相似。自 Go 1.11 起，Go 引入了模块管理以替代旧的 <code>GOPATH</code> 模式，使依赖管理更加方便和可靠。</p><p>go module最重要的是go.mod文件的定义，它用来标记一个module和它的依赖库以及依赖库的版本。会放在module的主文件夹下，一般以<code>go.mod</code>命名。类似于Maven的<code>pom.xml</code>文件</p><p>初始化<code>go.mod</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init [module-path]</span><br></pre></td></tr></table></figure><p>如果你的项目需要发布到github上，那么<code>module-path</code>一定要和仓库名对应。比如<code>github.com/&#123;username&#125;/&#123;reponame&#125;</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module github.com/&#123;username&#125;/&#123;reponame&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">example.com/apple v0<span class="number">.1</span><span class="number">.2</span></span><br><span class="line">example.com/banana v1<span class="number">.2</span><span class="number">.3</span></span><br><span class="line">example.com/banana/v2 v2<span class="number">.3</span><span class="number">.4</span></span><br><span class="line">example.com/pear <span class="comment">// indirect</span></span><br><span class="line">example.com/strawberry <span class="comment">// incompatible</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">exclude example.com/banana v1<span class="number">.2</span><span class="number">.4</span></span><br><span class="line">replace（</span><br><span class="line">golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180820150726</span><span class="number">-614</span>d502a4dac = &gt; github.com/golang/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180820150726</span><span class="number">-614</span>d502a4dac</span><br><span class="line">golang.org/x/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180821023952</span><span class="number">-922</span>f4815f713 = &gt; github.com/golang/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180826012351</span><span class="number">-8</span>a410e7b638d</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.0</span> = &gt; github.com/golang/text v0<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>require：项目依赖的包</li></ul><ul><li><p>exclude：忽略指定版本的依赖包</p></li><li><p>replace：由于在国内访问golang.org&#x2F;x的各个包都需要翻墙，你可以在go.mod中使用replace替换成github上对应的库。</p></li><li><p><code>incompatible</code> 表示不兼容标识，假如其当前版本为v3.6.0，因为其Module名字未遵循Golang所推荐的风格，即Module名中附带版本信息，我们称这个Module为不规范的Module。 在使用上没有区别，如果是我们自己开发的module，需要从 <code>xxx.com/xxx</code> 变到 <code>xxx.com/xxx/v2</code></p></li><li><p><code>indirect</code> 是指间接依赖的包，比如 a module 使用了 b module，但b module的go.mod不完整，或者未启用 go module的话，会把未记录在b的go.mod中又依赖了的包作为间接依赖，放到a的go.mod文件里</p></li></ul><p>下载依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个命令会下载指定路径的包或模块，并将其添加到`go.mod`文件中</span></span><br><span class="line">go get [url]        </span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载并更新到最新的次要版本或修订版本（patch version）</span></span><br><span class="line">go get -u [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会更新到最新的修订版本</span></span><br><span class="line">go get -u=patch [url]</span><br></pre></td></tr></table></figure><p>添加缺少的模块并删除未使用的模块，一般用来更新 go.mod 和 go.sum 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><p>其他的常用指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">go mod download：手动触发下载依赖包到本地cache（默认为<span class="variable">$GOPATH</span>/pkg/mod目录）</span><br><span class="line"></span><br><span class="line">go mod graph：打印项目的模块依赖结构</span><br><span class="line"></span><br><span class="line">go mod verify ：校验模块是否被篡改过</span><br><span class="line"></span><br><span class="line">go mod why：查看为什么需要依赖</span><br><span class="line"></span><br><span class="line">go mod vendor ：导出项目所有依赖到vendor下</span><br></pre></td></tr></table></figure><p><code>vendor</code> 文件夹是一个包含了项目所有依赖的本地副本的目录。</p><pre><code># support: nacos, consul, apollo, zk, etcd3  </code></pre><h1 id="type-file"><a href="#type-file" class="headerlink" title="type: file"></a>type: file</h1><pre><code>type: nacos  nacos:    server-addr: 127.0.0.1:8848    group: &#39;SEATA_GROUP&#39;    namespace: &#39;&#39;    dataId: &#39;seataServer.properties&#39;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 云原生 </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能大作业</title>
      <link href="/posts/fa82b526/"/>
      <url>/posts/fa82b526/</url>
      
        <content type="html"><![CDATA[<h1 id="1-实验简介"><a href="#1-实验简介" class="headerlink" title="1. 实验简介"></a>1. 实验简介</h1><p>使用Java编写NoC（Network-on-chip）片上网络模拟器，用于模拟消息的路由过程。</p><ul><li>网络结构：2D Mesh，规模<code>8*8</code></li><li>流量模式：uniform，transpose，hotspot</li><li>路由算法：主要Negative-first for 2D Meshes，并与XY路由算法、West-first算法进行对比。</li></ul><h1 id="2-算法描述"><a href="#2-算法描述" class="headerlink" title="2. 算法描述"></a>2. 算法描述</h1><h2 id="2-1-Mesh网络"><a href="#2-1-Mesh网络" class="headerlink" title="2.1 Mesh网络"></a>2.1 Mesh网络</h2><p>二维网格（2D-Mesh）拓扑结构，如图所示，该拓扑结构的特点是：每个节点的 上、下、左、右近邻相连，该拓扑具备结构简单、可扩展性较好、便于分析等优点。目前，2D-Mesh 是片上网络上最常用的一种拓扑结构。<br><img src="/../../img/Pasted%20image%2020240519153654.png"><br><img src="/../../img/Pasted%20image%2020240519153501.png"></p><p>本实验基于<code>8*8</code>的2D Mesh网络结构下进行。</p><h2 id="2-2-Turn-Model模型"><a href="#2-2-Turn-Model模型" class="headerlink" title="2.2 Turn Model模型"></a>2.2 Turn Model模型</h2><p>Turn Model模型是把每个路由节点相邻的4个通道分别用E（东）、W（西）、S（南）、N（北）四个方向标识，规定Turn Model转向指的是垂直角度的转向，例如自西向南的转向用WS表示，自北向东用NE表示，以此类推，因此所有的转向方式有：WE、EW、SW、WS、EN、NE、ES、SE共8种转向，如图所示。而这8种转向可以构成如下两种环。<br><img src="/../../img/Pasted%20image%2020240519154720.png"></p><p><img src="/../../img/Pasted%20image%2020240519154750.png"></p><h2 id="2-3-流量模式"><a href="#2-3-流量模式" class="headerlink" title="2.3 流量模式"></a>2.3 流量模式</h2><p>在片上网络（Network-on-Chip, NoC）的研究和模拟中，流量模式是指数据包在网络中的产生、传输和目的地的方式。不同的流量模式会影响网络中的通信需求和资源利用率，从而对网络的性能产生重要影响。<br>本实验主要涉及Uniform、Transpose、Hotspot三种流量模式，其含义如下：</p><ul><li>Uniform（均匀流量模式）<ul><li>在这种模式下，网络中的每个节点以相同的概率向其他任何节点发送数据包。</li><li>这种模式通常用于评估网络在均衡负载下的性能。</li></ul></li><li>Transpose（转置流量模式）<ul><li>转置流量模式通常指的是一种特定的通信模式，其中数据包的源节点和目的节点坐标在某种方式上呈现镜像关系。通信量集中在节点对之间的特定路径上。</li><li>例如，在二维网格NoC中，如果一个数据包从节点(0,0)发送到节点(1,1)，则另一个数据包可能从节点(1,1)发送到节点(0,0)。</li><li>这种模式可以用来模拟某些应用中存在的特定通信模式，如矩阵转置操作。</li></ul></li><li>Hotspot（热点流量模式）<ul><li>热点流量模式是指网络中有一个或几个节点充当热点，这些节点接收或发送大量的数据包，而其他节点则相对较少。</li><li>这种模式通常用于模拟那些通信不均匀的应用，例如某些计算任务中的中心服务器或共享资源。</li><li>热点流量模式会对网络中的某些部分造成较高的负载，可能会导致拥塞和性能瓶颈。</li></ul></li></ul><h2 id="2-4-Negative-first算法"><a href="#2-4-Negative-first算法" class="headerlink" title="2.4 Negative-first算法"></a>2.4 Negative-first算法</h2><p>Negative-First负向优先算法是转弯模型算法中的一种，此外还有West-First西向优先，North-Last北向最后转弯算法。负向优先转弯模型，是禁止数据包在路由的过程中朝负向转弯。其转弯模型图如下：<br><img src="/../../img/Pasted%20image%2020240519161135.png"></p><p>我们按如下图定义各方向的正负向，在坐标系中<strong>正方向</strong>为是Y+（北），X+（东），<strong>负方向</strong>为X-（西方向），Y-（南方向）。<br><img src="/../../img/Pasted%20image%2020240519161259.png"><br>算法通过禁止了一些转弯，避免了死锁环的产生， 该算法中不允许在正向路由的过程中转向负向路由，比如：一个数据包在向北（正向）传输过程中，禁止向西（负向）转向。在向东（正向）传输的过程中，禁止向南（负向）转向。负向优先路由算法规定，任何一个数据包在路由的时候，首先考虑的是向西和南进行自适应路由，然后再向东和北进行自适应路由。</p><p>假设当前节点的坐标<code>Current_Node</code>的坐标为<code>(curx,cury)</code>，目的节点 <code>Des_Node</code> 坐标为<code>(dstx,dsty)</code>，<code>△X=dstx-curx，△Y=dsty-cury</code>。数据包下一跳的方向为<code>dir</code></p><ol><li><code>△X=0 &amp;&amp; △Y=0</code>：当前节点即目的地，已经到达。</li><li><code>△X&gt;0 &amp;&amp; △Y=0</code>：目标节点在当前节点X+方向，数据包沿着 X+方向进行发送，如果在发送的过程中，遇到了故障链路或者缓冲已满，则沿着 Y-方向进行一个跳步</li><li><code>△X&lt;0 &amp;&amp; △Y=0</code>：目标节点在当前节点X-方向，数据包沿着X-方向进行发送，如果在发送的过程中，遇到了故障链路或者缓冲已满，则沿着Y-方向进行一个跳步</li><li><code>△X=0 &amp;&amp; △Y&gt;0</code>：目标节点在当前节点Y+方向，数据包沿着Y+方向进行发送，如果在发送的过程中，遇到了故障链路或者缓冲已满，则沿着X-方向进行一个跳步</li><li><code>△X=0 &amp;&amp; △Y&lt;0</code>：目标节点在当前节点Y-方向，数据包沿着Y-方向进行发送，如果在发送的过程中，遇到了故障链路或者缓冲已满，则沿着X-方向进行一个跳步</li><li><code>△X&gt;0 &amp;&amp; △Y&gt;0</code>：目标节点在当前节点东北方，数据包沿着X+&#x2F;Y+方向进行发送，如果在发送的过程中，遇到了故障链路或者缓冲已满，则沿着X-&#x2F;Y-方向进行一个跳步。这里规定优先按X方向进行。</li><li><code>△X&gt;0 &amp;&amp; △Y&lt;0</code>：目标节点在当前节点东南方，数据包沿着Y-方向进行发送，如果在发送的过程中，遇到了故障链路或者缓冲已满，则沿着X-方向进行一个跳步。这里规定优先按Y方向进行。</li><li><code>△X&lt;0 &amp;&amp; △Y&gt;0</code>：目标节点在当前节点西北方，数据包沿着X-方向进行发送，如果在发送的过程中，遇到了故障链路或者缓冲已满，则沿着Y-方向进行一个跳步。这里规定优先按X方向进行。</li><li><code>△X&lt;0 &amp;&amp; △Y&lt;0</code>：目标节点在当前节点西南方，数据包沿着X-&#x2F;Y-方向进行发送，如果在发送的过程中，遇到了故障链路或者缓冲已满，则沿着另一方向的负方向进行一个跳步。这里规定优先按X方向进行。</li></ol><h1 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3. 算法实现"></a>3. 算法实现</h1><h2 id="3-1-路由相关类"><a href="#3-1-路由相关类" class="headerlink" title="3.1 路由相关类"></a>3.1 路由相关类</h2><p><img src="/../../img/IRouting.png"></p><ul><li><code>IRouting</code>：定义了顶层接口，提供<code>forward</code>方法，接收message类型的参数，用于消息传播。</li><li><code>AbstractRouting</code>：抽象父类，包含了一些公有属性和方法。</li><li><code>NegativeFirstRouting</code>、<code>XYRouting</code>、<code>WestFirstRouting</code>：路由子类，实现了不同的路由算法。在本实验中，主要分析<code>NegativeFirst算法</code>，另外两个主要用于结果对比。</li></ul><p>具体路由选择代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> NodeInfo <span class="title function_">noWrapLinkrt</span><span class="params">(Q2DMeshNode cur,Q2DMeshNode dst)</span>&#123;  </span><br><span class="line">    <span class="comment">// 当前节点X、Y坐标  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">curx</span> <span class="operator">=</span> cur.x;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">cury</span> <span class="operator">=</span> cur.y;  </span><br><span class="line">    <span class="comment">// 目标节点X、Y坐标  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dstx</span> <span class="operator">=</span> dst.x;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">dsty</span> <span class="operator">=</span> dst.y;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 目标与当前节点的相对距离deltaX，deltaY  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">xdis</span> <span class="operator">=</span> dstx - curx;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">ydis</span> <span class="operator">=</span> dsty - cury;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> bufferslc;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// var1表示X上方向，var1表示Y上方向  </span></span><br><span class="line">    DirectionEnum var1=DirectionEnum.NONE,var2=DirectionEnum.NONE;  </span><br><span class="line">    <span class="type">int</span> vchx=<span class="number">0</span>,vchy=<span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">XYEnum</span> <span class="variable">perfer</span> <span class="operator">=</span> XYEnum.O;<span class="comment">//1表示优先走x,2表示优先走y  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 当前节点即目标节点  </span></span><br><span class="line">    <span class="keyword">if</span>(xdis==<span class="number">0</span> &amp;&amp; ydis==<span class="number">0</span>)&#123;  </span><br><span class="line">        var1 = DirectionEnum.NONE;  </span><br><span class="line">        var2 = DirectionEnum.NONE;  </span><br><span class="line">        perfer = XYEnum.O;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 目标节点在当前节点X轴正方向  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xdis&gt;<span class="number">0</span> &amp;&amp; ydis==<span class="number">0</span>)&#123;  </span><br><span class="line">        var1 = DirectionEnum.POSITIVE;<span class="comment">//优先x  </span></span><br><span class="line">        var2 = DirectionEnum.NEGATIVE;  </span><br><span class="line">        perfer = XYEnum.X;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 目标节点在当前节点X轴负方向  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xdis&lt;<span class="number">0</span> &amp;&amp; ydis==<span class="number">0</span>)&#123;  </span><br><span class="line">        var1 = DirectionEnum.NEGATIVE;<span class="comment">//优先x  </span></span><br><span class="line">        var2 = DirectionEnum.NEGATIVE;  </span><br><span class="line">        perfer = XYEnum.X;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 目标节点在当前节点Y轴正方向  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xdis==<span class="number">0</span> &amp;&amp; ydis&gt;<span class="number">0</span>)&#123;  </span><br><span class="line">        var1 = DirectionEnum.NEGATIVE;  </span><br><span class="line">        var2 = DirectionEnum.POSITIVE;<span class="comment">//优先y  </span></span><br><span class="line">        perfer = XYEnum.Y;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 目标节点在当前节点Y轴负方向  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xdis==<span class="number">0</span> &amp;&amp; ydis&lt;<span class="number">0</span>)&#123;  </span><br><span class="line">        var1 = DirectionEnum.NEGATIVE;  </span><br><span class="line">        var2 = DirectionEnum.NEGATIVE;<span class="comment">//优先y  </span></span><br><span class="line">        perfer = XYEnum.Y;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 目标节点在当前节点东北方  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xdis&gt;<span class="number">0</span> &amp;&amp; ydis&gt;<span class="number">0</span>)&#123;  </span><br><span class="line">        var1 = DirectionEnum.POSITIVE;<span class="comment">// 优先x  </span></span><br><span class="line">        var2 = DirectionEnum.POSITIVE;  </span><br><span class="line">        perfer = XYEnum.Y;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 目标节点在当前节点西南方  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xdis&lt;<span class="number">0</span> &amp;&amp; ydis&lt;<span class="number">0</span>)&#123;  </span><br><span class="line">        var1 = DirectionEnum.NEGATIVE;<span class="comment">// 优先x  </span></span><br><span class="line">        var2 = DirectionEnum.NEGATIVE;  </span><br><span class="line">        perfer = XYEnum.X;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 目标节点在当前节点东南方  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xdis&gt;<span class="number">0</span> &amp;&amp; ydis&lt;<span class="number">0</span>)&#123;  </span><br><span class="line">        var1 = DirectionEnum.NEGATIVE;  </span><br><span class="line">        var2 = DirectionEnum.NEGATIVE;<span class="comment">//优先y  </span></span><br><span class="line">        perfer = XYEnum.Y;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 目标节点在当前节点西北方  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xdis&lt;<span class="number">0</span> &amp;&amp; ydis&gt;<span class="number">0</span>)&#123;  </span><br><span class="line">        var1 = DirectionEnum.NEGATIVE;<span class="comment">//优先x  </span></span><br><span class="line">        var2 = DirectionEnum.NEGATIVE;  </span><br><span class="line">        perfer = XYEnum.X;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    Buffer[] xlink = <span class="keyword">new</span> <span class="title class_">Buffer</span>[]&#123;cur.bufferxneglink,<span class="literal">null</span>,cur.bufferxposlink&#125;;  </span><br><span class="line">    Buffer[] ylink = <span class="keyword">new</span> <span class="title class_">Buffer</span>[]&#123;cur.bufferyneglink,<span class="literal">null</span>,cur.bufferyposlink&#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span>[] xlinknode = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;cur.linkxneg,-<span class="number">1</span>,cur.linkxpos&#125;;  </span><br><span class="line">    <span class="type">int</span>[] ylinknode = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;cur.linkyneg,-<span class="number">1</span>,cur.linkypos&#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span>[] virtualch = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;R2,<span class="number">0</span>,R1&#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (Main.ALGORITHM == <span class="number">2</span>)&#123;  </span><br><span class="line">        vchx = R1;  </span><br><span class="line">        vchy = R1;  </span><br><span class="line">        <span class="type">Buffer</span> <span class="variable">xBuffer</span> <span class="operator">=</span> xlink[var1.getValue()];  </span><br><span class="line">        <span class="type">Buffer</span> <span class="variable">yBuffer</span> <span class="operator">=</span> ylink[var2.getValue()];  </span><br><span class="line">        <span class="type">int</span> <span class="variable">xNode</span> <span class="operator">=</span> xlinknode[var1.getValue()];  </span><br><span class="line">        <span class="type">int</span> <span class="variable">yNode</span> <span class="operator">=</span> ylinknode[var2.getValue()];  </span><br><span class="line">        bufferslc = prefer(xBuffer,yBuffer,vchx,vchy,next.getBuff(),perfer.getValue());  </span><br><span class="line">        <span class="keyword">switch</span> (bufferslc)&#123;  </span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:  </span><br><span class="line">                next.setNode(-<span class="number">1</span>);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="comment">// 走x方向  </span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line">                next.setBuff(xBuffer);  </span><br><span class="line">                next.setNode(xNode);  </span><br><span class="line">                next.setChannel(vchx);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="comment">// 走y方向  </span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:  </span><br><span class="line">                next.setBuff(yBuffer);  </span><br><span class="line">                next.setNode(yNode);  </span><br><span class="line">                next.setChannel(vchy);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//System.out.println(next);  </span></span><br><span class="line">        <span class="keyword">return</span> next;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> next;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-Mesh与Node"><a href="#3-2-Mesh与Node" class="headerlink" title="3.2 Mesh与Node"></a>3.2 Mesh与Node</h2><p>本实验定义了<code>8*8</code>的2d Mesh网络结构，其存放了64个网络节点，每个节点假设其坐标为<code>(x,y)</code>,那么此节点在网络中的编号定义为：<code>x*8+y</code>。</p><blockquote><p>网络类定义具体如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二维网格类，用于创建和管理一个二维网格系统。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Q2DMesh</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> k; <span class="comment">// 网格的大小（边长）</span></span><br><span class="line">    <span class="keyword">private</span> Q2DMeshNode[] head; <span class="comment">// 网格节点数组，存储网格的头部节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，初始化一个二维网格。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 网格的边长</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> R1buffer R1缓冲区大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> R2buffer R2缓冲区大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Q2DMesh</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> R1buffer,<span class="type">int</span> R2buffer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.k = n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> k * k;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Q2DMeshNode</span>[t];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建所有网格节点并初始化它们的坐标和缓冲区</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; k; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; k; y++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> x + y*k;</span><br><span class="line">                <span class="type">Q2DMeshNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Q2DMeshNode</span>();</span><br><span class="line">                node.setMesh(<span class="built_in">this</span>);</span><br><span class="line">                node.setCoordinate(id,x,y);</span><br><span class="line">                node.setBuffer(R1buffer,R2buffer);</span><br><span class="line">                head[id] = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为每个节点设置四个方向链路的缓冲区</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; k; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; k; y++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> x + y*k;</span><br><span class="line">                <span class="type">int</span> xneg, xpos , yneg, ypos;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算节点的四个相邻节点的索引</span></span><br><span class="line">                <span class="keyword">if</span> (x!=<span class="number">0</span>) xneg = (x-<span class="number">1</span>) + y*k;</span><br><span class="line">                <span class="keyword">else</span> xneg = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (x!=k-<span class="number">1</span>) xpos = (x+<span class="number">1</span>) + y*k;</span><br><span class="line">                <span class="keyword">else</span> xpos = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (y!=<span class="number">0</span>) yneg = x + (y-<span class="number">1</span>)*k;</span><br><span class="line">                <span class="keyword">else</span> yneg = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (y!=k-<span class="number">1</span>) ypos = x + (y+<span class="number">1</span>)*k;</span><br><span class="line">                <span class="keyword">else</span> ypos = -<span class="number">1</span>;</span><br><span class="line">                head[id].setLinkBuffer(xneg,xpos,yneg,ypos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取网格的边长。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 网格的边长</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getK</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取网格节点数组。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 网格节点数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Q2DMeshNode[] getHead() &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除所有节点的缓冲区。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k*k; i++) &#123;</span><br><span class="line">            head[i].clearBuffer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>节点类定义具体如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leggasai.network;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Q2DMeshNode类代表了一个二维网格网络中的节点。</span></span><br><span class="line"><span class="comment"> * 节点包含自身的缓冲区、与邻居节点的链接信息，以及节点的位置信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Q2DMeshNode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息最大长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MESSLENGTH</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 频道标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">R1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">R2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nodeId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区：x轴负方向</span></span><br><span class="line">    <span class="keyword">public</span> Buffer bufferxneg;</span><br><span class="line">    <span class="comment">// 缓冲区：x轴正方向</span></span><br><span class="line">    <span class="keyword">public</span> Buffer bufferxpos;</span><br><span class="line">    <span class="comment">// 缓冲区：y轴负方向</span></span><br><span class="line">    <span class="keyword">public</span> Buffer bufferyneg;</span><br><span class="line">    <span class="comment">// 缓冲区：y轴正方向</span></span><br><span class="line">    <span class="keyword">public</span> Buffer bufferypos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链接缓冲区：x轴负方向链接</span></span><br><span class="line">    <span class="keyword">public</span> Buffer bufferxneglink;</span><br><span class="line">    <span class="comment">// 链接缓冲区：x轴正方向链接</span></span><br><span class="line">    <span class="keyword">public</span> Buffer bufferxposlink;</span><br><span class="line">    <span class="comment">// 链接缓冲区：y轴负方向链接</span></span><br><span class="line">    <span class="keyword">public</span> Buffer bufferyneglink;</span><br><span class="line">    <span class="comment">// 链接缓冲区：y轴正方向链接</span></span><br><span class="line">    <span class="keyword">public</span> Buffer bufferyposlink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链接的节点ID：x轴负方向</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> linkxneg;</span><br><span class="line">    <span class="comment">// 链接的节点ID：x轴正方向</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> linkxpos;</span><br><span class="line">    <span class="comment">// 链接的节点ID：y轴负方向</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> linkyneg;</span><br><span class="line">    <span class="comment">// 链接的节点ID：y轴正方向</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> linkypos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所属的网格对象</span></span><br><span class="line">    <span class="keyword">private</span> Q2DMesh mesh;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的x坐标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="comment">// 节点的y坐标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置节点的坐标。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nodeId 节点ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 节点的x坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y 节点的y坐标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCoordinate</span><span class="params">(<span class="type">int</span> nodeId,<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nodeId = nodeId;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置节点的缓冲区参数。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buff1 第一个参数，用于配置缓冲区</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buff2 第二个参数，用于配置缓冲区</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuffer</span><span class="params">(<span class="type">int</span> buff1,<span class="type">int</span> buff2)</span>&#123;</span><br><span class="line">        <span class="comment">// 初始化缓冲区</span></span><br><span class="line">        bufferxneg = <span class="keyword">new</span> <span class="title class_">Buffer</span>();</span><br><span class="line">        bufferxpos = <span class="keyword">new</span> <span class="title class_">Buffer</span>();</span><br><span class="line">        bufferyneg = <span class="keyword">new</span> <span class="title class_">Buffer</span>();</span><br><span class="line">        bufferypos = <span class="keyword">new</span> <span class="title class_">Buffer</span>();</span><br><span class="line">        clearBuffer(); <span class="comment">// 清除缓冲区状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置缓冲区参数</span></span><br><span class="line">        bufferxneg.r1 = buff1;</span><br><span class="line">        bufferxpos.r1 = buff1;</span><br><span class="line">        bufferyneg.r1 = buff1;</span><br><span class="line">        bufferypos.r1 = buff1;</span><br><span class="line"></span><br><span class="line">        bufferxneg.r2 = buff2;</span><br><span class="line">        bufferxpos.r2 = buff2;</span><br><span class="line">        bufferyneg.r2 = buff2;</span><br><span class="line">        bufferypos.r2 = buff2;</span><br><span class="line"></span><br><span class="line">        bufferxneg.c = (buff1+buff2) / MESSLENGTH;</span><br><span class="line">        bufferxpos.c = (buff1+buff2) / MESSLENGTH;</span><br><span class="line">     </span><br></pre></td></tr></table></figure><h2 id="3-3-Message"><a href="#3-3-Message" class="headerlink" title="3.3 Message"></a>3.3 Message</h2><p>用于模拟在网络中传输的消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leggasai.network;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息类，用于在网络中传输消息数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息处理时间常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROCESSTIME</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 消息超时时间常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIMEOUT</span> <span class="operator">=</span> <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> length;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息来源节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> src;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息目标节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> dst;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> timeout;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息开始传输时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> begintrans;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息当前处理步骤</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> step;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息是否处于活动状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> active;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息路由路径上的节点信息数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> NodeInfo[] routePath;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由路径上节点的计数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否释放链路资源的标志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> releaselink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转向标志，用于网络中的方向调整</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> turn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认构造函数，初始化消息来源和目标为-1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Message</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.src = -<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>.dst = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，初始化消息的来源和目标节点。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src 消息来源节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dst 消息目标节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Message</span><span class="params">(<span class="type">int</span> src, <span class="type">int</span> dst)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.src = src;</span><br><span class="line">        <span class="built_in">this</span>.dst = dst;</span><br><span class="line">        begintrans = PROCESSTIME;</span><br><span class="line">        routePath = <span class="keyword">new</span> <span class="title class_">NodeInfo</span>[Q2DMeshNode.MESSLENGTH];</span><br><span class="line">        <span class="comment">// 初始化路由路径上的节点信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Q2DMeshNode.MESSLENGTH; i++) &#123;</span><br><span class="line">            <span class="type">NodeInfo</span> <span class="variable">nodeInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeInfo</span>();</span><br><span class="line">            nodeInfo.setNode(src);</span><br><span class="line">            nodeInfo.setChannel(<span class="number">0</span>);</span><br><span class="line">            nodeInfo.setBuff(<span class="literal">null</span>);</span><br><span class="line">            routePath[i] = nodeInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.step = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.active = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.length = Q2DMeshNode.MESSLENGTH;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.releaselink = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.turn = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.timeout = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-Event类"><a href="#3-4-Event类" class="headerlink" title="3.4 Event类"></a>3.4 Event类</h2><p>Event类主要用于生成消息以及调用路由算法进行消息传播。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leggasai.network;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leggasai.network.route.AbstractRouting;</span><br><span class="line"><span class="keyword">import</span> com.leggasai.network.route.IRouting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件类，用于处理消息的生成和转发。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Jiang Yichen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024-05-18-14:05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> consumed; <span class="comment">// 已消费的消息数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> totalcir; <span class="comment">// 总循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> messarrive; <span class="comment">// 到达的消息数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> k; <span class="comment">// 网络中节点的维度</span></span><br><span class="line">    <span class="keyword">private</span> Q2DMesh mesh; <span class="comment">// 网络拓扑</span></span><br><span class="line">    <span class="keyword">private</span> AbstractRouting route; <span class="comment">// 路由算法实例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，初始化事件对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> route 路由算法实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Event</span><span class="params">(AbstractRouting route)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.route = route;</span><br><span class="line">        <span class="built_in">this</span>.mesh = route.getMesh();</span><br><span class="line">        <span class="built_in">this</span>.k = route.getK();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成一条消息，实现均匀流量模式。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 生成的消息对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">genMes</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 实现uniform流量模式</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tempRand</span> <span class="operator">=</span> Math.abs(rand.nextInt()) % (k*k);</span><br><span class="line">        <span class="type">int</span> src,dest;</span><br><span class="line">        src = tempRand;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            tempRand = Math.abs(rand.nextInt()) % (k*k);</span><br><span class="line">            <span class="keyword">if</span> (tempRand != src)&#123;</span><br><span class="line">                dest = tempRand;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>(src,dest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转发消息。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 待转发的消息对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">forwardMes</span><span class="params">(Message s)</span>&#123;</span><br><span class="line">        <span class="comment">// 检查消息是否开始传输，更新传输状态</span></span><br><span class="line">        <span class="keyword">if</span>(s.getBegintrans() &lt;= <span class="number">0</span>) s.setCount(s.getCount()+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在源节点进行特殊处理</span></span><br><span class="line">        <span class="keyword">if</span>(s.getRoutePath()[<span class="number">0</span>].getNode() == s.getSrc())&#123;</span><br><span class="line">            <span class="comment">// 若尚未开始传输，则准备传输</span></span><br><span class="line">            <span class="keyword">if</span>(s.getBegintrans() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                s.setBegintrans(s.getBegintrans()-<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s.setBegintrans(s.getBegintrans()-<span class="number">1</span>);</span><br><span class="line">                <span class="type">NodeInfo</span> <span class="variable">next</span> <span class="operator">=</span> route.forward(s);</span><br><span class="line">                <span class="comment">// 若无法找到下一跳节点，超时计数器加1</span></span><br><span class="line">                <span class="keyword">if</span> (next.getNode() == -<span class="number">1</span>)&#123;</span><br><span class="line">                    s.setTimeout(s.getTimeout()+<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 成功找到下一跳，重置超时计数器</span></span><br><span class="line">                    s.setTimeout(<span class="number">0</span>);</span><br><span class="line">                    s.getRoutePath()[<span class="number">0</span>]=next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在非源节点进行转发逻辑处理</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 若当前节点不是目的节点，则尝试转发</span></span><br><span class="line">            <span class="keyword">if</span> (s.getRoutePath()[<span class="number">0</span>].getNode() != s.getDst())&#123;</span><br><span class="line">                <span class="type">NodeInfo</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (route!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    next = route.forward(s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 无法找到下一跳节点，消息进入重试逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (next.getNode() == -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> i;</span><br><span class="line">                    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;Q2DMeshNode.MESSLENGTH&amp;&amp;s.getRoutePath()[i].getNode()==s.getRoutePath()[<span class="number">0</span>].getNode();i++);</span><br><span class="line">                    <span class="keyword">if</span>(i &lt; Q2DMeshNode.MESSLENGTH)&#123;</span><br><span class="line">                        <span class="comment">// 处理消息路径中的环路</span></span><br><span class="line">                        NodeInfo temp1,temp2;</span><br><span class="line">                        temp2 = s.getRoutePath()[i-<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">while</span> (i&lt;Q2DMeshNode.MESSLENGTH)&#123;</span><br><span class="line">                            temp1 = s.getRoutePath()[i];</span><br><span class="line">                            s.getRoutePath()[i] = temp2;</span><br><span class="line">                            temp2 = temp1;</span><br><span class="line">                            i++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (temp2.getNode()!=s.getRoutePath()[Q2DMeshNode.MESSLENGTH-<span class="number">1</span>].getNode())&#123;</span><br><span class="line">                            s.setReleaselink(<span class="literal">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 缓存处理</span></span><br><span class="line">                        <span class="keyword">if</span> (temp2.getBuff()!=<span class="literal">null</span> &amp;&amp; temp2.getNode()!=s.getRoutePath()[Q2DMeshNode.MESSLENGTH-<span class="number">1</span>].getNode())&#123;</span><br><span class="line">                            temp2.getBuff().bufferPlus(temp2.getChannel(),Q2DMeshNode.MESSLENGTH);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    s.setTimeout(s.getTimeout()+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 成功找到下一跳节点，进行路径更新和缓存处理</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 处理路径更新和缓存</span></span><br><span class="line">                    NodeInfo temp1,temp2;</span><br><span class="line">                    temp2 = s.getRoutePath()[<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> i= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (i&lt;Q2DMeshNode.MESSLENGTH)&#123;</span><br><span class="line">                        temp1 = s.getRoutePath()[i];</span><br><span class="line">                        s.getRoutePath()[i] = temp2;</span><br><span class="line">                        temp2 = temp1;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (temp2.getNode()!=s.getRoutePath()[Q2DMeshNode.MESSLENGTH-<span class="number">1</span>].getNode())&#123;</span><br><span class="line">                        s.setReleaselink(<span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 缓存处理</span></span><br><span class="line">                    <span class="keyword">if</span> (temp2.getBuff()!=<span class="literal">null</span> &amp;&amp; temp2.getNode()!=s.getRoutePath()[Q2DMeshNode.MESSLENGTH-<span class="number">1</span>].getNode())&#123;</span><br><span class="line">                        temp2.getBuff().bufferPlus(temp2.getChannel(),Q2DMeshNode.MESSLENGTH);</span><br><span class="line">                    &#125;</span><br><span class="line">                    s.getRoutePath()[<span class="number">0</span>]=next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在目的节点进行消息接收处理</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                NodeInfo temp1,temp2;</span><br><span class="line">                temp2 = s.getRoutePath()[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> i;</span><br><span class="line">                <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;Q2DMeshNode.MESSLENGTH&amp;&amp;s.getRoutePath()[i].getNode()==s.getRoutePath()[<span class="number">0</span>].getNode();i++);</span><br><span class="line">                <span class="keyword">if</span> (i==Q2DMeshNode.MESSLENGTH)&#123;</span><br><span class="line">                    <span class="comment">// 完成消息传输，更新缓存</span></span><br><span class="line">                    s.getRoutePath()[i-<span class="number">1</span>].getBuff().bufferPlus(s.getRoutePath()[i-<span class="number">1</span>].getChannel(),Q2DMeshNode.MESSLENGTH);</span><br><span class="line">                    s.setActive(<span class="literal">false</span>);</span><br><span class="line">                    totalcir += s.getCount();</span><br><span class="line">                    messarrive++;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 处理路径更新和缓存</span></span><br><span class="line">                <span class="keyword">while</span> (i&lt;Q2DMeshNode.MESSLENGTH)&#123;</span><br><span class="line">                    temp1 = s.getRoutePath()[i];</span><br><span class="line">                    s.getRoutePath()[i] = temp2;</span><br><span class="line">                    temp2 = temp1;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp2.getNode()!=s.getRoutePath()[Q2DMeshNode.MESSLENGTH-<span class="number">1</span>].getNode())&#123;</span><br><span class="line">                    s.setReleaselink(<span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 缓存处理</span></span><br><span class="line">                <span class="keyword">if</span> (temp2.getBuff()!=<span class="literal">null</span> &amp;&amp; temp2.getNode()!=s.getRoutePath()[Q2DMeshNode.MESSLENGTH-<span class="number">1</span>].getNode())&#123;</span><br><span class="line">                    temp2.getBuff().bufferPlus(temp2.getChannel(),Q2DMeshNode.MESSLENGTH);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4-结果分析"><a href="#4-结果分析" class="headerlink" title="4. 结果分析"></a>4. 结果分析</h1><p><img src="/../../img/Pasted%20image%2020240519202119.png"></p><p><img src="/../../img/Pasted%20image%2020240519202113.png"></p><p>通过对比上述不同路由算法可以得出初步结论：</p><ul><li>在注入率和平均时延变化曲线来看：三者总体差距不大。且在注入率为0.5附近时，平均时延急剧升高。可能的原因：<ol><li><strong>网络拥塞：</strong> 当注入率达到一定水平时，可能会导致网络拥塞。在注入率为0.5附近，网络中的消息数量达到了临界点，超过了系统的处理能力，导致消息传输出现阻塞和延迟增加的情况。</li><li><strong>消息碰撞：</strong> 在高注入率下，可能会出现大量的消息碰撞现象，即多个消息同时到达目标节点，导致目标节点无法同时处理所有消息，从而造成延迟增加。</li><li><strong>资源竞争：</strong> 随着注入率的增加，网络中的节点之间竞争资源的情况也会增加。在注入率为0.5附近，节点之间的竞争可能达到了高峰，导致了消息传输的延迟增加。</li></ol></li><li>在注入率和吞吐量变化曲线来看：大致的饱和点在0.6附近。<code>Negative-First</code>算法对比其他两种算法稍优，特别是在注入率较高的水平下，而其他两个算法吞吐量几乎一致。其可能的原因为负向优先算法具有一定的灵活性，可以根据实际情况进行动态调整。在高注入率下，负向优先算法可能会根据网络负载情况动态选择合适的路径（绕开高负载节点），以最大程度地减少延迟和提高吞吐量。</li></ul><p>总体而言上述三种路由算法的性能差距不明显，其原因可能在于它们路径选择的相似性。</p><ul><li>都是基于简单转弯模型的，并根据相似的规则进行路由。</li><li>无法进行自适应变化，如果考虑更高的性能，可以采用自适应路由算法。</li><li>网络结构以及参数原因：本实验中节点和链路的缓存设置较小，可能对实验结果产生一定影响。</li></ul><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>本次实验通过编写Java程序来模拟NoC片上网络传输。实现了<code>Negative-First for 2D Meshes</code>算法,，通过评估平均延迟、吞吐量和饱和点对比了不同路由算法在不同负载情况下的性能表现。之后会尝试进一步研究和优化路由算法，比如采用自适应的路由算法等，以提高片上网络的性能和效率，同时可以考虑更多的性能指标和实验条件，以更全面地评估系统的性能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes</title>
      <link href="/posts/9acacb00/"/>
      <url>/posts/9acacb00/</url>
      
        <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><img src="/../../../img/Pasted%20image%2020240428162003.png"></p><p>控制面（Control Plane）：<strong>负责管理整个集群。</strong> 控制面协调集群中的所有活动，例如调度应用、维护应用的所需状态、应用扩容以及推出新的更新。</p><p>节点（Node）：是一个虚拟机或物理机，充当工作机器的角色。<strong>节点使用控制面暴露的 <a href="https://kubernetes.io/zh-cn/docs/concepts/overview/kubernetes-api/">Kubernetes API</a> 与控制面通信。</strong></p><h2 id="Kubernetes对象"><a href="#Kubernetes对象" class="headerlink" title="Kubernetes对象"></a>Kubernetes对象</h2><p>在 Kubernetes 系统中，<strong>Kubernetes 对象</strong>是持久化的实体。 Kubernetes 使用这些实体去表示整个集群的状态。Kubernetes 对象是一种“意向表达（Record of Intent）”。这就是 Kubernetes 集群所谓的<strong>期望状态（Desired State）</strong>。</p><p>每个对象都可以用yaml来进行描述。下面是一个具体的例子</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># 告知 Deployment 运行 2 个与该模板匹配的 Pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>在想要创建的 Kubernetes 对象所对应的清单（YAML 或 JSON 文件）中，需要配置的字段如下：</p><ul><li><code>apiVersion</code> - 创建该对象所使用的 Kubernetes API 的版本</li><li><code>kind</code> - 想要创建的对象的类别</li><li><code>metadata</code> - 帮助唯一标识对象的一些数据，包括一个 <code>name</code> 字符串、<code>UID</code> 和可选的 <code>namespace</code></li><li><code>spec</code> - 你所期望的该对象的状态</li></ul><h1 id="Minikube"><a href="#Minikube" class="headerlink" title="Minikube"></a>Minikube</h1><p>1、使用<code>minikube</code>在本地创建一个单集群k8s</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube start</span><br></pre></td></tr></table></figure><p>minikube的其他指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 Minikube </span></span><br><span class="line">minikube start </span><br><span class="line"><span class="comment"># 查看 Minikube 状态 </span></span><br><span class="line">minikube status </span><br><span class="line"><span class="comment"># 停止 Minikube </span></span><br><span class="line">minikube stop </span><br><span class="line"><span class="comment"># 删除 Minikube 集群 </span></span><br><span class="line">minikube delete</span><br></pre></td></tr></table></figure><h1 id="Kubectl基础"><a href="#Kubectl基础" class="headerlink" title="Kubectl基础"></a>Kubectl基础</h1><p>kubectl是k8s的命令行工具，用于和Kubernetes 集群进行交互和管理。它是 Kubernetes 的客户端工具之一，可以通过命令行界面（CLI）执行各种操作，如创建和管理资源、查看集群状态、调试应用程序等。</p><p>Q：kubectl如何建立和某个指定的Kubernetes集群的连接<br>A：kubectl通过集群<code>config</code>配置文件来建立和k8s集群之间的连接。kubectl会自动搜索主机上类似以下路径的配置文件，并尝试根据配置文件中集群的配置信息和集群建立连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$HOME/.kube/config</span><br><span class="line">$KUBECONFIG</span><br></pre></td></tr></table></figure><p>如何查看连接是否成功，如果连接成功，会返回集群中节点的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><h1 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h1><p>如果本机存在多个Kubernetes集群的话，需要指定kubectl去连接哪个集群。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kubectl config &lt;sub-command&gt;</span><br><span class="line">==============================</span><br><span class="line">  current-context   Display the current-context</span><br><span class="line">  delete-cluster    Delete the specified cluster from the kubeconfig</span><br><span class="line">  delete-context    Delete the specified context from the kubeconfig</span><br><span class="line">  delete-user       Delete the specified user from the kubeconfig</span><br><span class="line">  get-clusters      Display clusters defined in the kubeconfig</span><br><span class="line">  get-contexts      Describe one or many contexts</span><br><span class="line">  get-users         Display users defined in the kubeconfig</span><br><span class="line">  rename-context    Rename a context from the kubeconfig file</span><br><span class="line">  set               Set an individual value in a kubeconfig file</span><br><span class="line">  set-cluster       Set a cluster entry in kubeconfig</span><br><span class="line">  set-context       Set a context entry in kubeconfig</span><br><span class="line">  set-credentials   Set a user entry in kubeconfig</span><br><span class="line">  unset             Unset an individual value in a kubeconfig file</span><br><span class="line">  use-context       Set the current-context in a kubeconfig file</span><br><span class="line">  view              Display merged kubeconfig settings or a specified kubeconfig file</span><br></pre></td></tr></table></figure><p>查看所有可用的context</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl config get-contexts</span><br><span class="line"></span><br><span class="line">CURRENT   NAME             CLUSTER          AUTHINFO         NAMESPACE</span><br><span class="line">          docker-desktop   docker-desktop   docker-desktop</span><br><span class="line">*         minikube         minikube         minikube         default</span><br></pre></td></tr></table></figure><p>这里我使用minikube和docker-desktop分别启动了k8s集群，显示的内容如上，并且表示当前启用的是名为<code>minikube</code>的上下文。</p><p>查看当前启用的context</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl config current-context</span><br></pre></td></tr></table></figure><p>切换context</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl config use-context &lt;NAME&gt;</span><br></pre></td></tr></table></figure><h1 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h1><p>创建部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment &lt;deployment-name&gt; --image=&lt;image-name&gt;</span><br></pre></td></tr></table></figure><p>查看所有部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployments</span><br></pre></td></tr></table></figure><p>当创建Deployment后，K8s会创建一个Pod来托管该<strong>应用实例</strong>。Pod是由一个或多个应用容器构成的，一个pod中的容器能共享一些资源：</p><ul><li>共享存储，当作卷</li><li>网络，每个pod都有不同且唯一的IP地址</li><li>有关每个容器如何运行的信息，例如容器镜像版本或要使用的特定端口<br><img src="/../../../img/Pasted%20image%2020240429113900.png"></li></ul><p>一些kubectl的相关命令<br>1、获取现存的所有Pods</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>2、查看pods详情，包括IP 地址、使用的端口以及 Pod 生命期有关的事件列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pods</span><br></pre></td></tr></table></figure><p>3、查看pods的日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs &lt;pod-name&gt;</span><br><span class="line"></span><br><span class="line">kubectl logs &lt;pod-name&gt; -c &lt;container-name&gt;</span><br></pre></td></tr></table></figure><p>4、在容器中执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> &lt;pod-name&gt; -- &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line">kubectl <span class="built_in">exec</span> &lt;pod-name&gt; -c &lt;container-name&gt; -- &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure><p>节点（Node）<br>Pod 总是运行在<strong>节点</strong>上。节点是 Kubernetes 中参与计算的机器，可以是虚拟机或物理计算机，具体取决于集群。 每个节点由控制面管理。节点可以有多个 Pod，Kubernetes 控制面会自动处理在集群中的节点上调度 Pod。 控制面的自动调度考量了每个节点上的可用资源。<br>节点至少包括：</p><ul><li>Kubelet：负责 Kubernetes 控制面和节点之间通信的进程；它管理机器上运行的 Pod 和容器。</li><li>容器运行时：（如 Docker）负责从镜像仓库中提取容器镜像、解压缩容器以及运行应用。</li></ul><p>服务（Service）<br>Kubernetes的Service是一个抽象层，它定义了一组Pod的逻辑集，并为这些Pod支持外部流量暴露、负载均衡和服务发现。Kubernetes 中的服务（Service）是一种抽象概念，它定义了 Pod 的逻辑集和访问 Pod 的协议。<br>尽管每个 Pod 都有一个唯一的 IP 地址，但是如果没有 Service，这些 IP 不会被公开到集群外部。 Service 允许你的应用接收流量。 通过设置 Service 的 <code>spec</code> 中的 <code>type</code>，你可以用不同的方式公开 Service：</p><ul><li>_ClusterIP_（默认）- 在集群的内部 IP 上公开 Service。这种类型使得 Service 只能从集群内访问。</li><li><em>NodePort</em> - 使用 NAT 在集群中每个选定 Node 的相同端口上公开 Service 。使用<code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code> 从集群外部访问 Service。是 ClusterIP 的超集。</li><li><em>LoadBalancer</em> - 在当前云中创建一个外部负载均衡器（如果支持的话），并为 Service 分配一个固定的外部IP。是 NodePort 的超集。</li><li><em>ExternalName</em> - 将 Service 映射到 <code>externalName</code> 字段的内容（例如 <code>foo.bar.example.com</code>），通过返回带有该名称的 <code>CNAME</code> 记录实现。不设置任何类型的代理。这种类型需要 <code>kube-dns</code> 的 v1.7 或更高版本，或者 CoreDNS 的 0.8 或更高版本。</li></ul><p>标签（Label）<br>Service 通过<a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels">标签和选择算符</a>来匹配一组 Pod，它们是允许对 Kubernetes 中的对象进行逻辑操作的一种分组原语。 标签是附加在对象上的键&#x2F;值对，可以以多种方式使用：</p><ul><li>指定用于开发、测试和生产的对象</li><li>嵌入版本标记</li><li>使用标记将对象分类</li></ul><p><img src="/../../../img/Pasted%20image%2020240429123722.png"></p><h1 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h1><p>1、查看集群中的Services</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services</span><br></pre></td></tr></table></figure><p>2、暴露服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose deployment &lt;deployment-name&gt; --port=&lt;port&gt; --<span class="built_in">type</span>=&lt;service-type&gt;</span><br><span class="line"></span><br><span class="line">kubectl expose deployment/kubernetes-bootcamp --<span class="built_in">type</span>=<span class="string">&quot;NodePort&quot;</span> --port 8080</span><br></pre></td></tr></table></figure><p>3、使用标签<br>使用<code>describe</code>查看标签名称，app&#x3D;kubernetes-bootcamp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe deployment</span><br></pre></td></tr></table></figure><p><img src="/../../../img/Pasted%20image%2020240429144555.png"></p><p>通过标签名来查询pod，service</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -l app=kubernetes-bootcamp</span><br><span class="line"></span><br><span class="line">kubectl get service -l app=kubernetes-bootcamp</span><br></pre></td></tr></table></figure><p><img src="/../../../img/Pasted%20image%2020240429144709.png"></p><p>添加新标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label pods &lt;pod-name&gt; &lt;label key=label value&gt;</span><br></pre></td></tr></table></figure><p>4、 删除服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete service -l app=kubernetes-bootcamp</span><br></pre></td></tr></table></figure><h1 id="应用扩缩"><a href="#应用扩缩" class="headerlink" title="应用扩缩"></a>应用扩缩</h1><p><strong>扩缩</strong> 是通过改变 Deployment 中的副本数量来实现的。</p><p>查看由 Deployment 创建的 ReplicaSet</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get rs</span><br></pre></td></tr></table></figure><p>扩容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale deployments/kubernetes-bootcamp --replicas=4</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -o wide</span><br></pre></td></tr></table></figure><h1 id="应用更新"><a href="#应用更新" class="headerlink" title="应用更新"></a>应用更新</h1><p><strong>滚动更新</strong> 允许通过使用新的实例逐步更新 Pod 实例，实现<strong>零停机</strong>的 Deployment 更新。 新的 Pod 将被调度到具有可用资源的节点上。</p><p>滚动更新允许以下操作：</p><ul><li>将应用程序从一个环境升级到另一个环境（通过容器镜像更新）</li><li>回滚到以前的版本</li><li>持续集成和持续交付应用程序，无需停机</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2</span><br></pre></td></tr></table></figure><p><img src="/../../../img/Pasted%20image%2020240429153501.png"></p><p>验证更新，可以看到已经是v&#x3D;2版本<br><img src="/../../../img/Pasted%20image%2020240429153801.png"></p><p>检查更新状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout status deployments/kubernetes-bootcamp</span><br></pre></td></tr></table></figure><p>回滚更新</p><p>先执行一次错误的更新（不存在的版本号）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image deployments/kubernetes-bootcamp kubernetes-bootcamp=gcr.io/google-samples/kubernetes-bootcamp:v10</span><br></pre></td></tr></table></figure><p>通过<code>kubectl get pods</code>可以看到部分Pod的状态是<code>ImagePullBackOff</code>。通过<code>kubectl describe pods</code><br>可见在受影响的 Pod 的 <code>Events</code> 部分， 显示镜像的 <code>v10</code> 版本在仓库中不存在。</p><p><code>rollout undo</code> 命令会恢复 Deployment 到先前的已知状态（v2 的镜像）。 更新是受版本控制的，你可以恢复 Deployment 到任何先前已知状态。</p><p>清理本地集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete deployments/kubernetes-bootcamp services/kubernetes-bootcamp</span><br></pre></td></tr></table></figure><h1 id="部署Redis服务"><a href="#部署Redis服务" class="headerlink" title="部署Redis服务"></a>部署Redis服务</h1><p>1、应用 Redis Deployment</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://k8s.io/examples/application/guestbook/redis-leader-deployment.yaml</span><br></pre></td></tr></table></figure><p>也可以直接通过该yaml文件进行创建。</p><p>2、创建 Redis 领导者服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://k8s.io/examples/application/guestbook/redis-leader-service.yaml</span><br></pre></td></tr></table></figure><p>3、创建Redis Follower</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://k8s.io/examples/application/guestbook/redis-follower-deployment.yaml</span><br></pre></td></tr></table></figure><p>4、创建Redis Follower服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://k8s.io/examples/application/guestbook/redis-follower-service.yaml</span><br></pre></td></tr></table></figure><p>5、查看所有服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services</span><br></pre></td></tr></table></figure><p>6、创建前端Deployment</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://k8s.io/examples/application/guestbook/frontend-deployment.yaml</span><br></pre></td></tr></table></figure><p>7、创建前端服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://k8s.io/examples/application/guestbook/frontend-service.yaml</span><br></pre></td></tr></table></figure><p>8、由于使用docker作为容器驱动，需要开启minikube tunnel</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube service kubernetes-bootcamp --url</span><br></pre></td></tr></table></figure><p><img src="/../../../img/Pasted%20image%2020240429193346.png"><br>打开上述url<br><img src="/../../../img/Pasted%20image%2020240429193400.png"></p><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><h2 id="PersistentVolume-PV"><a href="#PersistentVolume-PV" class="headerlink" title="PersistentVolume(PV)"></a>PersistentVolume(PV)</h2><h2 id="PersistentVolumeClaim-PVC"><a href="#PersistentVolumeClaim-PVC" class="headerlink" title="PersistentVolumeClaim(PVC)"></a>PersistentVolumeClaim(PVC)</h2><h2 id="StorageClass"><a href="#StorageClass" class="headerlink" title="StorageClass"></a>StorageClass</h2><h1 id="StatefulSet基础"><a href="#StatefulSet基础" class="headerlink" title="StatefulSet基础"></a>StatefulSet基础</h1><h1 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h1><p>涉及Kubernetes集群内部是如何通信的。包括：</p><ul><li>容器间通信</li><li>Pod间通信</li><li>Pod和Service间通信</li><li>外部和Service间通信</li></ul><p>Kubernetes 强制要求所有网络设施都满足以下基本要求（从而排除了有意隔离网络的策略）：</p><ul><li>Pod 能够与所有其他<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点</a>上的 Pod 通信， 且不需要网络地址转译（NAT）</li><li>节点上的代理（比如：系统守护进程、kubelet）可以和节点上的所有 Pod 通信</li></ul><p>Kubernetes 的 IP 地址存在于 <code>Pod</code> 范围内 —— 容器共享它们的网络命名空间 —— 包括它们的 IP 地址和 MAC 地址。 这就意味着 <code>Pod</code> 内的容器都可以通过 <code>localhost</code> 到达对方端口。 这也意味着 <code>Pod</code> 内的容器需要相互协调端口的使用，但是这和虚拟机中的进程似乎没有什么不同， 这也被称为“一个 Pod 一个 IP”模型。</p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/621593509">一文让你全面了解K8s(Kubernetes) - 知乎 (zhihu.com)</a><br>官方文档：<a href="https://kubernetes.io/zh-cn/docs/home/">Kubernetes 文档 | Kubernetes</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 云原生 </tag>
            
            <tag> 容器化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向NLP模型的字符级白盒对抗样本生成方法研究</title>
      <link href="/posts/3e53bfad/"/>
      <url>/posts/3e53bfad/</url>
      
        <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ol><li><strong>白盒攻击</strong>：在机器学习模型的安全领域，攻击者如果具有关于模型的全部知识，包括模型的结构、参数和训练数据等，这种攻击被称为“白盒攻击”。攻击者利用这些信息生成对抗样本，目的是欺骗模型做出错误的预测。与之相对的，如果攻击者不知道模型的内部结构，</li><li><strong>字符级</strong>：这意味着对抗性干扰发生在文本数据的最小单位——字符层面。通过在文本数据中添加、删除或替换单个字符，攻击者可以生成与原始数据在人类理解上几乎相同，但在机器学习模型中可能导致不同输出的样本。</li><li><strong>对抗样本</strong>：对抗样本是通过在原始数据上故意添加人类难以察觉的扰动生成的样本，目的是欺骗机器学习模型。在字符级对抗样本的情况下，这些扰动通常是对文本中的字符进行微小的修改。</li><li><strong>对抗攻击</strong>：生成对抗样本让模型产生错误的输出称为对抗攻击。</li></ol><p>攻击粒度&#x2F;生成方法：幅度从大到小，更大地粒度更容易改变模型的输出结果。<br>句子级：<br>单词级：<br>字符级：<br><img src="/../../img/Pasted%20image%2020240425143417.png"></p><h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><ul><li>安全性：构造对抗样本干扰模型的输出，导致人工智能应用在关键领域出现判断失误、检测失效、隐私泄露等重大安全隐患。</li></ul><p>意义</p><ul><li>垃圾邮件分类检测，通过模型漏洞，构造样本来规避模型检测。</li><li>通过生成对抗样本的训练，提升模型的鲁棒性。</li></ul><p>任务类型</p><ul><li>分类任务：整个输入对应一个标签。</li><li>序列标注任务：句子-&gt;单词标签。</li><li>机器翻译任务：序列-&gt;序列任务</li></ul><h1 id="二、相关工作"><a href="#二、相关工作" class="headerlink" title="二、相关工作"></a>二、相关工作</h1><p>介绍了目前流行的几种方法</p><h2 id="句子级别"><a href="#句子级别" class="headerlink" title="句子级别"></a>句子级别</h2><p><img src="/../../img/Pasted%20image%2020240425145634.png"><br>添加句子、替换等价句子、转述句子、改变句子风格、重新生成句子</p><h2 id="单词级别"><a href="#单词级别" class="headerlink" title="单词级别"></a>单词级别</h2><p>原地修改句子中的某些词汇<br><img src="/../../img/Pasted%20image%2020240425150256.png"></p><h2 id="字符级别"><a href="#字符级别" class="headerlink" title="字符级别"></a>字符级别</h2><p><img src="/../../img/Pasted%20image%2020240425150731.png"></p><h1 id="三、本文方法——CLTRA"><a href="#三、本文方法——CLTRA" class="headerlink" title="三、本文方法——CLTRA"></a>三、本文方法——CLTRA</h1><p><img src="/../../img/Pasted%20image%2020240425151727.png"></p><p><strong>可替换字符串生成算法</strong><br>每个单词<strong>至少</strong>被分成三部分：<strong>首子词、中间子词（可能多个）、尾子词</strong>。子词是指在<strong>后缀词汇表</strong>中已经存在的。其中首子词和尾子词保证是<strong>最长匹配</strong>。然后只对中间子词进行扰动。从而重新拼接变成一个新的单词。<br><img src="/../../img/Pasted%20image%2020240426201019.png"><br><strong>最长匹配</strong>特点保证了在对中间子词进行扰动后，拼接成的新单词不会被分词器以和原来不同的切分方式切分。</p><p>e.g.<br>原单词：algorithm<br>分词器切分后：a lgorith m<br>进行扰动：a l<em>d</em>orith m<br>拼接：aldorithm<br>分词器重新切分：aldo rith m（与原来切分方式不一致，应该被切分为a l<em>d</em>orith m）</p><p><strong>后缀词汇表类别分布输入</strong></p><h2 id="扰动范围"><a href="#扰动范围" class="headerlink" title="扰动范围"></a>扰动范围</h2><p>尽可能保证对抗样本s’和原样本s的相似性。</p><p><strong>单词限制</strong>：取优先级最高的topk个单词进行扰动。<br>衡量指标：各个子词的梯度向量的二范数的均值<br><img src="/../../img/Pasted%20image%2020240426202012.png"></p><p><strong>符宽限制</strong>：限制子词长度的变化。</p><p><strong>形态相似限制</strong>：让被替换的子词和原子词看上去是“相似”的。比如love和1ove。<br>方法是生成每个子词的图片，衡量其视觉向量的相似度。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>$Loss &#x3D; L_{Adv} + \lambda_{size}*L_{size} + \lambda_{vision}*L_{vision}$</p><p>对抗损失函数、符宽限制系数，符宽损失函数、形态相似限制系数，形态相似损失函数</p><h1 id="四、实验评估"><a href="#四、实验评估" class="headerlink" title="四、实验评估"></a>四、实验评估</h1><h2 id="分类任务"><a href="#分类任务" class="headerlink" title="分类任务"></a>分类任务</h2><p><strong>数据集</strong><br><img src="/../../img/Pasted%20image%2020240425194226.png"><br><strong>评价指标</strong></p><ul><li>准确率：来评估对抗样本是否攻击成功，越低越好。</li><li>编辑距离：衡量对抗样本与原输入的扰动大小。越低意味着相似度更高。</li><li>查询次数：在构造对抗样本时，查询目标模型的次数。越低越好，意味着成本和性能更优。<br><strong>基线方法</strong></li><li>GBDA：目前最优秀的<strong>单词级白盒</strong>对抗样本生成方法</li><li>DeepWordBug：<strong>字符级</strong>的<strong>黑盒</strong>对抗样本生成方法<br><strong>实验结果</strong><br><img src="/../../img/Pasted%20image%2020240425194617.png"><br><img src="/../../img/Pasted%20image%2020240425194856.png"></li></ul><h2 id="序列标注任务"><a href="#序列标注任务" class="headerlink" title="序列标注任务"></a>序列标注任务</h2><p><strong>命名实体识别任务</strong>：识别文本中的特定实体，并为这些实体分类。<br>Case：Apple Inc. announced its new product line in Cupertino on September 10th.</p><ul><li>Apple： (B-ORG)——组织名</li><li>Cupertino： (B-LOC)——地点</li></ul><ul><li>September ：(B-DATE)——时间</li></ul><p><strong>槽位抽取任务</strong>：从文本中抽取特定信息的值，如时间、地点、数量。依赖于NER的结果来识别并分类信息。<br>Case：I want to book a flight from New York to London on July 15th.</p><ul><li>意图：book a flight</li><li>出发地：New York</li><li>目的地：London</li><li>日期：July 15th</li></ul><p><strong>数据集</strong><br><img src="/../../img/Pasted%20image%2020240425195422.png"></p><p><strong>评价指标</strong></p><ul><li>F1-Score：Precision和Recall的调和平均，用于衡量查准率和查全率。</li><li>实体攻击成功率：所有实体中攻击成功的实体的比例。判断标准是首个单词的B标签是否分类错误，B表示实体的开始。</li><li>编辑距离：同任务1</li><li>查询次数：同任务1</li></ul><p><strong>基线方法</strong></p><ul><li>Zeroe：基于视觉攻击，用特殊字符进行替换，其原理是因为BERT的词汇表不包含上述这些特殊字符，其会被映射为<code>[UNK]</code>，有效的破坏了单词的语义。</li></ul><p><strong>实验结果</strong><br><img src="/../../img/Pasted%20image%2020240425200026.png"><br><img src="/../../img/Pasted%20image%2020240425200055.png"></p><p><strong>符宽限制系数和形态相似限制系数</strong><br>更大的形态相似限制系数，使得文本的扰动更小，因此编辑距离变小，导致实体攻击成功率降低。<br><img src="/../../img/Pasted%20image%2020240425200322.png"></p><p>符宽限制系数对实体攻击成功率影响不大，但对编辑距离影响较大。<br><img src="/../../img/Pasted%20image%2020240425200439.png"></p><h2 id="机器翻译任务"><a href="#机器翻译任务" class="headerlink" title="机器翻译任务"></a>机器翻译任务</h2><p><strong>数据集</strong><br><img src="/../../img/Pasted%20image%2020240425200646.png"><br><strong>评价指标</strong></p><ul><li>攻击成功率：对抗样本生成的翻译和参考翻译的BLUE 分数降低为原来的一半以下。</li><li>相对BLUE降低值：整个数据集平均降低的 BLUE比例，是降低值与原来值的比。</li><li>相对chrF降低值：整个数据集平均降低的 chrF比例，是降低值与原来值的比。字符级别。</li><li>扰动百分比：对抗样本与原样本相比扰动的百分比。</li></ul><p><strong>基线模型</strong></p><ul><li>Seq2Sick：白盒攻击方法，梯度来构造词嵌入空间的扰动，再映射回离散序列。</li><li>TransFool：白盒攻击方法，同上，但使用了词嵌入。</li></ul><p><strong>实验结果</strong><br><img src="/../../img/Pasted%20image%2020240425203148.png"><br><img src="/../../img/Pasted%20image%2020240425203154.png"><br><img src="/../../img/Pasted%20image%2020240425203232.png"><br><img src="/../../img/Pasted%20image%2020240425204604.png"><br><img src="/../../img/Pasted%20image%2020240425204624.png"></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><strong>字符级</strong>粒度，意味着最高的相似程度，编辑距离值小，扰动范围小。</li><li><strong>白盒方法</strong>，更少的模型查询次数，性能更优，充分利用了梯度。</li><li><strong>普适性</strong>：在分类任务，序列标注任务，机器翻译任务上均取得了不错的效果。</li><li><strong>创新型算法</strong>：可替换字符串上传算法；扰动限制损失函数</li></ul><h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><ul><li>拓展其他任务：对于现有大模型的安全性、鲁棒性验证。</li><li>面向中文：需要改造分词算法</li><li>如何利用对抗样本：本文提出了构造对抗样本的方法，来揭示模型的缺陷和鲁棒性。如何利用对抗样本对模型进行强化？一种方式是将对抗样本作为训练集进行对抗训练。</li></ul><h1 id="六、"><a href="#六、" class="headerlink" title="六、"></a>六、</h1><h2 id="NLP-VS-LLM"><a href="#NLP-VS-LLM" class="headerlink" title="NLP VS LLM"></a>NLP VS LLM</h2><p>一些局限性：</p><ul><li>感觉本篇的工作可能是之前所做的，沉淀了一段时间，是在大语言模型出现之前的（模型基本都是用的BERT，也可以从他发表在EMNLP上的时间2022年推断出），试验了一下论文中提及的几个对抗样本，对现在的大语言模型似乎无效。作者也在未来展望中提到了未来运用到大模型上的一些想法。</li></ul><p>CASE 1：翻译任务<br><img src="/../../img/Pasted%20image%2020240425183443.png"></p><p>大语言模型可以识别错误并正确地猜测出了原文，根本骗不到大模型~<br><img src="/../../img/Pasted%20image%2020240425183329.png"></p><p>CASE 2：情感分类<br><img src="/../../img/Pasted%20image%2020240425183955.png"></p><p>大语言模型依旧可以正确判断对抗样本，并且能够帮你进行<strong>纠错</strong>，比如<code>teruible -&gt; terrible</code><br><img src="/../../img/Pasted%20image%2020240425183944.png"></p><p>CASE 3：序列标注任务<br><img src="/../../img/Pasted%20image%2020240425190426.png"></p><p>可以正确标注，并且能够将对抗样本中的扰动 <code>baliimore -&gt; baltimore</code>进行纠正<br><img src="/../../img/Pasted%20image%2020240425190416.png"></p><ul><li>这篇文章我认为写的非常不错，提出了比较创新的算法，并通过详细的实验数据作为支撑，验证了其算法的高效性。（相关算法已发表在NLP领域顶会EMNLP，其有效性、真实性可保证）</li><li>验证了一个观点，LLM的出现让传统NLP无路可走。</li><li>不过值得注意的是，上述的训练集都来自领域内非常流行的公开语料库，不排除大模型使用它们进行了训练，所以才导致了对抗样本失效。</li><li>由于目前大模型存在安全性、可解释性、幻觉等方面的缺陷，如果能通过有效的对抗样本学习来解决上述问题，是未来大模型优化的一个点。</li></ul><p>论文链接：<br><a href="https://arxiv.org/pdf/2210.17004.pdf">2210.17004.pdf (arxiv.org)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 大模型 </tag>
            
            <tag> 论文 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/posts/6c92115f/"/>
      <url>/posts/6c92115f/</url>
      
        <content type="html"><![CDATA[<h1 id="IOC原理"><a href="#IOC原理" class="headerlink" title="IOC原理"></a>IOC原理</h1><p>Bean对象的创建周期<br>xxx.class -&gt; 推断构造方法 -&gt; 对象（其属性还未赋值） -&gt; 依赖注入(Autowred) -&gt; 初始化前 -&gt; 初始化(aterPropertiesSet) -&gt; 初始化后(AOP)  -&gt; (代理对象) -&gt; 存入Map -&gt; Bean对象</p><ul><li>单例池：存放所有单例Bean的缓存池。可能存在不同名，但同类型的Bean。</li><li>推断构造方法：有@Autowired优先，无参优先；有多个有参构造但没有无参，报错</li><li>查找策略：先根据类型，再根据 名字从单例池中查找。</li><li>命名：如果Compoent没有显式命名，Spring会默认用小写类名去命名。</li></ul><h2 id="类、类实例、类的Class对象、类加载器"><a href="#类、类实例、类的Class对象、类加载器" class="headerlink" title="类、类实例、类的Class对象、类加载器"></a>类、类实例、类的Class对象、类加载器</h2><p><img src="/../../../img/Pasted%20image%2020240323130657.png"></p><ul><li><code>.java</code>文件经过<code>javac.exe</code>编译为<code>.class</code>二进制文件。一般存放在和<code>.java</code>源文件位置相似的地方。</li><li>类的<code>Class</code>对象用来描述一个类，每个类都对应一个<code>Class</code>对象，包含了类的元信息，如类的名称、父类、实现的接口、类的修饰符等。通过<code>Class</code>对象可以创造一个该类的实例。</li><li>类加载器<code>classLoader</code>的主要作用就是加载 Java 类的字节码（ <code>.class</code> 文件）到 JVM 中（在内存中生成一个代表该类的 <code>Class</code> 对象）。</li><li>可以通过上图中的<code>getClass()</code>以及<code>getClassLoader()</code>方法进行转换。<br><img src="/../../../img/Pasted%20image%2020240323210610.png"></li></ul><h2 id="手写一个IOC-Demo"><a href="#手写一个IOC-Demo" class="headerlink" title="手写一个IOC Demo"></a>手写一个IOC Demo</h2><ul><li>理解@ComponentScan、@Component、@Scope、@Autowired</li></ul><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><p>按照之前Bean的生命周期，构造实例化 -&gt; 依赖注入  -&gt; 存入单例池。那么如果类中的属性相互依赖对方，导致创建Bean之后进行依赖注入时，发现需要注入的类也在等待自己。因此双方都在等待，无法完成创建。Spring是如何解决的？如果按照一般思路：可以先将双方进行实例化，延迟依赖注入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component  </span><br><span class="line">public class OneService &#123;  </span><br><span class="line">  </span><br><span class="line">    @Autowired  </span><br><span class="line">    private TwoService twoService;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component  </span><br><span class="line">public class TwoService &#123;  </span><br><span class="line">    @Autowired  </span><br><span class="line">    private OneService oneService;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三级缓存机制</p><ol><li>第一级：singletonObjects：存储最终的单例</li><li>第二级：earlySingletonObjects：存放发生循环依赖时的，并提前AOP的<strong>中间态</strong>Bean。防止发生多个循环依赖时，创建多个中间态Bean。（中间态指因循环依赖而未完成全部构造过程的Bean）</li><li>第三级：singletonFactories：用来存放提前AOP时的对象表达式（先于AOP，二级缓存存的是AOP后的）<br>提前AOP<br><img src="/../../../img/Pasted%20image%2020240323185058.png"></li></ol><h1 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h1><p>xxxProxy对象 -&gt; xxx代理对象 -&gt; xxx代理对象.target &#x3D; 普通对象（被代理的原对象）-&gt; 放入单例池<br><img src="/../../../img/Pasted%20image%2020240323145908.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现RPC框架——gsRPC</title>
      <link href="/posts/bcab05d2/"/>
      <url>/posts/bcab05d2/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>使用Netty以及Zookeeper实现RPC框架。</p><h1 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h1><h2 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h2><p><img src="/../../../../img/Pasted%20image%2020240331170806.png"><br>client端的基本功能是服务发现和服务代理。</p><p>细节实现部分：</p><ul><li>服务发现：当服务调用者上线后，需要从注册中心订阅所有（可以做一个优化，只订阅自己关心的服务）的服务，以及服务提供者的信息。一旦发生变化，注册中心会及时通知服务调用者。</li><li>服务代理：通过动态代理将本地方法的执行转化为发送请求，让服务提供者执行后返回结果。初步考虑使用CGLIB实现代理。</li><li>负载均衡：多种负载均衡算法，<strong>随机路由</strong>、最少活跃优先、最短响应优先、轮询路由、一致性哈希路由。参考<a href="https://cn.dubbo.apache.org/zh-cn/overview/core-features/load-balance/">负载均衡 | Apache Dubbo</a><ul><li>加权随机：按权重设置随机概率。权重由服务提供者给出，权重越高的服务提供者代表处理能力越强，越容易被选中。</li><li>加权轮询：平滑加权轮询算法。</li><li>最少活跃数优先：活跃数越低，越优先调用，相同活跃数的进行加权随机。</li><li>最短响应优先：在最近一个滑动窗口中，响应时间越短，越优先调用。</li><li>一致性Hash（实现较难）：相同参数的请求总是发到同一提供者。</li></ul></li><li>连接池管理：预先和服务端建立长连接，降低连接开销。</li></ul><ol><li>客户端扫描<code>@GsConsumer</code>注解标识的<code>Service</code>属性，初始化Bean的时候进行动态代理。将所有客户端需要的<code>Service</code>信息保存为集合。</li><li>服务发现和订阅，注册中心连接Zookeeper，进行按需订阅上述<code>Service</code>对应的所有服务者的信息，保存为Map。<code>key</code>为<code>Service</code>标识，<code>value</code>为<code>Provider</code>信息列表。</li><li>连接池和上述<code>Providers</code>建立长连接，并缓存。保存<code>Service</code>和<code>Channel</code>的Map。</li><li>应用端发起调用，执行代理方法。代理将调用信息<code>Invocation</code>发送给任务管理者。</li><li>任务管理者根据负载均衡策略找到一个对应的<code>Provider</code>信息，然后从连接池获取客户端和该<code>Provider</code>连接的<code>Channel</code>。生成<code>Request</code>并发送到<code>Channel</code>，提交到线程池。</li><li>等待服务端执行，返回结果</li><li><code>Channel</code>收到来自服务端的响应后，通知任务管理者</li><li>任务管理者进行信息统计，响应时间等，然后将结果返回给代理。</li></ol><h3 id="GsReference"><a href="#GsReference" class="headerlink" title="@GsReference"></a>@GsReference</h3><p>用于标识消费者的服务。</p><ul><li>interfaceClass：接口的class</li><li>version：版本号</li></ul><h3 id="Proxy类"><a href="#Proxy类" class="headerlink" title="Proxy类"></a>Proxy类</h3><p>用于代理客户端方法，隐藏调用逻辑。提供了<code>cglib</code>、<code>jdk</code>、<code>javassist</code>三种方式。</p><h3 id="DiscoveryCenter"><a href="#DiscoveryCenter" class="headerlink" title="DiscoveryCenter"></a>DiscoveryCenter</h3><p>抽象类，用于和远端的注册中心进行交互，提供服务发现和服务订阅功能。<br>属性：</p><ul><li>ServiceCache：存储由<code>@GsConsumer</code>标注的所有所需服务。</li><li>Service2Invokers：存储<code>ServiceMeta -&gt; Invokers</code>的映射</li><li>InvokersMap：<code>ProviderKey -&gt; Invoker</code>映射</li></ul><p>方法：</p><ul><li>pullService：从注册中心拉取服务</li><li>watchNode：</li><li>watchNodeAndChildren：</li></ul><h3 id="ServiceMeta"><a href="#ServiceMeta" class="headerlink" title="ServiceMeta"></a>ServiceMeta</h3><p>客户端服务元信息，由<code>@GsConsumer</code>注解扫描生成<br>属性：</p><ul><li>ServiceName：服务名，全类名</li><li>Version：版本<br>方法：</li><li>getServiceKey：返回<code>ServiceName#version</code></li></ul><h3 id="Invoker"><a href="#Invoker" class="headerlink" title="Invoker"></a>Invoker</h3><p>服务提供者信息。这是从注册中心拉取的。用于构建 <code>ServiceKey-&gt;List&lt;Invoker&gt;</code>的映射。<br>属性：</p><ul><li>Ip：Ip地址</li><li>Port：端口号</li><li>Version：版本</li><li>Weight：权重</li><li>ServiceKey：标识。为<code>IP:Port#Version</code></li></ul><h3 id="Invocation"><a href="#Invocation" class="headerlink" title="Invocation"></a>Invocation</h3><p>服务调用信息。<br>属性：</p><ul><li>Request Body：请求体</li><li>Invoker：调用者</li><li>StartTime：开始时间</li><li>EndTime：结束时间</li><li>IsSuccess：是否成功</li><li>RequestId：请求唯一ID标识</li></ul><h3 id="InvocationManager"><a href="#InvocationManager" class="headerlink" title="InvocationManager"></a>InvocationManager</h3><p>服务调用中心，执行所有客户端调用的中心，内部维护一个CachedThreadPool</p><h3 id="LoadBalance接口"><a href="#LoadBalance接口" class="headerlink" title="LoadBalance接口"></a>LoadBalance接口</h3><p>负责客户端负载均衡，从<code>List&lt;Invoker&gt;</code>中按不同策略选出服务提供者，进行方法调用。</p><ul><li><code>ConsistentHash</code>：一致性哈希算法</li><li><code>RoundRobin</code>：基于权重的平滑轮询算法</li><li><code>WeightedRandom</code>：基于权重的随机算法</li><li><code>LeastActive</code>：最少活跃数优先算法</li><li><code>ShortestResponse</code>：最短响应时间优先算法<br>方法：</li><li>Select：<code>List&lt;Invoker&gt; -&gt; Invoker</code></li></ul><h3 id="Channel-Pool"><a href="#Channel-Pool" class="headerlink" title="Channel Pool"></a>Channel Pool</h3><p>用于构建及缓存和服务提供者长连接。<br>属性：</p><ul><li>Invokers2Handler：<code>Invoker -&gt; Handler</code><br>方法：</li><li>getHandlerByInvoker：获取Invoker对应的Handler。</li><li>addChannel：添加一个新<code>Invoker</code>的channel连接</li><li>removeChannel：移除一个<code>Invoker</code>的channel连接</li></ul><h2 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h2><p><img src="/../../../../img/Pasted%20image%2020240421195958.png"></p><p>Server端需要扫描提供的类接口和实现，并将服务注册到注册中心。之后开启NIO，接收客户端的连接，处理客户端发送的RPC请求。<br>细节实现部分：</p><ul><li>服务注册：当服务提供者开启后，首先就是扫描@GsService的接口和实现类。将其注册到注册中心<ul><li>需要和注册中心保持长连接，注册中心需要定时发送心跳（探活），来验证服务提供者是否在线；需要额外手段探测服务提供者是否还有能力处理请求。当服务提供者无法处理请求时，注册中心应该及时从服务提供者列表中移出该服务提供者。</li><li>健康检查机制：假死，健康，宕机。如果服务提供者和zookeeper断开连接，能不能发现？注册中心需要定期向zookeeper更新状态信息。</li></ul></li><li>服务监控：评估自己的处理能力。</li><li>限流&#x2F;容错：当无法接收更多的请求时，直接返回一个错误信息。</li><li>优雅关闭：当存在尚未处理完的请求时，可能需要延迟关闭。通常延迟十秒后，强制关闭。</li><li>监控客户端：服务提供者应该和客户端保持长连接，但如果若干时间内没有收到客户端发送的RPC请求时，应该主动关闭与该客户端的连接。优化点：当连接数超出最大限制时，应该首先关闭最久未请求的连接，LRU算法？（ChannelManager负责）</li><li>服务缓存：对服务实现类和服务Key进行缓存，用于通过反射执行方法。（Service Manager负责）</li></ul><p>组件功能：</p><ul><li>Channel Manager：连接管理，管理所有与客户端的连接，连接控制，活跃检测。</li><li>Service Manager：服务中心，保存服务Key -&gt; 实现类的映射，用于Task Manager调用某个服务中的方法。此外，将服务信息告诉注册中心。服务熔断</li><li>Registry Center：注册中心。将服务中心的服务信息提供给ZooKeeper，以及注销服务（熔断）</li><li>Task Manager：任务调度中心，负责处理请求，其依靠线程池。此外维护活跃任务数量，用于优雅停机时避免有进行中的任务，限流。</li></ul><h3 id="GsService"><a href="#GsService" class="headerlink" title="@GsService"></a>@GsService</h3><p>用于标识服务提供者的服务。</p><ul><li>interfaceClass：接口的class</li><li>version：版本号</li></ul><h3 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h3><p>服务提供者的服务中心，缓存了<code>Servicekey -&gt; ServiceImpl</code>的映射，用于执行实际的方法调用。初始化时，由<code>@GsService</code>注解注册到本服务中心中。</p><p>属性：</p><ul><li>ServicesMap：缓存<code>Servicekey -&gt; ServiceImpl</code>的映射，通过反射执行请求方法。<br>方法：</li><li>executeMethod：执行相应服务的相应方法，参数为request的请求信息。</li><li>cacheService：缓存服务实现类。</li></ul><h3 id="RegistryCenter"><a href="#RegistryCenter" class="headerlink" title="RegistryCenter"></a>RegistryCenter</h3><p>服务提供者的注册中心，负责和远程注册中心（Zookeeper）建立连接，并将服务注册到注册中心。服务列表来自于ServiceManager。<br>方法：</p><ul><li>registry：注册服务</li><li>unregistry：注销所有服务</li><li>doClose：关闭注册中心以及和zookeeper的连接。用于服务提供者下机。</li></ul><h3 id="TaskManager"><a href="#TaskManager" class="headerlink" title="TaskManager"></a>TaskManager</h3><p>服务提供者的任务中心，用于处理所有来自客户端的请求。内部使用<code>Map</code>映射<code>requestId -&gt; future</code>。此外还可以用来实现服务监控<br>属性：</p><ul><li>ThreadPool：内部线程池，用于并行处理任务<br>方法：</li><li>submitTask：提交任务Resquest到线程池,返回一个CompletableFuture&lt; Response &gt;对象，handler使用thenAccept方法避免阻塞。将ResponseBody写入Kindred，并写入ctx</li></ul><h3 id="ChannelManager"><a href="#ChannelManager" class="headerlink" title="ChannelManager"></a>ChannelManager</h3><p>服务提供者的连接管理中心，用于维护和客户端的长连接。实现连接数控制、流量控制。<br>属性：</p><ul><li>ChannelMap：缓存所有和客户端的channel。<br>方法：</li><li>addChannel：添加channel</li><li>removeChannel：移除channel</li></ul><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>用于处理Channel事件的Handler。继承SimpleChannelInboundHandler<br>属性：</p><ul><li>TaskManager：用于提交任务到</li><li>TaskMap：存储Request</li></ul><h2 id="通信协议和序列化"><a href="#通信协议和序列化" class="headerlink" title="通信协议和序列化"></a>通信协议和序列化</h2><p>协议：先实现一个自定义协议<strong>Kindred</strong>（类似dubbo），分为请求头部和请求体<br>序列化：支持hessian，kryo，protostuff，jdk原生，fst<br>Request Body以及Response Body定义<br>RequestHandler以及ResponseHandler：协议Adapter，序列化Adapter，工厂模式</p><p><img src="/../../../../img/Pasted%20image%2020240324193900.png"><br>Protocol Magic：Kindred协议固定为0xCDED，可以快速过滤。<br>Bit Info：</p><ul><li>Request&#x2F;Response（1bit）：标识是Request还是Response</li><li>Need return（1bit）：用于标识该Request是否需要服务端返回数据</li><li>Event（1bit）：是否是事件，心跳事件</li><li>Serialize Type（5bit）：序列化方式<br>Status：请求状态（仅对于Response有效，对于Request固定为0x00）</li><li>20：OK：成功</li><li>31：Client_timeout：客户端超时，客户端无法在合理的时间内收到服务端的响应。默认10s</li><li>32：Server_timeout：服务端超时，服务端处理请求超时。客户端由状态码判断。默认5s</li><li>40：Server_error：无法解析请求等</li><li>50：Server_limit_rate：服务端限流，请稍后再试 ok</li><li>60：Service_not_found：服务未找到 ok</li><li>70：Method_not_found：方法未找到 ok</li><li>80：Service_error：服务执行时发生错误，异常 ok</li></ul><p>Request ID：请求的唯一标识，雪花算法<br>Data Length：请求体长度，用于序列化</p><p>Data：存放请求体（这些是需要被序列化的）<br>对于Request：Request Body</p><ul><li>Service name：服务名String</li><li>Service version：服务版本String</li><li>Service method name：方法名String</li><li>Method parameter types：方法参数类型列表<code>Class&lt;?&gt;[]</code></li><li>Method arguments：方法参数值列表<code>Object[]</code></li><li>Extend fields：拓展字段，Map&lt;String,Object&gt;类型</li></ul><p>对于Response：Response Body</p><ul><li>Value type：返回的类型，null&#x2F;value&#x2F;exception</li><li>Value data：返回的数据，Object</li></ul><p>编解码过程：<br>解码器&#x2F;编码器需要知道使用的协议类型，以及序列化方式才能进行解码。<br>字节流 -&gt; 解码器 -&gt; 协议（请求头，请求体）<br>协议（请求头，请求体） -&gt; 编码器 -&gt; 字节流</p><p>类预注册：<br>部分序列化方式可以通过预先注册类Schema优化序列化性能。</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="Fst"><a href="#Fst" class="headerlink" title="Fst"></a>Fst</h3><h3 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h3><h3 id="Protostuff"><a href="#Protostuff" class="headerlink" title="Protostuff"></a>Protostuff</h3><h3 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a>Kryo</h3><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>性能</p><h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><h3 id="ApplicationProperties"><a href="#ApplicationProperties" class="headerlink" title="ApplicationProperties"></a>ApplicationProperties</h3><p>前缀：<code>gsrpc.application</code><br>描述：用于应用的配置信息</p><ul><li>name：应用名</li><li>proxy：代理方式jdk、javassist、cglib</li></ul><h3 id="ConsumerProperties"><a href="#ConsumerProperties" class="headerlink" title="ConsumerProperties"></a>ConsumerProperties</h3><p>前缀：<code>gsrpc.consumer</code><br>描述：服务调用者配置信息</p><ul><li>timeout：客户端超时时间</li><li>retries：重试次数</li><li>loadbalance：负载均衡策略</li><li>protocol：通信协议，默认Kindred（当前仅支持）</li><li>port：端口号netty，默认-1，表示随机</li><li>serialization：序列化方式，默认kryo。支持kryo、fst、hessian、Protostuff、jdk</li></ul><h3 id="ProviderProperties"><a href="#ProviderProperties" class="headerlink" title="ProviderProperties"></a>ProviderProperties</h3><p>前缀：<code>gsrpc.provider</code><br>描述：服务提供者配置信息</p><ul><li>timeout：服务端超时时间</li><li>retries：重试次数</li><li>protocol：通信协议，默认Kindred（当前仅支持）</li><li>port：端口号netty，默认20688</li><li>serialization：序列化方式，默认kryo。支持kryo、fst、hessian、Protostuff、jdk</li><li>weight：权重，默认5，范围1-10。</li><li>accepts：最大客户端连接数，默认1024<br>待拓展</li><li>eviction：客户端连接淘汰策略</li></ul><h3 id="RegistryProperties"><a href="#RegistryProperties" class="headerlink" title="RegistryProperties"></a>RegistryProperties</h3><p>前缀：<code>gsrpc.registry</code><br>描述：服务注册中心的相关配置 </p><ul><li>ip：地址</li><li>port：端口号</li><li>type：注册中心类型，默认zookeeper</li><li>timeout：连接超时时间</li><li>session：会话超时时间</li></ul><h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><ul><li><input disabled="" type="checkbox"> registryCenter的配置注入优化一下</li><li><input disabled="" type="checkbox"> com.leggasai.rpc.client.netty.handler.KindredClientChannelHandler#invoke 第一次writeAndFlush方法耗时异常，尝试一下</li><li><input disabled="" type="checkbox"> 序列化预注册支持用户自定义SerializationOptimizer</li><li><input disabled="" type="checkbox"> com.leggasai.rpc.client.proxy.invoke.RpcMethodInvoke#invoke是否应该抛出异常？</li><li><input disabled="" type="checkbox"> 统计中心</li><li><input disabled="" type="checkbox"> 优化一下客户端服务端线程池</li><li><input disabled="" type="checkbox"> 服务降级和熔断，服务端限流算法</li><li><input disabled="" type="checkbox"> http协议，json&#x2F;gson序列化方式</li><li><input disabled="" type="checkbox"> 日志治理，统一一下框架，添加日志配置。一些调用信息不要输出到控制台</li><li><input checked="" disabled="" type="checkbox"> 测试多提供者，在虚拟机测试完成</li><li><input checked="" disabled="" type="checkbox"> 修复注册中心配置，应该对于提供者和服务者不一样</li><li><input disabled="" type="checkbox"> 重大BUG，先启动发现中心，后启动注册中心，导致首次调用必失败，因为还没注册服务上去。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 微服务和分布式 </category>
          
          <category> Project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Netty</title>
      <link href="/posts/1c6ba3e2/"/>
      <url>/posts/1c6ba3e2/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ol><li><code>Netty</code> 是由 <code>JBOSS</code> 提供的一个 <code>Java</code> 开源框架，现为 <code>Github</code> 上的独立项目。</li><li><code>Netty</code> 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 <code>IO</code> 程序。</li><li><code>Netty</code> 主要针对在 <code>TCP</code> 协议下，面向 <code>Client</code> 端的高并发应用，或者 <code>Peer-to-Peer</code> 场景下的大量数据持续传输的应用。</li><li><code>Netty</code> 本质是一个 <code>NIO</code> 框架，适用于服务器通讯相关的多种应用场景。</li></ol><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p><strong>Socket</strong><br>Socket（套接字）是通信的基石，是支持TCP&#x2F;IP协议的路通信的基本操作单元。可以将套接字看作不同主机间的进程进行双间通信的端点，它构成了单个主机内及整个网络间的编程界面。<br>Socket 相当于是应用程序的大门，我们在网络中发送的报文都会经过这道大门才能够进入到应用程序中，让应用程序来使用报文中的数据。</p><blockquote><p>要写网络程序就必须用Socket</p></blockquote><p>群聊NIO案例</p><p>零拷贝大文件案例</p><p>实现简易RPC</p><p>客户端：</p><ul><li>服务发现，注册服务，监听服务更新</li><li>负载均衡算法，随机哈希、轮询、LFU、LRU、LRT（最小响应时间）</li><li>服务代理</li><li>Netty客户端实现</li></ul><p>服务端：</p><ul><li>服务注册</li><li>Netty服务端实现</li></ul><p>共同</p><ul><li>协议 + 序列化方式</li><li>网络通信框架Netty</li><li>注册中心，服务发现 zk</li><li>心跳机制，超时断开连接</li></ul><p>服务注册：<br>需要注册什么信息？多个服务提供者如何组织数据结构？</p><ul><li>以服务为节点？以服务提供者为节点？</li><li>信息可能需要包含服务提供者的ip，port，服务元信息（服务类名，版本号）</li><li>提供者掉线了，需要从注册中心中删除，心跳机制</li><li></li></ul><p>协议：</p><ul><li>头部（最好固定多少字节）<ul><li>请求ID，用来唯一标识一次RPC，64bits&#x3D;8字节</li><li>Request&#x2F;Response  </li><li>State 状态</li><li>body部分序列化方式</li><li>body长度 4字节</li></ul></li><li>body部分（这部分长度&#x3D;上述body长度）<ul><li>服务名</li><li>服务版本</li><li>方法名</li><li>方法参数类型列表</li><li>方法参数列表</li><li>拓展？可以是一个map结构</li><li><hr></li><li>返回error</li><li>返回类型，这个感觉可以不用，因为client知道返回类型应该是啥。</li><li>返回结果</li></ul></li></ul><p>参考资料：<br><a href="https://dongzl.github.io/netty-handbook/#/">Netty 学习手册 (dongzl.github.io)</a></p><p><a href="https://github.com/Snailclimb/guide-rpc-framework">Snailclimb&#x2F;guide-rpc-framework: A custom RPC framework implemented by Netty+Kyro+Zookeeper.（一款基于 Netty+Kyro+Zookeeper 实现的自定义 RPC 框架-附详细实现过程和相关教程。） (github.com)</a></p><p><a href="https://github.com/luxiaoxun/NettyRpc">luxiaoxun&#x2F;NettyRpc: A simple RPC framework based on Netty, ZooKeeper and Spring (github.com)</a></p><p><a href="https://github.com/tang-jie/NettyRPC">tang-jie&#x2F;NettyRPC: NettyRPC is high performance java rpc server base on Netty,using kryo,hessian,protostuff support message serialization. (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP</title>
      <link href="/posts/a0419e9f/"/>
      <url>/posts/a0419e9f/</url>
      
        <content type="html"><![CDATA[<p>课程官网：<a href="https://csapp.cs.cmu.edu/">CS:APP3e, Bryant and O’Hallaron (cmu.edu)</a></p><p>参考博客：<br><a href="https://fengmuzi2003.gitbook.io/csapp3e/">https://fengmuzi2003.gitbook.io/csapp3e/</a></p><p>中文翻译：<br><a href="https://www.bilibili.com/video/BV1j34y1U7oy">https://www.bilibili.com/video/BV1j34y1U7oy</a></p><p>中文视频：<br><a href="https://space.bilibili.com/354767108">九曲阑干的个人空间-九曲阑干个人主页-哔哩哔哩视频 (bilibili.com)</a></p><p>电子书：<a href="https://hansimov.gitbook.io/csapp">本电子书信息 | 深入理解计算机系统（CSAPP） (gitbook.io)</a></p><p>学习方式：看书是重点，作业一定要做。视频辅助理解</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/posts/364ea8cc/"/>
      <url>/posts/364ea8cc/</url>
      
        <content type="html"><![CDATA[<h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h1 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://refactoringguru.cn/design-patterns/strategy">策略设计模式 (refactoringguru.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="/posts/cdcc4eae/"/>
      <url>/posts/cdcc4eae/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。在分布式系统中，可能涉及到多个参与者，每个参与者负责管理自己的本地数据。分布式事务的目标是确保在整个分布式环境中，所有相关的操作要么全部成功，要么全部失败，以保持数据的一致性。（All or nothing）</p><p><img src="/../../../img/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%9B%BE%20(7).png"></p><h1 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h1><h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p><strong>CAP</strong>是 <strong>Consistency</strong>、<strong>Availability</strong>、<strong>Partition tolerance</strong>三个词语的缩写，分别表示一致性、可用性、分区容忍性。</p><ul><li><strong>一致性(Consistency) <strong>：更新操作成功并返回客户端完成后，</strong>所有节点</strong>在<strong>同一时间</strong>的数据<strong>完全一致</strong>，不能存在中间状态。（这里指<strong>强一致性</strong>）</li><li><strong>可用性(Availability)</strong> ： 系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在<strong>有限时间</strong>内<strong>返回结果</strong>。</li><li>**分区容错性(Partition tolerance) **：分布式系统在遇到任何网络分区故障时，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</li></ul><blockquote><p>任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。在互联网领域的绝大多数的场景中，都需要<strong>牺牲强一致性来换取系统的高可用性</strong>，系统往往只需要保证最终一致性。</p></blockquote><p>CAP理论权衡<br>由于C、A、P无法同时满足，必须有所舍弃。但如果放弃P（分区容错性），也就放弃了分布式。因此目前常见的分布式系统基于CAP分类主要有：AP和CP两类。<a href="https://zhuanlan.zhihu.com/p/338835258">CAP理论该怎么理解？为什么是三选二？为什么是CP或者AP？面试题有哪些？ - 知乎 (zhihu.com)</a></p><h2 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h2><blockquote><p>CAP是分布式系统设计理论，BASE是CAP理论中AP方案的延伸，对于C我们采用的方式和策略就是保证最终一致性；</p></blockquote><p><strong>BASE</strong>是<strong>B</strong>asically <strong>A</strong>vailable（基本可用）、<strong>S</strong>oft state（软状态）和<strong>E</strong>ventually consistent（最终一致性）三个短语的缩写。BASE基于CAP定理演化而来，核心思想是即时无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p><ul><li>BA（基本可用）：分布式系统在出现不可预知的故障的时候，允许损失部分可用性，但不等于系统不可用。体现在（1）响应时间延长 （2）服务降级</li><li>S（软状态）：允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性。允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。、</li><li>E（最终一致性）：系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。</li></ul><p>BASE理论是提出通过牺牲一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。</p><h1 id="分布式事务分类"><a href="#分布式事务分类" class="headerlink" title="分布式事务分类"></a>分布式事务分类</h1><p>分布式事务实现方案从类型上去分刚性事务、刚性事务</p><h2 id="刚性事务"><a href="#刚性事务" class="headerlink" title="刚性事务"></a>刚性事务</h2><p>定义：无业务改造，强一致性，原生支持回滚&#x2F;隔离性，低并发，适合短事务。<br>原则：遵循CAP理论的CP原则。保证强一致性<br>实现方式：XA 协议（2PC、JTA、JTS）、3PC，但由于同步阻塞，处理效率低，不适合大型网站分布式场景。</p><h2 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h2><p>定义：有业务改造，最终一致性，实现补偿接口，实现资源锁定接口，高并发，适合长事务。<br>原则：遵循Base理论（AP原则），允许中间状态，保证最终一致性。<br>实现方式：TCC&#x2F;FMT、Saga（状态机模式、Aop模式）、本地事务消息、消息事务（半消息）</p><h1 id="刚性事务解决方案"><a href="#刚性事务解决方案" class="headerlink" title="刚性事务解决方案"></a>刚性事务解决方案</h1><h2 id="X-Open-DTP模型"><a href="#X-Open-DTP模型" class="headerlink" title="X&#x2F;Open DTP模型"></a>X&#x2F;Open DTP模型</h2><p>X&#x2F;Open <strong>DTP(Distributed Transaction Process)</strong> 是一个分布式事务模型。这个模型主要使用了两段提交(2PC - Two-Phase-Commit)来保证分布式事务的完整性。</p><p>三大组件：<br>AP：Application，即应用程序。属于业务层，规定了事务所涉及的操作。<br>TM：Transaction Manager，事务管理器。是事务调度模型的核心部分，负责协调和管理事务，提供AP事务接口、管理RM事务提交。<br>RM：Resource Manager，资源管理器。如数据库，消息队列，文件系统等。<br><img src="/../../../img/Pasted%20image%2020240223190711.png"></p><p>事务执行流程：<br><img src="/../../../img/Pasted%20image%2020240223190843.png"></p><h2 id="XA协议"><a href="#XA协议" class="headerlink" title="XA协议"></a>XA协议</h2><p>在 X&#x2F;Open DTP分布式事务模型中，TM 和 多个 RM 的事务控制，都是<strong>基于 XA 协议来完成</strong>的。XA 协议也是 X&#x2F;Open 提出的分布式事务处理规范（基于2PC），也是分布式事务处理的工业标准，它定义了一组标准的函数接口，称为 <strong>xa 函数</strong>，用于管理和控制分布式事务的执行。</p><p>目前，主流数据库都实现了 XA 接口，如 MySQL、Oracle、DB2、PGSQL等，它们都可以作为RM。</p><p>常见的xa函数：<br>xa_open&#x2F;xa_close：建立和关闭与资源管理器的连接。<br>xa_start：启动一个xa事务。示例(mysql)：xa start xid ，xid必须全局唯一<br>xa_end：结束一个xa事务。示例(mysql)：xa end xid<br>xa_perpare：准备。示例(mysql)：xa perpare xid<br>xa_commit：提交xa事务。示例(mysql)：xa commit xid<br>xa_rollback：回滚xa事务。示例(mysql)：xa rollback xid</p><p>XA各个阶段的处理流程<br><img src="/../../../img/Pasted%20image%2020240223191207.png"></p><h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p>2PC即Two-Phase Commit，二阶段提交。（标准的XA规范）</p><p>一阶段（Prepare）：TM向各RM发送事务内容，RM执行事务（写入undo&#x2F;redo日志），但不提交。并向TM发送响应（成功或失败）。<br>二阶段（Commit）：TM根据各RM返回的结果，决定是否最终执行事务提价或回滚，并广播给RM执行Commit&#x2F;Rollback。然后各RM向TM返回响应结果（成功或失败）。注意这里RM如超时未收到TM的请求，则默认执行<strong>回滚</strong>操作。<br><img src="/../../../img/Pasted%20image%2020240223194517.png"></p><p>优点：</p><ul><li>实现简单</li></ul><p>缺点：</p><ul><li>同步阻塞，所有参与的RM都是事务阻塞，并且是锁定资源的，意味着不能进行其他操作；同时各个参与者还必须等待其他参与者完成响应。</li><li>单点故障：由于TM是单点的，如果出现故障，所有RM都无法完成事务操作（第二阶段不能提交或回滚）</li><li>数据不一致：在第二阶段TM发送Commit的时候，如果发送网络波动或TM崩溃，导致部分RM没有接收到请求，那么整个系统会出现数据不一致问题。</li><li>缺少快速失败机制：在第一阶段，如果参与者出现故障，TM只能等待超时机制来得知。（3PC进行改进）</li></ul><h2 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h2><p>针对2PC的缺点，提出了3PC。在2PC的基础上添加了CanCommit阶段。</p><p>一阶段（CanCommit）：TM询问RM是否可以提交事务，RM此时只检查是否因为部分因素导致事务无法成功提交，并加入了超时机制。RM返回响应（如果某个RM不能正常提交，后面就不执行了，相当于预检机制）<br>二阶段（PreCommit）：当所有RM返回YES时，TM向各RM发送事务内容，RM执行事务（写入undo&#x2F;redo日志），但不提交。<br>三阶段（DoCommit）：TM 根据 RM 在 PreCommit 阶段的响应，决定是否执行最终提交操作。如果所有 RM 都响应 PreCommit 成功，TM 发送 DoCommit 请求给所有 RM 执行 提交操作。否则，如果有任何一个 RM 响应 PreCommit 失败或超时，TM 发送 DoAbort 请求给所有 RM 执行回滚操作。注意这里RM如超时未收到TM的请求，则默认执行<strong>提交</strong>操作。</p><p>从上述过程看出，3PC主要添加了预检机制以及修改了超时时的默认行为。改善了单点问题和回滚时的性能。但依旧存在数据不一致、阻塞等问题。</p><h1 id="柔性事务解决方案"><a href="#柔性事务解决方案" class="headerlink" title="柔性事务解决方案"></a>柔性事务解决方案</h1><p>在电商领域等互联网场景下，刚性事务在数据库性能和处理能力上都暴露出了瓶颈。<br>柔性事务有两个特性：基本可用和柔性状态。</p><ul><li>基本可用是指分布式系统出现故障的时候允许损失一部分的可用性。</li><li>柔性状态是指允许系统存在中间状态，这个中间状态不会影响系统整体的可用性，比如数据库读写分离的主从同步延迟等。柔性事务的一致性指的是<strong>最终一致性</strong>。</li></ul><p>柔性事务主要分为<strong>补偿性</strong>和<strong>通知型</strong></p><ul><li>补偿型事务：TCC、SAGA。是同步的</li><li>通知型事务：MQ事务消息、最大努力通知型。是异步的</li></ul><h2 id="异步确保型"><a href="#异步确保型" class="headerlink" title="异步确保型"></a>异步确保型</h2><p>指将一系列同步的事务操作修改为基于消息队列异步执行的操作，来避免分布式事务中同步阻塞带来的数据操作性能的下降。</p><h3 id="MQ事务消息方案"><a href="#MQ事务消息方案" class="headerlink" title="MQ事务消息方案"></a>MQ事务消息方案</h3><p>基于MQ的事务消息方案主要依靠MQ的<strong>半消息机制</strong>来实现投递消息和参与者自身本地事务的一致性保障。半消息机制实现原理其实借鉴的2PC的思路，是二阶段提交的广义拓展。</p><p><strong>半消息机制</strong><br>通常包括两个步骤：发送半消息和确认半消息。</p><ol><li><strong>发送半消息（Send Half Message）：</strong><ul><li>发送半消息是指在事务开始时，将消息发送到消息队列，但消息处于未确认的状态。</li><li>在这个阶段，消息队列会持有这个消息，但不会将其投递给订阅者或消费者。</li></ul></li><li><strong>确认半消息（Confirm Half Message）：</strong><ul><li>确认半消息是指在事务执行成功时，发送确认请求给消息队列，让消息队列将消息标记为可投递状态。</li><li>如果事务执行失败，发送取消请求给消息队列，让消息队列将消息标记为不可投递状态。</li></ul></li></ol><p><strong>流程：</strong><br><img src="/../../../img/Pasted%20image%2020240223204011.png"></p><ol><li>事务发起方首先发送半消息到MQ；</li><li>MQ通知发送方消息发送成功；</li><li>在发送半消息成功后执行本地事务；</li><li>根据本地事务执行结果返回commit或者是rollback；</li><li>如果消息是rollback, MQ将丢弃该消息不投递；如果是commit，MQ将会消息发送给消息订阅方；</li><li>订阅方根据消息执行本地事务；</li><li>订阅方执行本地事务成功后再从MQ中将该消息标记为已消费；</li><li>如果执行本地事务过程中，执行端挂掉，或者超时，MQ服务器端将不停的询问producer来获取事务状态；</li><li>Consumer端的消费成功机制有MQ保证；</li></ol><p>案例：用户下单后，增加用户账户积分。在这个业务中涉及到两个具有<strong>先后顺序</strong>关系的操作。只有订单服务成功创建订单后，才可以增加积分（保证原子性）</p><ol><li>订单服务创建订单</li><li>订单服务向MQ发送<strong>半消息</strong></li><li>积分服务增加积分<br><img src="/../../../img/Pasted%20image%2020240225224634.png"></li></ol><p>如果积分服务的事务失败，则需要回滚订单服务或重试。<br>如果涉及到更多的服务，比如创建订单，然后扣除库存，最后增加用户积分。则涉及到三类服务，订单服务、库存服务、积分服务。库存服务订阅订单服务，积分服务订阅库存服务。 </p><ol><li>订单服务创建订单</li><li>订单服务向MQ发送半消息</li><li>订单服务本地提交事务，并向MQ确认。</li><li>库存服务收到MQ消息，向MQ发送半消息，并执行扣减库存事务。</li><li>库存服务本地提交事务，并向MQ确认。</li><li>积分服务收到MQ消息，执行增加积分事务。<br>如果某一服务执行失败，可能需要全部回滚或重试。</li></ol><p>RocketMQ实现异步确保型事务</p><blockquote><p>有一些第三方的MQ是支持事务消息的，这些消息队列，支持半消息机制，比如RocketMQ，ActiveMQ。但是有一些常用的MQ也不支持事务消息，比如 RabbitMQ 和 Kafka 都不支持。</p></blockquote><p>以阿里的 RocketMQ 中间件为例，其思路大致为：</p><ol><li>producer(本例中指A系统)发送半消息到broker，这个半消息不是说消息内容不完整， 它包含完整的消息内容， 在producer端和普通消息的发送逻辑一致</li><li>broker存储半消息，半消息存储逻辑与普通消息一致，只是属性有所不同，topic是固定的RMQ_SYS_TRANS_HALF_TOPIC，queueId也是固定为0，这个tiopic中的消息对消费者是不可见的，所以里面的消息永远不会被消费。这就保证了在半消息提交成功之前，消费者是消费不到这个半消息的</li><li>broker端半消息存储成功并返回后，A系统执行本地事务，并根据本地事务的执行结果来决定半消息的提交状态为提交或者回滚</li><li>A系统发送结束半消息的请求，并带上提交状态(提交 or 回滚)</li><li>broker端收到请求后，首先从RMQ_SYS_TRANS_HALF_TOPIC的queue中查出该消息，设置为完成状态。如果消息状态为提交，则把半消息从RMQ_SYS_TRANS_HALF_TOPIC队列中复制到这个消息原始topic的queue中去(之后这条消息就能被正常消费了)；如果消息状态为回滚，则什么也不做。</li><li>producer发送的半消息结束请求是 oneway 的，也就是发送后就不管了，只靠这个是无法保证半消息一定被提交的，rocketMq提供了一个兜底方案，这个方案叫消息反查机制，Broker启动时，会启动一个TransactionalMessageCheckService 任务，该任务会定时从半消息队列中读出所有超时未完成的半消息，针对每条未完成的消息，Broker会给对应的Producer发送一个消息反查请求，根据反查结果来决定这个半消息是需要提交还是回滚，或者后面继续来反查</li><li>consumer(本例中指B系统)消费消息，执行本地数据变更(至于B是否能消费成功，消费失败是否重试，这属于正常消息消费需要考虑的问题)</li></ol><p><img src="/../../../img/Pasted%20image%2020240225225653.png"><br><img src="/../../../img/Pasted%20image%2020240225225736.png"></p><h3 id="本地消息表方案"><a href="#本地消息表方案" class="headerlink" title="本地消息表方案"></a>本地消息表方案</h3><p>有时候我们目前的MQ组件并不支持事务消息，或者我们想尽量少的侵入业务方。这时我们需要另外一种方案“基于DB本地消息表“。</p><p>本地消息表最初由eBay 提出来解决分布式事务的问题。是目前业界使用的比较多的方案之一，它的核心思想就是将分布式事务<strong>拆分</strong>成本地事务进行处理。</p><p><img src="/../../../img/Pasted%20image%2020240225230224.png"><br>消息发送方：</p><ul><li>需要有一个消息表，记录着消息状态相关信息。</li><li>业务数据和消息表在同一个数据库，要保证它俩在同一个本地事务。直接利用本地事务，将业务数据和事务消息直接写入数据库。</li><li>在本地事务中处理完业务数据和写消息表操作后，通过写消息到 MQ 消息队列。使用专门的投递工作线程进行事务消息投递到MQ，根据投递ACK去删除事务消息表记录</li><li>消息会发到消息消费方，如果发送失败，即进行重试。</li></ul><p>消息消费方：</p><ul><li>处理消息队列中的消息，完成自己的业务逻辑。</li><li>如果本地事务处理成功，则表明已经处理成功了，修改发送方消息表消息状态。</li><li>如果本地事务处理失败，那么就会重试执行。</li><li>如果是业务层面的失败，给消息生产方发送一个业务补偿消息，通知进行回滚等操作。</li></ul><p>生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。</p><p><strong>优缺点：</strong><br>优点：</p><ul><li>本地消息表建设成本比较低，实现了可靠消息的传递确保了分布式事务的最终一致性。<br>无需提供回查方法，进一步减少的业务的侵入。</li><li>在某些场景下，还可以进一步利用注解等形式进行解耦，有可能实现无业务代码侵入式的实现。<br>缺点：</li><li>本地消息表与业务耦合在一起，难于做成通用性，不可独立伸缩。</li><li>本地消息表是基于数据库来做的，而数据库是要读写磁盘IO的，因此在高并发下是有性能瓶颈的</li></ul><h3 id="MQ事务消息-VS-本地消息表"><a href="#MQ事务消息-VS-本地消息表" class="headerlink" title="MQ事务消息 VS 本地消息表"></a>MQ事务消息 VS 本地消息表</h3><p>相同点：</p><ul><li>事务消息都依赖于消息队列MQ，因此都是异步的（回调机制实现）。</li><li>都存在重复投递的可能，需要去重机制或幂等设计。</li><li>都需要实现业务补偿逻辑</li></ul><p>不同点：</p><ul><li>MQ事务消息需要MQ的半消息特性支持，而本地消息表使用数据库记录消息状态</li><li>MQ事务具有比较大的业务侵入性，需要业务方进行改造，提供对应的本地操作成功的回查功能</li><li>MQ事务效率高，但具有业务耦合性。本地事务表的消息表也具有耦合性。</li></ul><h2 id="最大努力通知型"><a href="#最大努力通知型" class="headerlink" title="最大努力通知型"></a>最大努力通知型</h2><p>最大努力通知方案的目标，就是发起通知方通过一定的机制，最大努力将业务处理结果通知到接收方。一般使用<strong>衰减重试机制</strong>达到事务的最终一致性。</p><p><strong>最大努力通知事务</strong>主要用于<strong>外部系统</strong>，因为外部的网络环境更加复杂和不可信，所以只能尽最大努力去通知实现数据最终一致性，<strong>比如充值平台与运营商、支付对接、商户通知等等跨平台、跨企业的系统间业务交互场景</strong>；</p><p>而<strong>异步确保型事务</strong>主要适用于<strong>内部系统</strong>的数据最终一致性保障，因为内部相对比较可控，比如订单和购物车、收货与清算、支付与结算等等场景。</p><h3 id="MQ事务消息方案-1"><a href="#MQ事务消息方案-1" class="headerlink" title="MQ事务消息方案"></a>MQ事务消息方案</h3><p>要实现最大努力通知，可以采用 MQ 的 ACK 机制。</p><p>最大努力通知事务在投递之前，跟异步确保型流程都差不多，关键在于投递后的处理。因为异步确保型在于内部的事务处理，所以MQ和系统是直连并且无需严格的权限、安全等方面的思路设计。最大努力通知事务在于第三方系统的对接，所以最大努力通知事务有几个特性：</p><ul><li>业务主动方在完成业务处理后，向业务被动方(第三方系统)发送通知消息，允许存在消息丢失。</li><li>业务主动方提供递增多挡位时间间隔(5min、10min、30min、1h、24h)，用于失败重试调用业务被动方的接口；在通知N次之后就不再通知，报警+记日志+人工介入。</li><li>业务被动方提供幂等的服务接口，防止通知重复消费。</li><li>业务主动方需要有定期校验机制，对业务数据进行兜底；防止业务被动方无法履行责任时进行业务回滚，确保数据最终一致性。</li><li><strong>消息校对机制</strong>：在重复通知仍然没有通知到对方，可由接收通知方主动查询信息。</li></ul><p><img src="/../../../img/Pasted%20image%2020240226230339.png"></p><ol><li>业务活动的主动方，在完成业务处理之后，向业务活动的被动方发送消息，允许消息丢失。</li><li>主动方可以设置时间阶梯型通知规则，在通知失败后按规则重复通知，直到通知N次后不再通知。</li><li>主动方提供校对查询接口给被动方按需校对查询，用于恢复丢失的业务消息。</li><li>业务活动的被动方如果正常接收了数据，就正常返回响应，并结束事务。</li><li>如果被动方没有正常接收，根据定时策略，向业务活动<strong>主动方查询</strong>，恢复丢失的业务消息。</li></ol><p>场景：充值业务</p><ol><li>账户系统调用充值系统接口</li><li>充值系统完成支付处理向账户系统发起充值结果通知<br>若通知失败，则充值系统按策略进行重复通知</li><li>账户系统接收到充值结果通知修改充值状态</li><li>账户系统未接收到通知会主动调用充值系统的接口查询充值结果<br><img src="/../../../img/Pasted%20image%2020240226230346.png"></li></ol><p><strong>特点</strong></p><ol><li>用到的服务模式：可查询操作、幂等操作；</li><li>被动方的处理结果不影响主动方的处理结果；</li><li>适用于对业务最终一致性的时间敏感度低的系统；</li><li>适合跨企业的系统间的操作，或者企业内部比较独立的系统间的操作，比如银行通知、商户通知等；</li></ol><h3 id="本地消息表方案-1"><a href="#本地消息表方案-1" class="headerlink" title="本地消息表方案"></a>本地消息表方案</h3><p>要实现最大努力通知，可以采用定期<strong>检查本地消息表</strong>的机制 。<br><img src="/../../../img/Pasted%20image%2020240226231139.png"></p><p>发送消息方：</p><ul><li>需要有一个消息表，记录着消息状态相关信息。</li><li>业务数据和消息表在同一个数据库，要保证它俩在同一个本地事务。直接利用本地事务，将业务数据和事务消息直接写入数据库。</li><li>在本地事务中处理完业务数据和写消息表操作后，通过写消息到 MQ 消息队列。使用专门的投递工作线程进行事务消息投递到MQ，根据投递ACK去删除事务消息表记录</li><li>消息会发到消息消费方，如果发送失败，即进行重试。</li><li>生产方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。</li></ul><h2 id="最大努力通知事务-VS-异步确保型事务"><a href="#最大努力通知事务-VS-异步确保型事务" class="headerlink" title="最大努力通知事务 VS 异步确保型事务"></a>最大努力通知事务 <strong>VS</strong> 异步确保型事务</h2><p>最大努力通知事务其实是基于异步确保型事务发展而来适用于外部对接的一种业务实现。他们主要有的是业务差别，如下：<br>• 从参与者来说：最大努力通知事务适用于跨平台、跨企业的系统间业务交互；异步确保型事务更适用于同网络体系的内部服务交付。<br>• 从消息层面说：最大努力通知事务需要主动推送并提供多档次时间的重试机制来保证数据的通知；而异步确保型事务只需要消息消费者主动去消费。<br>• 从数据层面说：最大努力通知事务还需额外的定期校验机制对数据进行兜底，保证数据的最终一致性；而异步确保型事务只需保证消息的可靠投递即可，自身无需对数据进行兜底处理。</p><h2 id="隔离性问题"><a href="#隔离性问题" class="headerlink" title="隔离性问题"></a>隔离性问题</h2><p>考虑电商系统中经典的“超售问题”。<br>商品下单一般会涉及两个操作，首先读商品库存，然后扣除库存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin transaction</span><br><span class="line">read(stock)</span><br><span class="line">if stock &gt; 0:</span><br><span class="line">write(stock-1)</span><br><span class="line">commit</span><br></pre></td></tr></table></figure><p>为了确保不出现”超售“，上述事务必须要保障隔离等级为“可重复读”及以上，否则会出现用户A读取库存的时候，用户B下单成功，扣除了库存。这时用户A如果再次读取库存，会发现两次读取的数据不一致（不可重复读），那么用户A在后续扣除库存的时候，可能就会出现”超售“问题（如果用户B买走了最后一件商品的话，此时库存应该为0）。</p><p>由于<strong>异步确保型</strong>和<strong>最大努力通知型</strong>都是异步的，有一定的延迟性，无法提供实时的隔离性保证。</p><h2 id="补偿型"><a href="#补偿型" class="headerlink" title="补偿型"></a>补偿型</h2><p>补偿模式使用一个额外的协调服务来协调各个需要保证一致性的业务服务，协调服务按顺序调用各个业务微服务，如果某个业务服务调用异常（包括业务异常和技术异常）就取消之前所有已经调用成功的业务服务。</p><h3 id="TCC事务"><a href="#TCC事务" class="headerlink" title="TCC事务"></a>TCC事务</h3><p>TCC 是另一种常见的分布式事务机制，它是“Try-Confirm-Cancel”三个单词的缩写，是由数据库专家 Pat Helland 在 2007 年撰写的论文《<a href="https://www-db.cs.wisc.edu/cidr/cidr2007/papers/cidr07p15.pdf">Life beyond Distributed Transactions: An Apostate’s Opinion (opens new window)</a>》中提出。</p><p>TCC 分布式事务模型包括三部分：</p><ol><li><p>主业务服务：主业务服务为整个业务活动的发起方，服务的编排者，负责发起并完成整个业务活动。</p></li><li><p>从业务服务：从业务服务是整个业务活动的参与方，负责提供 TCC 业务操作，实现初步操作(Try)、确认操作(Confirm)、取消操作(Cancel)三个接口，供主业务服务调用。<br><img src="/../../../img/Pasted%20image%2020240227224352.png"></p></li><li><p>业务活动管理器：业务活动管理器管理控制整个业务活动，包括记录维护 TCC 全局事务的事务状态和每个从业务服务的子事务状态，并在业务活动提交时调用所有从业务服务的 Confirm 操作，在业务活动取消时调用所有从业务服务的 Cancel 操作。</p></li></ol><ul><li><strong>Try</strong>：尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好全部需用到的业务资源（保障隔离性）。</li><li><strong>Confirm</strong>：确认执行阶段，真正执行的业务逻辑，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。Try成功，Confirm一定成功。Confirm 阶段可能会重复执行，因此本阶段所执行的操作需要具备<strong>幂等性</strong>。</li><li><strong>Cancel</strong>：取消执行阶段，释放 Try 阶段预留的业务资源。Cancel 阶段可能会重复执行，也需要满足幂等性。</li></ul><p><strong>Confirm 或 Cancel 阶段</strong>： 两者是互斥的，只能进入其中一个，并且都满足幂等性，允许失败重试。<br><img src="/../../../img/Pasted%20image%2020240227224529.png"></p><p><strong>TCC事务模型的要求</strong>：</p><ul><li>可查询操作：服务操作具有全局唯一的标识，操作唯一的确定的时间。</li><li>幂等操作：重复调用多次产生的业务结果与调用一次产生的结果相同。一是通过业务操作实现幂等性，二是系统缓存所有请求与处理的结果，最后是检测到重复请求之后，自动返回之前的处理结果。</li><li>TCC操作：Try阶段，尝试执行业务，完成所有业务的检查，实现一致性；预留必须的业务资源，实现准隔离性。Confirm阶段：真正的去执行业务，不做任何检查，仅适用Try阶段预留的业务资源，Confirm操作还要满足幂等性。Cancel阶段：取消执行业务，释放Try阶段预留的业务资源，Cancel操作要满足幂等性。TCC与2PC(两阶段提交)协议的区别：TCC位于业务服务层而不是资源层，TCC没有单独准备阶段，Try操作兼备资源操作与准备的能力，TCC中Try操作可以灵活的选择业务资源，锁定粒度。TCC的开发成本比2PC高。实际上TCC也属于两阶段操作，但是TCC不等同于2PC操作。</li><li>可补偿操作：Do阶段：真正的执行业务处理，业务处理结果外部可见。Compensate阶段：抵消或者部分撤销正向业务操作的业务结果，补偿操作满足幂等性。约束：补偿操作在业务上可行，由于业务执行结果未隔离或者补偿不完整带来的风险与成本可控。实际上，TCC的Confirm和Cancel操作可以看做是补偿操作。</li></ul><h4 id="TCC事务模型-VS-DTP事务模型"><a href="#TCC事务模型-VS-DTP事务模型" class="headerlink" title="TCC事务模型 VS DTP事务模型"></a><strong>TCC事务模型 VS DTP事务模型</strong></h4><p><img src="/../../../img/Pasted%20image%2020240227225110.png"></p><p>相似点：</p><ul><li>TCC事务的<strong>主业务服务</strong>相当于DTP模型中的<strong>AP</strong>；TCC事务的<strong>从业务服务</strong>相当于 DTP模型中的<strong>RM</strong><ul><li>在DTP模型中，应用AP操作多个资源管理器RM上的资源；而在TCC模型中，是主业务服务操作多个从业务服务上的资源。例如航班预定案例中，美团App就是主业务服务，而川航和东航就是从业务服务，主业务服务需要使用从业务服务上的机票资源。不同的是DTP模型中的资源提供者是类似于Mysql这种关系型数据库，而TCC模型中资源的提供者是其他业务服务。</li></ul></li><li>TCC中<strong>从业务服务</strong>的<code>Try</code>、<code>Confirm</code>、<code>Cancel</code>与DTP模型中<strong>RM</strong>提供的<code>Prepare</code>、<code>Commit</code>、<code>Rollback</code>接口类似。</li><li>事务管理器<ul><li>在DTP模型中，阶段1的(prepare)和阶段2的(commit、rollback)，都是由TM进行调用的。</li><li>TCC中阶段1的try接口是主业务服务调用(绿色箭头)，阶段2的(confirm、cancel接口)是事务管理器TM调用(红色箭头)。这就是 TCC 分布式事务模型的二阶段异步化功能，从业务服务的第一阶段执行成功，主业务服务就可以提交完成，然后再由事务管理器框架异步的执行各从业务服务的第二阶段。这里牺牲了一定的隔离性和一致性的，但是提高了长事务的可用性。</li></ul></li></ul><h4 id="TCC事务模型-VS-2PC"><a href="#TCC事务模型-VS-2PC" class="headerlink" title="TCC事务模型 VS 2PC"></a><strong>TCC事务模型 VS 2PC</strong></h4><p><img src="/../../../img/Pasted%20image%2020240227225607.png"></p><p>阶段1：</p><ul><li>在XA中，各个RM准备提交各自的事务分支，事实上就是准备提交资源的更新操作(insert、delete、update等)；执行事务（写入undo&#x2F;redo log)，但不提交。</li><li>在TCC中，是主业务活动请求(try)各个从业务服务<strong>预留</strong>资源。</li></ul><p>阶段2：</p><ul><li>XA根据第一阶段每个RM是否都prepare成功，判断是要提交还是回滚。如果都prepare成功，那么就commit每个事务分支，反之则rollback每个事务分支。</li><li>TCC中，如果在第一阶段所有业务资源都预留成功，那么confirm各个从业务服务，否则取消(cancel)所有从业务服务的资源预留请求。</li></ul><p><strong>TCC和2PC不同点</strong></p><ul><li>XA是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁。基于数据库锁实现，需要数据库支持XA协议，由于在执行事务的全程都需要对相关数据加锁，一般高并发性能会比较差</li><li>TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁，性能较好。但是对微服务的侵入性强，微服务的每个事务都必须实现try、confirm、cancel等3个方法，开发成本高，今后维护改造的成本也高为了达到事务的一致性要求，try、confirm、cancel接口必须实现幂等性操作由于事务管理器要记录事务日志，必定会损耗一定的性能，并使得整个TCC事务时间拉长</li><li>2PC的撤销是通过<strong>回滚事务</strong>实现，而TCC的撤销是基于<strong>补偿性事务</strong>，而不是简单的回滚。补偿是一个独立的支持ACID特性的本地事务，用于在逻辑上取消服务提供者上一个ACID事务造成的<strong>影响</strong>，对于一个长事务(long-running transaction)，与其实现一个巨大的分布式ACID事务，不如使用基于补偿性的方案，把每一次服务调用当做一个较短的本地ACID事务来处理，执行完就立即提交</li></ul><blockquote><p>TCC的最终一致性要求弱化了对资源的锁定条件，进而提高了分布式下的并发性能</p></blockquote><h4 id="使用场景案例"><a href="#使用场景案例" class="headerlink" title="使用场景案例"></a>使用场景案例</h4><p>TCC是可以解决部分场景下的分布式事务的，但是，它的一个问题在于，需要每个参与者都分别实现Try，Confirm和Cancel接口及逻辑，这对于业务的侵入性是巨大的。</p><p>TCC 方案严重依赖回滚和补偿代码，最终的结果是：回滚代码逻辑复杂，业务代码很难维护。所以，TCC 方案的使用场景较少，但是也有使用的场景。</p><p>比如说跟钱打交道的，支付、交易相关的场景，大家会用 TCC方案，严格保<strong>证分布式事务要么全部成功，要么全部自动回滚</strong>，严格保证资金的正确性，保证在资金上不会出现问题。</p><p>以下是一个网上书店购买书本的案例：<br><img src="/../../../img/Pasted%20image%2020240227230756.png"></p><ol><li>用户向 Fenix’s Bookstore 发送交易请求：购买一本价值 100 元的《深入理解 Java 虚拟机》。</li><li>创建事务，生成事务 ID，记录在活动日志中，进入 Try 阶段：<ul><li>用户服务：检查业务可行性，可行的话，将该用户的 100 元设置为“冻结”状态，通知下一步进入 Confirm 阶段；不可行的话，通知下一步进入 Cancel 阶段。</li><li>仓库服务：检查业务可行性，可行的话，将该仓库的 1 本《深入理解 Java 虚拟机》设置为“冻结”状态，通知下一步进入 Confirm 阶段；不可行的话，通知下一步进入 Cancel 阶段。</li><li>商家服务：检查业务可行性，不需要冻结资源。</li></ul></li><li>如果第 2 步所有业务均反馈业务可行，将活动日志中的状态记录为 Confirm，进入 Confirm 阶段：<ul><li>用户服务：完成业务操作（扣减那被冻结的 100 元）。</li><li>仓库服务：完成业务操作（标记那 1 本冻结的书为出库状态，扣减相应库存）。</li><li>商家服务：完成业务操作（收款 100 元）。</li></ul></li><li>第 3 步如果全部完成，事务宣告正常结束，如果第 3 步中任何一方出现异常，不论是业务异常或者网络异常，都将根据活动日志中的记录，重复执行该服务的 Confirm 操作，即进行最大努力交付。</li><li>如果第 2 步有任意一方反馈业务不可行，或任意一方超时，将活动日志的状态记录为 Cancel，进入 Cancel 阶段：<ul><li>用户服务：取消业务操作（释放被冻结的 100 元）。</li><li>仓库服务：取消业务操作（释放被冻结的 1 本书）。</li><li>商家服务：取消业务操作（大哭一场后安慰商家谋生不易）。</li></ul></li><li>第 5 步如果全部完成，事务宣告以失败回滚结束，如果第 5 步中任何一方出现异常，不论是业务异常或者网络异常，都将根据活动日志中的记录，重复执行该服务的 Cancel 操作，即进行最大努力交付。<br>如果上述重复执行失败，则可以进行告警，人工介入来处理。</li></ol><h3 id="SAGA事务"><a href="#SAGA事务" class="headerlink" title="SAGA事务"></a>SAGA事务</h3><p>SAGA可以看做一个异步的、利用队列实现的补偿事务。</p><p>Saga模型是把一个分布式事务拆分为多个本地事务，每个本地事务都有相应的执行模块和补偿模块（对应TCC中的Confirm和Cancel），当Saga事务中任意一个本地事务出错时，可以通过调用相关的补偿方法恢复之前的事务，达到事务最终一致性。</p><p>这样的SAGA事务模型，是牺牲了一定的隔离性和一致性的，但是提高了long-running事务的可用性。</p><h5 id="Saga事务组成"><a href="#Saga事务组成" class="headerlink" title="Saga事务组成"></a>Saga事务组成</h5><ul><li><strong>LLT</strong>（Long Live Transaction）：由一个个本地事务组成的事务链。</li><li><strong>本地事务</strong>：事务链由一个个子事务（原子事务）组成，$LLT &#x3D; T1+T2+T3+…+Ti$。</li><li><strong>补偿</strong>：每个本地事务 $Ti$有对应的补偿 $Ci$。</li></ul><p><strong>要求</strong></p><ul><li>$Ti$与 $Ci$都具备幂等性。</li><li>$Ti$与 $Ci$满足交换律（Commutative），即先执行 $Ti$还是先执行 $Ci$，其效果都是一样的。</li><li>$Ci$必须能成功提交，即不考虑 $Ci$本身提交失败被回滚的情形，如出现就必须持续重试直至成功，或者要人工介入。</li></ul><p>如果 $T1$到 $Tn$均成功提交，那事务顺利完成，否则，要采取以下两种恢复策略之一：</p><ul><li><p><strong>向后恢复</strong>（Backward Recovery）：撤销掉之前所有成功子事务。如果任意本地子事务失败，则补偿已完成的事务。如异常情况的执行顺序$T1,T2,T3,…Ti,Ci,…C3,C2,C1$。<br><img src="/../../../img/Pasted%20image%2020240228225511.png"></p></li><li><p><strong>向前恢复</strong>（Forward Recovery）：即重试失败的事务（最大努力交付），适用于必须要成功的场景，该情况下不需要执行补偿Ci。执行顺序：$T1,T2,…,Tj（失败）,Tj（重试）,…,Ti$。</p></li></ul><p>显然，向前恢复没有必要提供补偿事务，如果你的业务中，子事务（最终）总会成功，或补偿事务难以定义或不可能，向前恢复更符合你的需求。</p><p><strong>使用限制</strong></p><ul><li>不是所有的事务都能被补偿。补偿事务从语义角度撤消了事务$Ti$的行为，但未必能将数据库返回到执行$Ti$时的状态。</li><li>Saga不提供ACID保证，因为原子性和隔离性不能得到满足。<ul><li>原子性（Atomicity）：正常情况下保证，但不能完全保证。</li><li>一致性（Consistency）：在某个时间点，会出现A库和B库的数据违反一致性要求的情况，但是最终是一致的。</li><li>隔离性（Isolation）：在某个时间点，A事务能够读到B事务部分提交的结果。</li><li>持久性（Durability）：和本地事务一样，只要commit则数据被持久。</li></ul></li></ul><h4 id="SAGA事务解决方案"><a href="#SAGA事务解决方案" class="headerlink" title="SAGA事务解决方案"></a>SAGA事务解决方案</h4><p>考虑业务逻辑如下：</p><ol><li>向DB中插入一条数据</li><li>向MQ中发送一条消息</li></ol><h5 id="方案一：半消息模式"><a href="#方案一：半消息模式" class="headerlink" title="方案一：半消息模式"></a>方案一：半消息模式</h5><p>半消息的完整事务逻辑如下：</p><ol><li>向MQ发送半消息。</li><li>向DB插入数据。</li><li>向MQ发送确认消息。<br><img src="/../../../img/Pasted%20image%2020240228232407.png"><br>这样，即使第二步执行失败，那么MQ中的半消息也无法被消费者消费（相当于执行了补偿）</li></ol><p>为了解决确认消息丢失的问题，MQ引入了一个反查的机制。即MQ会每隔一段时间，对所有的半消息进行扫描，并就扫描到的存在时间过长的半消息，向发送者进行询问，询问如果得到确认回复，则将消息改为确认状态，如得到失败回复，则将消息删除。</p><h5 id="方案二：本地消息表"><a href="#方案二：本地消息表" class="headerlink" title="方案二：本地消息表"></a>方案二：本地消息表</h5><p>在DB中，新增一个消息表，用于存放消息。如下：</p><ol><li>在DB业务表中插入数据。</li><li>在DB消息表中插入数据。</li><li>异步将消息表中的消息发送到MQ，收到ack后，删除消息表中的消息。<br><img src="/../../../img/Pasted%20image%2020240228232604.png"></li></ol><p>如上，通过上述逻辑，将一个分布式的事务，拆分成两大步。第1和第2，构成了一个本地的事务，从而解决了分布式事务的问题。<br>这种解决方案，不需要业务端提供消息查询接口，只需要稍微修改业务逻辑，侵入性是最小的。</p><h4 id="SAGA的案例"><a href="#SAGA的案例" class="headerlink" title="SAGA的案例"></a>SAGA的案例</h4><p>SAGA适用于无需马上返回业务发起方最终状态的场景，例如：你的请求已提交，请稍后查询或留意通知 之类。</p><p>将上述补偿事务的场景用SAGA改写，其流程如下：</p><ol><li>订单服务创建最终状态未知的订单记录，并提交事务T1</li><li>现金服务扣除所需的金额，并提交事务T2</li><li>订单服务更新订单状态为成功，并提交事务T3</li></ol><p>以上为成功的流程，若现金服务扣除金额失败，那么，最后一步订单服务将会更新订单状态为失败（补偿T1）。</p><p>其业务编码工作量比补偿事务多一点，包括以下内容：</p><ul><li>订单服务创建初始订单的逻辑</li><li>订单服务确认订单成功的逻辑</li><li>订单服务确认订单失败的逻辑</li><li>现金服务扣除现金的逻辑</li><li>现金服务补偿返回现金的逻辑</li></ul><p>但其相对于补偿事务形态有性能上的优势，所有的本地子事务执行过程中，都无需等待其调用的子事务执行，减少了加锁的时间，这在事务流程较多较长的业务中性能优势更为明显。同时，其利用队列进行进行通讯，具有削峰填谷的作用。</p><p>因此该形式适用于不需要同步返回发起方执行最终结果、可以进行补偿、对性能要求较高、不介意额外编码的业务场景。</p><p>但当然SAGA也可以进行稍微改造，变成与TCC类似、可以进行资源预留的形态。</p><h2 id="TCC-vs-SAGA"><a href="#TCC-vs-SAGA" class="headerlink" title="TCC vs SAGA"></a>TCC vs SAGA</h2><p>相同点：</p><ul><li>都是补偿性事务</li></ul><p>不同点：</p><ul><li>TCC可以保障隔离性，SAGA无法保障</li><li>SAGA业务侵入小，TCC需要全局改造</li><li>SAGA事件驱动模式，参与者可异步执行，高吞吐；</li></ul><h1 id="总体方案对比"><a href="#总体方案对比" class="headerlink" title="总体方案对比"></a>总体方案对比</h1><table><thead><tr><th>属性</th><th>2PC</th><th>TCC</th><th>Saga</th><th>异步确保型事务</th><th>尽最大努力通知</th></tr></thead><tbody><tr><td>事务一致性</td><td>强</td><td>弱</td><td>弱</td><td>弱</td><td>弱</td></tr><tr><td>复杂性</td><td>中</td><td>高</td><td>中</td><td>低</td><td>低</td></tr><tr><td>业务侵入性</td><td>小</td><td>大</td><td>小</td><td>中</td><td>中</td></tr><tr><td>使用局限性</td><td>大</td><td>大</td><td>中</td><td>小</td><td>中</td></tr><tr><td>性能</td><td>低</td><td>中</td><td>高</td><td>高</td><td>高</td></tr><tr><td>维护成本</td><td>低</td><td>高</td><td>中</td><td>低</td><td>中</td></tr></tbody></table><h1 id="Seata框架"><a href="#Seata框架" class="headerlink" title="Seata框架"></a>Seata框架</h1><p><a href="https://seata.apache.org/zh-cn/docs/user/quickstart/">快速启动 | Apache Seata</a><br>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p><h2 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h2><ul><li>TC ：事务协调者。负责我们的事务ID的生成，事务决议，注册、提交、回滚等。</li><li>TM：事务管理者。定义事务的边界，负责告知 TC，分布式事务的开始，提交，回滚。</li><li>RM：资源管理者。管理每个分支事务的资源，每一个 RM 都会作为一个分支事务注册在 TC。<br><img src="/../../../img/Pasted%20image%2020240302113013.png"></li></ul><h2 id="Seata事务的执行流程"><a href="#Seata事务的执行流程" class="headerlink" title="Seata事务的执行流程"></a><strong>Seata事务的执行流程</strong></h2><ol><li>事务管理者（TM）通过RPC至事务协调者（TC）注册全局事务（Global Transaction）</li><li>将TC生成的<code>XID</code>传递至其TM所调用的任意资源管理者（RM）中</li><li>RM通过其接收到的<code>XID</code>,将其所管理的资源且被该调用锁使用到的资源注册为一个事务分支(Branch Transaction)</li><li>当该请求的调用链全部结束时TM将事务的决议结果（Commit&#x2F;Rollback）通知TC</li><li>TC将协调所有RM进行事务的二阶段动作（回滚&#x2F;提交）</li></ol><h2 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h2><p>AT 模式是 Seata 创新的一种非侵入式的分布式事务解决方案，Seata 在内部做了对数据库操作的代理层，我们使用 Seata AT 模式时，实际上用的是 Seata 自带的数据源代理 DataSourceProxy，Seata 在这层代理中加入了很多逻辑，比如插入回滚 undo_log 日志，检查全局锁等。</p><p>AT模式是改进版的2PC模式，或XA模型。它不会一直锁定资源。</p><ul><li>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。</li><li>二阶段：<ul><li>提交异步化，非常快速地完成。</li><li>回滚通过一阶段的回滚日志进行反向补偿。</li></ul></li></ul><h3 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h3><ul><li>基于支持本地 ACID 事务的关系型数据库。</li><li>Java 应用，通过 JDBC 访问数据库。</li></ul><h3 id="AT模型图"><a href="#AT模型图" class="headerlink" title="AT模型图"></a>AT模型图</h3><p><img src="/../../../img/Pasted%20image%2020240302114518.png"></p><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>有个充值业务，现在有两个服务，一个负责管理用户的余额，另外一个负责管理用户的积分。</p><blockquote><p>当用户充值的时候，首先增加用户账户上的余额，然后增加用户的积分。</p></blockquote><p>Seata AT分为两阶段，主要逻辑全部在第一阶段，第二阶段主要做回滚或日志清理的工作。</p><p>第一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。<br><img src="/../../../img/Pasted%20image%2020240302114851.png"></p><ol><li>余额服务中的TM，向TC申请开启一个全局事务，TC会返回一个全局的事务ID。</li><li>余额服务在执行本地业务之前，RM会先向TC注册分支事务。</li><li>余额服务依次生成undo log、执行本地事务、生成redo log，最后直接提交本地事务。</li><li>余额服务的RM向TC汇报，事务状态是成功的。</li><li>余额服务发起远程调用，把事务ID传给积分服务。</li><li>积分服务在执行本地业务之前，也会先向TC注册分支事务。</li><li>积分服务次生成undo log、执行本地事务、生成redo log，最后直接提交本地事务。</li><li>积分服务的RM向TC汇报，事务状态是成功的。</li><li>积分服务返回远程调用成功给余额服务。</li><li>余额服务的TM向TC申请全局事务的提交&#x2F;回滚。</li></ol><p>第二阶段：异步提交或回滚</p><ul><li>提交：TC通知多个RM异步清理掉本地的redo和undo log</li><li>回滚：TC通知每个RM回滚数据</li></ul><h3 id="读写隔离性"><a href="#读写隔离性" class="headerlink" title="读写隔离性"></a>读写隔离性</h3><p><strong>写隔离</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">分支事务1-开始</span><br><span class="line">| </span><br><span class="line">V 获取 本地锁</span><br><span class="line">| </span><br><span class="line">V 获取 全局锁    分支事务2-开始</span><br><span class="line">|               |</span><br><span class="line">V 释放 本地锁    V 获取 本地锁</span><br><span class="line">|               |</span><br><span class="line">V 释放 全局锁    V 获取 全局锁</span><br><span class="line">            |</span><br><span class="line">                V 释放 本地锁</span><br><span class="line">                |</span><br><span class="line">                V 释放 全局锁</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如上所示，一个分布式事务的锁获取流程是这样的<br>1）先获取到本地锁，这样你已经可以修改本地数据了，只是还不能本地事务提交<br>2）而后，能否提交就是看能否获得全局锁（<strong>拿到全局锁才可以提交</strong>）<br>3）获得了全局锁，意味着可以修改了，那么可以提交本地事务，然后释放本地锁<br>4）当分布式事务全局提交，释放全局锁。这样就可以让其它事务获取全局锁，并提交它们对本地数据的修改了。</p><p><strong>写隔离原则</strong></p><ul><li>一阶段本地事务提交前，需要确保先拿到 <strong>全局锁</strong> 。</li><li>拿不到 <strong>全局锁</strong> ，不能提交本地事务。</li><li>拿 <strong>全局锁</strong> 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。</li></ul><p>以一个示例来说明：</p><blockquote><p>两个全局事务 tx1 和 tx2，分别对 a 表的 m 字段进行更新操作，m 的初始值 1000。</p></blockquote><p>tx1 先开始，开启本地事务，拿到本地锁，更新操作 m &#x3D; 1000 - 100 &#x3D; 900。本地事务提交前，先拿到该记录的 <strong>全局锁</strong> ，本地提交释放本地锁。（在此之前tx2一直在等待本地锁）</p><p>tx2 后开始，开启本地事务，拿到本地锁（tx2可以拿到被tx1修改后的最新数据m&#x3D;900），更新操作 m &#x3D; 900 - 100 &#x3D; 800。本地事务提交前，尝试拿该记录的 <strong>全局锁</strong> ，tx1 全局提交前，该记录的全局锁被 tx1 持有，tx2 需要重试等待 <strong>全局锁</strong> 。</p><p><img src="/../../../img/Pasted%20image%2020240302131351.png"><br>tx1 二阶段全局提交，释放 <strong>全局锁</strong> 。tx2 拿到 <strong>全局锁</strong> 提交本地事务。</p><p>考虑如果tx1的第二阶段需要全局回滚，则 tx1 需要重新获取该数据的本地锁，进行反向补偿的更新操作，实现分支的回滚。（但此时本地锁被tx2持有，tx2在等待全局锁，tx1在等待本地锁，如果不做处理，就形成了循环等待死锁的局面）。</p><p><img src="/../../../img/Pasted%20image%2020240302131634.png"></p><p>此时，如果 tx2 仍在等待该数据的 <strong>全局锁</strong>，同时持有本地锁，则 tx1 的分支回滚会失败。分支的回滚会一直重试，直到 tx2 的 <strong>全局锁</strong> 等锁超时，放弃 <strong>全局锁</strong> 并回滚本地事务释放本地锁，tx1 的分支回滚最终成功。<br>因为整个过程 <strong>全局锁</strong> 在 tx1 结束前一直是被 tx1 持有的，所以不会发生 <strong>脏写</strong> 的问题。</p><p><strong>读隔离</strong><br>在数据库本地事务隔离级别 <strong>读已提交（Read Committed）</strong> 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 <strong>读未提交（Read Uncommitted）</strong> 。（因为其他事务可能会全局回滚）</p><p>如果应用在特定场景下，必需要求全局的 <strong>读已提交</strong> ，目前 Seata 的方式是通过 <strong>SELECT FOR UPDATE</strong> 语句的代理。<br><img src="/../../../img/Pasted%20image%2020240302132128.png"></p><p>SELECT FOR UPDATE 语句的执行会申请 全局锁 ，如果 全局锁 被其他事务持有，则释放本地锁（回滚 SELECT FOR UPDATE 语句的本地执行）并重试。这个过程中，查询是被 block 住的，直到 全局锁 拿到，即读取的相关数据是 已提交 的，才返回。</p><p>出于总体性能上的考虑，Seata 目前的方案并没有对所有 SELECT 语句都进行代理，仅针对 FOR UPDATE 的 SELECT 语句。</p><h2 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a>TCC模式</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>TCC 与 Seata AT 事务一样都是<strong>两阶段事务</strong>，它与 AT 事务的主要区别为：</p><ul><li><strong>TCC 对业务代码侵入严重</strong><br>  每个阶段的数据操作都要自己进行编码来实现，事务框架无法自动处理。</li><li><strong>TCC 性能更高</strong><br>  不必对数据加<strong>全局锁</strong>，允许多个事务同时操作数据。</li></ul><p>Seata TCC 整体是 <strong>两阶段提交</strong> 的模型。一个分布式的全局事务，全局事务是由若干分支事务组成的，分支事务要满足 <strong>两阶段提交</strong> 的模型要求，即需要每个分支事务都具备自己的：</p><ul><li>一阶段 prepare 行为</li><li>二阶段 commit 或 rollback 行为</li></ul><p><img src="/../../../img/Pasted%20image%2020240302132435.png"></p><p>根据两阶段行为模式的不同，我们将分支事务划分为 <strong>Automatic (Branch) Transaction Mode</strong> 和 <strong>TCC (Branch) Transaction Mode</strong>.</p><p>AT 模式基于 <strong>支持本地 ACID 事务</strong> 的 <strong>关系型数据库</strong>：</p><ul><li>一阶段 prepare 行为：在本地事务中，一并提交业务数据更新和相应回滚日志记录。</li><li>二阶段 commit 行为：马上成功结束，<strong>自动</strong> 异步批量清理回滚日志。</li><li>二阶段 rollback 行为：通过回滚日志，<strong>自动</strong> 生成补偿操作，完成数据回滚。</li></ul><p>相应的，TCC 模式，不依赖于底层数据资源的事务支持：</p><ul><li>一阶段 prepare 行为：调用 <strong>自定义</strong> 的 prepare 逻辑。</li><li>二阶段 commit 行为：调用 <strong>自定义</strong> 的 commit 逻辑。</li><li>二阶段 rollback 行为：调用 <strong>自定义</strong> 的 rollback 逻辑。</li></ul><p>所谓 TCC 模式，是指支持把 <strong>自定义</strong> 的分支事务纳入到全局事务的管理中。</p><p>TCC 的 Try 操作作为一阶段，负责资源的<strong>检查和预留</strong>；Confirm 操作作为二阶段<strong>提交操作</strong>，执行真正的业务；Cancel 是二阶段<strong>回滚操作</strong>，执行预留资源的取消，使资源回到初始状态。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>第一阶段 Try<br>以账户服务为例，当下订单时要扣减用户账户金额：<br><img src="/../../../img/Pasted%20image%2020240302133031.png"></p><p>假如用户购买 100 元商品，要扣减 100 元。<br>TCC 事务首先对这100元的扣减金额进行<strong>预留</strong>，或者说是先冻结这100元（如果账户没有100元，该分支事务就直接失败了）<br><img src="/../../../img/Pasted%20image%2020240302133125.png"></p><p>第二阶段 Confirm<br>如果第一阶段能够顺利完成，那么说明“扣减金额”业务(分支事务)最终肯定是可以成功的。当全局事务提交时， TC会控制当前分支事务进行提交，如果提交失败，TC 会反复尝试，直到提交成功为止。<br>当全局事务提交时，就可以使用冻结的金额来最终实现业务数据操作：<br><img src="/../../../img/Pasted%20image%2020240302133204.png"></p><p>第二阶段 Cancel<br>如果全局事务回滚，就把冻结的金额进行解冻，恢复到以前的状态，TC 会控制当前分支事务回滚，如果回滚失败，TC 会反复尝试，直到回滚完成为止。<br><img src="/../../../img/Pasted%20image%2020240302133210.png"></p><p>多个事务并发的情况<br>多个TCC全局事务允许并发，它们执行扣减金额时，只需要冻结各自的金额即可：<br><img src="/../../../img/Pasted%20image%2020240302133217.png"></p><h2 id="SAGA模式"><a href="#SAGA模式" class="headerlink" title="SAGA模式"></a>SAGA模式</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>Saga 模式是 SEATA 提供的长事务解决方案，在 Saga 模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者，一阶段<strong>正向服务</strong>和二阶段<strong>补偿服务</strong>都由业务开发实现。<br><img src="/../../../img/Pasted%20image%2020240302134538.png"></p><p>适用场景：</p><ul><li>业务流程长、业务流程多</li><li>参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口</li></ul><p>优势：</p><ul><li>一阶段提交本地事务，无锁，高性能</li><li>事件驱动架构，参与者可异步执行，高吞吐</li><li>补偿服务易于实现</li></ul><p> 缺点：</p><ul><li>不保证隔离性</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>目前 SEATA 提供的 Saga 模式是基于状态机引擎来实现的，机制是：</p><ol><li>通过状态图来定义服务调用的流程并生成 json 状态语言定义文件</li><li>状态图中一个节点可以是调用一个服务，节点可以配置它的补偿节点</li><li>状态图 json 由状态机引擎驱动执行，当出现异常时状态引擎反向执行已成功节点对应的补偿节点将事务回滚<blockquote><p>注意: 异常发生时是否进行补偿也可由用户自定义决定</p></blockquote></li><li>可以实现服务编排需求，支持单项选择、并发、子流程、参数转换、参数映射、服务执行状态判断、异常捕获等功能</li></ol><p><img src="/../../../img/Pasted%20image%2020240302134745.png"></p><h2 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h2><p><strong>使用前提</strong></p><ul><li>支持XA 事务的数据库。</li><li>Java 应用，通过 JDBC 访问数据库。</li></ul><p>在 Seata 定义的分布式事务框架内，利用事务资源（数据库、消息服务等）对<strong>XA 协议</strong>的支持，以 XA 协议的机制来管理分支事务的一种 事务模式。<br><img src="/../../../img/Pasted%20image%2020240302135237.png"></p><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p><strong>整体运行机制</strong><br>XA 模式 运行在 Seata 定义的事务框架内：</p><p><img src="/../../../img/Pasted%20image%2020240302135439.png"></p><ul><li>执行阶段<ul><li>XA start + XA end + XA prepare + SQL + 注册分支</li></ul></li><li>完成阶段<ul><li>XA commit&#x2F;XA rollback</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 微服务和分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程</title>
      <link href="/posts/3e225941/"/>
      <url>/posts/3e225941/</url>
      
        <content type="html"><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p><strong>串行、并行、并发</strong><br>串行：多个程序按序执行。上一个做完，接着做下一个。<br>并行：多个程序同时执行，一般需要多核处理器的支持。<br>并发：多个程序交错执行，就像看上去是同时执行的一样。</p><p><strong>同步异步、阻塞非阻塞</strong><br>同步和异步：当前线程是否需要等待方法调用执行完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步</span></span><br><span class="line">isFinished = doTask();</span><br><span class="line"><span class="comment">// wait for finished </span></span><br><span class="line"><span class="keyword">if</span> isFinished&#123;</span><br><span class="line"><span class="comment">// 任务完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步</span></span><br><span class="line">doTask(&#123;</span><br><span class="line"><span class="comment">// 任务完成</span></span><br><span class="line"><span class="comment">// 执行回调</span></span><br><span class="line">send a message</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在异步调用下的代码逻辑相对而言不太直观，需要借助回调或事件通知，这在复杂逻辑下对编码能力的要求较高。而同步调用就是直来直去，等待执行完毕然后拿到结果紧接着执行下面的逻辑，对编码能力的要求较低，也更不容易出错。<br>所以你会发现有很多方法它是异步调用的方式，但是最终的使用还是异步转同步。<br>比如你向线程池提交一个任务，得到一个<code>future</code>，此时是异步的，然后你在紧接着在代码里调用 <code>future.get()</code>，那就变成等待这个任务执行完成，这就是所谓的异步转同步，像 Dubbo RPC 调用同步得到返回结果就是这样实现的。</p><p>阻塞和非阻塞：当前接口数据还未准备就绪时，线程是否被阻塞挂起。<br>何为阻塞挂起？就是当前线程还处于 CPU 时间片当中，调用了阻塞的方法，由于数据未准备就绪，则时间片还未到就让出 CPU。所以阻塞和同步看起来都是等，但是本质上它们不一样，同步的时候可没有让出 CPU。一旦同步结束，CPU可立马执行接下去的代码。</p><p>而非阻塞就是当前接口数据还未准备就绪时，线程不会被阻塞挂起，可以不断轮询请求接口，看看数据是否已经准备就绪。</p><h2 id="1-2-线程的状态"><a href="#1-2-线程的状态" class="headerlink" title="1.2 线程的状态"></a>1.2 线程的状态</h2><p><img src="/../../../img/Pasted%20image%2020240220120821.png"></p><ul><li>NEW：Thread对象被创建出来了，但是还没有执行start方法。</li><li>RUNNABLE：Thread对象调用了start方法，就为RUNNABLE状态（CPU调度&#x2F;没有调度）</li><li>BLOCKED、WAITING、TIME_WAITING：都可以理解为是阻塞、等待状态，因为处在这三种状态下，CPU不会调度当前线程</li><li>BLOCKED：synchronized没有拿到同步锁，被阻塞的情况</li><li>WAITING：调用wait方法就会处于WAITING状态，需要被手动唤醒（notify或notifyAll）</li><li>TIME_WAITING：调用sleep方法、join方法、wait(long timeout)，会被自动唤醒，无需手动唤醒</li><li>TERMINATED：run方法执行完毕，线程生命周期到头了</li></ul><h1 id="二、线程的创建"><a href="#二、线程的创建" class="headerlink" title="二、线程的创建"></a>二、线程的创建</h1><h2 id="2-1-继承Thread类"><a href="#2-1-继承Thread类" class="headerlink" title="2.1 继承Thread类"></a>2.1 继承Thread类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leggasai.concurrent;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">// thread 1  </span></span><br><span class="line">        <span class="type">MyJob</span> <span class="variable">worker1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyJob</span>();  </span><br><span class="line">        worker1.start();  </span><br><span class="line">        <span class="comment">// thread 2  </span></span><br><span class="line">        <span class="type">MyJob</span> <span class="variable">worker2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyJob</span>();  </span><br><span class="line">        worker2.start();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// error!  </span></span><br><span class="line">        <span class="comment">// 调用run方法只会在当前线程执行执行run方法内部代码  </span></span><br><span class="line">        <span class="comment">// 调用start方法才会新建一个线程，去执行  </span></span><br><span class="line">        <span class="comment">// worker1.run();  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyJob</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">&quot;:&quot;</span>+<span class="string">&quot;I am working!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-实现Runnable"><a href="#2-2-实现Runnable" class="headerlink" title="2.2 实现Runnable"></a>2.2 实现Runnable</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leggasai.concurrent;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRun</span>());  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">&quot;:&quot;</span> + <span class="string">&quot;I am working!&quot;</span>);  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">                System.out.println(Thread.currentThread().getId() + <span class="string">&quot;:&quot;</span> + <span class="string">&quot;I am working!&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        worker1.start();  </span><br><span class="line">        worker2.start();  </span><br><span class="line">        worker3.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRun</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">&quot;:&quot;</span>+<span class="string">&quot;I am working!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-实现Callable"><a href="#2-3-实现Callable" class="headerlink" title="2.3 实现Callable"></a>2.3 实现Callable</h2><p>实现Callable接口，可以创建具有返回值的线程。需要配合<code>FutureTask</code>使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCall</span>());  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);  </span><br><span class="line">        worker1.start();  </span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> (String)futureTask.get();  </span><br><span class="line">        System.out.println(res);  </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCall</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getId()+<span class="string">&quot;:&quot;</span>+<span class="string">&quot;I am working!&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-线程池"><a href="#2-4-线程池" class="headerlink" title="2.4 线程池"></a>2.4 线程池</h2><p>在大型应用中，一般都是使用线程池去并发执行多个任务，因为线程池实际上已经创建好了若干个活跃的线程，省去了创建线程的时间，具有更高的效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">threadPoolDemo</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="comment">// 创建大小为3的线程池  </span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);  </span><br><span class="line">    <span class="comment">// 提交多个任务给线程池执行  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;  </span><br><span class="line">        <span class="type">MyRun</span> <span class="variable">myRun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRun</span>();  </span><br><span class="line">        executorService.execute(myRun);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 关闭线程池  </span></span><br><span class="line">    executorService.shutdown();  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRun</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">&quot;:&quot;</span>+<span class="string">&quot;I am working!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、线程的使用"><a href="#三、线程的使用" class="headerlink" title="三、线程的使用"></a>三、线程的使用</h1><h3 id="3-1-获取线程信息"><a href="#3-1-获取线程信息" class="headerlink" title="3.1 获取线程信息"></a>3.1 获取线程信息</h3><p>获取当前线程<code>Thread.currentThread()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Thread.currentThread());</span><br><span class="line"><span class="comment">// Thread[Thread-0,5,main]</span></span><br></pre></td></tr></table></figure><p>获取线程相关信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(thread.getId());  </span><br><span class="line">System.out.println(thread.getName());  </span><br><span class="line">System.out.println(thread.getState());  </span><br><span class="line">System.out.println(thread.getPriority());  </span><br><span class="line">System.out.println(thread.getUncaughtExceptionHandler());  </span><br><span class="line">System.out.println(thread.getThreadGroup());</span><br><span class="line"></span><br><span class="line"><span class="number">20</span></span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line">RUNNABLE</span><br><span class="line"><span class="number">5</span></span><br><span class="line">java.lang.ThreadGroup[name=main,maxpri=<span class="number">10</span>]</span><br><span class="line">java.lang.ThreadGroup[name=main,maxpri=<span class="number">10</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-设置线程相关信息"><a href="#3-2-设置线程相关信息" class="headerlink" title="3.2 设置线程相关信息"></a>3.2 设置线程相关信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread.setName(<span class="string">&quot;my thread&quot;</span>);  </span><br><span class="line">thread.setPriority(<span class="number">10</span>);  </span><br><span class="line">System.out.println(thread.getName());  </span><br><span class="line">System.out.println(thread.getPriority());</span><br><span class="line"></span><br><span class="line">t1.setDaemon(<span class="literal">true</span>);  </span><br><span class="line">System.out.println(t1.isDaemon());</span><br></pre></td></tr></table></figure><p>线程的优先级：范围1-10。数值越高意味着优先级越高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="number">1</span>);  </span><br><span class="line">    &#125;);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="number">2</span>);  </span><br><span class="line">    &#125;);  </span><br><span class="line">    t1.setPriority(<span class="number">1</span>);  </span><br><span class="line">    t2.setPriority(<span class="number">10</span>);  </span><br><span class="line">    t1.start();  </span><br><span class="line">    t2.start();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本先执行t2,后执行t1</span></span><br></pre></td></tr></table></figure><p>线程让步<code>Thread.yield()</code>：当前线程向处理器表明自己可以让步，放弃CPU使用权让给其他<strong>相同优先级</strong>线程。这并不是一个强制性的指令，而是一个建议，具体实现依赖于底层操作系统的线程调度器。该方法一般很少使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">50</span>)&#123;  </span><br><span class="line">                Thread.<span class="keyword">yield</span>();  </span><br><span class="line">            &#125;  </span><br><span class="line">            System.out.println(<span class="string">&quot;t1:&quot;</span> + i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;t2:&quot;</span> + i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    t2.start();  </span><br><span class="line">    t1.start();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// t1大概率输出到49时，会让t2执行一段时间,比如输出大致如下</span></span><br><span class="line">...</span><br><span class="line">t1:<span class="number">47</span></span><br><span class="line">t1:<span class="number">48</span></span><br><span class="line">t1:<span class="number">49</span></span><br><span class="line">t2:<span class="number">0</span></span><br><span class="line">t2:<span class="number">1</span></span><br><span class="line">t2:<span class="number">2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面这种情况，<code>yield</code>无法生效，因为<code>yield()</code>不会释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;  </span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">50</span>)&#123;  </span><br><span class="line">                    Thread.<span class="keyword">yield</span>();  </span><br><span class="line">                &#125;  </span><br><span class="line">                System.out.println(<span class="string">&quot;t1:&quot;</span> + i);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;t2:&quot;</span> + i);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    t1.start();  </span><br><span class="line">    t2.start();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程休眠<code>Thread.sleep()</code>：使得线程暂停执行一段时间进入时间等待状态，会让出CPU，但不会让出锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    System.out.println(System.currentTimeMillis());  </span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">    System.out.println(System.currentTimeMillis());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程<code>join()</code>方法：使得当前线程等待被调用<code>join()</code>方法的线程执行结束。<br>下面代码中，由于设置<code>t1</code>为守护线程，<code>main</code>线程不会等待<code>t1</code>执行结束才结束，因此会直接结束运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    t1.setDaemon(<span class="literal">true</span>);  </span><br><span class="line">    t1.start();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>t1.join()</code>方法后，<code>main</code>线程会等待<code>t1</code>执行结束后，在继续运行。因此控制台可输出1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">            System.out.println(<span class="number">1</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    t1.setDaemon(<span class="literal">true</span>);  </span><br><span class="line">    t1.start();  </span><br><span class="line">    <span class="comment">// 等待t1执行结束  </span></span><br><span class="line">    t1.join();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>守护线程 vs 非守护线程</p><ul><li>默认情况下，线程都是非守护线程。</li><li>守护线程是一种在程序运行时，在后台提供服务的线程，随着非守护线程的结束而自动退出。</li><li>主线程默认是非守护线程，如果主线程执行结束，需要查看当前JVM内是否还有非守护线程，如果没有JVM直接停止</li><li>可以通过<code>setDaemon和isDaemon</code>来设置守护线程和查看是否是守护线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">            System.out.println(<span class="string">&quot;非守护线程执行结束:&quot;</span>+System.currentTimeMillis());  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    t1.start();  </span><br><span class="line">    System.out.println(<span class="string">&quot;等待非守护线程执行结束:&quot;</span>+System.currentTimeMillis());  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待非守护线程执行结束:1708408152713</span></span><br><span class="line"><span class="comment">//     非守护线程执行结束:1708408153719</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3-线程的等待和唤醒（重点）"><a href="#3-3-线程的等待和唤醒（重点）" class="headerlink" title="3.3 线程的等待和唤醒（重点）"></a>3.3 线程的等待和唤醒（重点）</h3><p><code>wait()/wait(timeout)</code>：使得当前线程释放锁资源，进入等待状态，并加入<strong>等待队列</strong>。<br><code>notify()</code>：唤醒在同一个对象上调用<code>wait()</code>而进入等待队列中的某个线程，进入到<strong>锁队列</strong>。<br><code>notifyAll()</code>：唤醒在同一个对象上调用<code>wait()</code>而进入等待队列中的所有线程，进入到<strong>锁队列</strong>。<br>上述关键词必须在<code>synchronized</code>代码块内或方法体内才能调用，因为他们是基于某个对象锁的。</p><ol><li>线程A调用 <code>wait()</code> 方法，释放对象的锁，进入等待队列。</li><li>线程B执行一些操作，然后调用 <code>notify()</code> 方法，唤醒等待队列中的线程A。</li><li>线程A被唤醒后，它将进入锁队列，等待获取对象的锁。</li><li>当线程B释放对象的锁（例如，退出同步块或同步方法）时，线程A将有机会竞争锁，成功获取锁后继续执行。</li></ol><h3 id="3-4-线程结束"><a href="#3-4-线程结束" class="headerlink" title="3.4 线程结束"></a>3.4 线程结束</h3><p>方法一：<code>stop()</code>方法，但由于<code>stop()</code>方法会产生不可预测行为使得程序进入不一致状态，已被弃用。<br>方法二：自然结束<br>方法三：修改共享变量。务必使用<code>volatile</code>修饰共享变量，如下面的flag。原因见4.2可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">  </span><br><span class="line">    t1.start();  </span><br><span class="line">    Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">    System.out.println(t1.getState());  </span><br><span class="line">    flag = <span class="literal">false</span>;  </span><br><span class="line">    <span class="comment">// be sure the Thread t1 has terminated.  </span></span><br><span class="line">    Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">    System.out.println(t1.getState());  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法四：<code>interrupt()</code>方法（推荐使用）。<br>通过打断WAITING或者TIMED_WAITING状态的线程，从而抛出异常自行处理<br>这种停止线程方式是最常用的一种，在框架和JUC中也是最常见的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;  </span><br><span class="line">            <span class="comment">// 获取任务  </span></span><br><span class="line">            <span class="comment">// 拿到任务，执行任务  </span></span><br><span class="line">            <span class="comment">// 没有任务了，让线程休眠  </span></span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;基于打断形式结束当前线程&quot;</span>);  </span><br><span class="line">                <span class="keyword">return</span>;            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    t1.start();  </span><br><span class="line">    Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">    t1.interrupt();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标记法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;  </span><br><span class="line">            <span class="comment">// 获取任务  </span></span><br><span class="line">            <span class="comment">// 拿到任务，执行任务  </span></span><br><span class="line">            <span class="comment">// 没有任务了，让线程休眠  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程被打断&quot;</span>);  </span><br><span class="line">    &#125;);  </span><br><span class="line">    t1.start();  </span><br><span class="line">    Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">    t1.interrupt();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、并发编程"><a href="#四、并发编程" class="headerlink" title="四、并发编程"></a>四、并发编程</h1><p>三大特性：原子性、可见性、有序性。这三大特性是并发编程中需要特别关注和处理的问题，保证它们的正确性有助于避免并发引起的一系列问题，如竞态条件、死锁、活锁等。</p><h2 id="4-1-原子性"><a href="#4-1-原子性" class="headerlink" title="4.1 原子性"></a>4.1 原子性</h2><p><strong>原子性指一个操作是不可分割的，不可中断的，一个线程在执行时，另一个线程不会影响到他。</strong></p><p>JMM（Java Memory Model）。不同的硬件和不同的操作系统在内存上的操作有一定差异的。Java为了解决相同代码在不同操作系统上出现的各种问题，用JMM屏蔽掉各种硬件和操作系统带来的差异。让Java的并发编程可以做到跨平台。</p><p>JMM规定所有变量都会存储在主内存中，在操作的时候，需要从主内存中复制一份到线程内存（CPU内存），在线程内部做计算。然后再写回主内存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">10</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;  </span><br><span class="line">                increment();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;  </span><br><span class="line">                increment();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">        t1.join();  </span><br><span class="line">        t2.join();  </span><br><span class="line">        System.out.println(count);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序按理应该输出200（两个线程各调用了<code>increment()</code>方法一百次），但实际最终结果往往小于200。其原因在于<code>count++</code>不满足原子性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count++不满足原子性，其可分为三步</span><br><span class="line">(<span class="number">1</span>)从内存读取count的值到CPU寄存器</span><br><span class="line">(<span class="number">2</span>)ADD操作</span><br><span class="line">(<span class="number">3</span>)将寄存器的值再写回内存中</span><br></pre></td></tr></table></figure><p><img src="/../../../img/Pasted%20image%2020240220162403.png"></p><p>考虑多线程并发执行的情况：可能会发生如下情景<br>线程#1在执行<code>count++</code>但是在写回内存之前，有另外一个线程#2也开始执行<code>count++</code>。于是对于线程#2读取到的实际可以被认为<strong>脏值</strong>，因为线程#1还没将更新值写回内存。最后线程#2将<code>count</code>+1后的新值<code>a+1</code>写回内存。明显不符合预期<code>count=a+2</code>。因为丢失了更新。<br><img src="/../../../img/Pasted%20image%2020240220162544.png"></p><p>如果加上<code>synchronized</code>关键词，则同一时间最多只能有一个线程访问<code>increment()</code>方法，这时流程图就变为了如下所示：这时最终值能够符合预期，因为锁的机制，使得<code>count++</code>变为了原子操作。<br><img src="/../../../img/Pasted%20image%2020240220163454.png"></p><p>解决方法二：原子类</p><p>目前Java中提供的原子类大部分底层使用了CAS锁（CompareAndSet自旋锁），如AtomicInteger、AtomicLong等；也有使用了分段锁+CAS锁的原子类，如LongAdder等。</p><p>解决方法三：Lock锁<br>如<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>。详见锁章节</p><p>解决方法四：<code>ThreadLocal类</code><br>这个类提供线程局部变量。这些变量与普通变量的不同之处在于，访问一个变量的每个线程都有自己的、独立初始化的变量副本。</p><p><img src="/../../../img/Pasted%20image%2020240221114630.png"></p><p><code>Thread</code>、<code>ThreadLocalMap</code>、<code>ThreadLocal</code>的关系如上图所示。</p><ul><li>每个<code>Thread</code>实例对象都有其各自的<code>ThreadLocalMap</code>映射，该Map存放了<code>ThreadLocal</code>到<code>Object</code>的映射</li><li>可以创建多个<code>ThreadLocal</code>来为每个线程存储多个线程独立的变量。</li><li>每个<code>Thread</code>的变量是独立的，因为<code>ThreadLocalMap</code>是每个线程独有的。而<code>ThreadLocal</code>只是作为<code>Key</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">ThreadLocal</span> <span class="variable">tl1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">ThreadLocal</span> <span class="variable">tl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">// belong to main thread  </span></span><br><span class="line">        tl1.set(<span class="string">&quot;123&quot;</span>);  </span><br><span class="line">        tl2.set(<span class="string">&quot;456&quot;</span>);  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;t1:&quot;</span> + tl1.get());  </span><br><span class="line">            System.out.println(<span class="string">&quot;t1:&quot;</span> + tl2.get());  </span><br><span class="line">        &#125;);  </span><br><span class="line">        t1.start();  </span><br><span class="line">  </span><br><span class="line">        System.out.println(<span class="string">&quot;main:&quot;</span> + tl1.get());  </span><br><span class="line">        System.out.println(<span class="string">&quot;main:&quot;</span> + tl2.get());  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">main:<span class="number">123</span></span><br><span class="line">main:<span class="number">456</span></span><br><span class="line">t1:<span class="literal">null</span></span><br><span class="line">t1:<span class="literal">null</span></span><br></pre></td></tr></table></figure></li></ul><p><code>ThreadLocal</code>：</p><ul><li><code>set()</code>：在当前线程上绑定一个变量。也就是在当前线程的<code>ThreadLocalMap</code>中添加了一个映射，<code>ThreadLocal</code>-&gt;<code>Object</code></li><li><code>get()</code>：获取此<code>ThreadLocal</code>在当前线程上绑定的值。</li><li><code>remove()</code>：删除此<code>ThreadLocal</code>在当前线程上绑定的值，避免内存泄漏。</li></ul><p><strong>内存泄漏问题</strong><br>内存泄漏：JVM创建的对象永远都无法访问到，但是GC又不能回收对象所占用的内存。<br>Java中的使用引用类型分别是<strong>强，软，弱，虚</strong>。<br>在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个<strong>强引用</strong>。强引用不会被JVM的GC回收。因此是造成内存泄漏的主要原因之一。</p><p>其次是<strong>软引用</strong>，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中，作为缓存使用。</p><p>然后是<strong>弱引用</strong>，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。可以解决内存泄漏问题，ThreadLocal就是基于弱引用解决内存泄漏的问题。</p><p>最后是<strong>虚引用</strong>，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。不过在开发中，我们用的更多的还是强引用。</p><p><code>ThreadLocalMap</code>中的<code>Entry</code>的<code>key</code>被设计成弱引用。<br><img src="/../../../img/Pasted%20image%2020240221125816.png"></p><p>如果当我们不再使用<code>ThreadLocal</code>变量时，依旧有一条强引用路径指向<code>entry</code><br><img src="/../../../img/Pasted%20image%2020240221130514.png">为了解决这个问题，<code>ThreadLocal</code>的作者就把<code>entry</code>中的<code>key</code>设计成弱引用的形式，一旦栈中的<code>ref-threadlocal</code>强引用消失，在下一次GC时就会清除堆中的<code>threadlocal</code>对象。此时，该<code>entry</code>的<code>key</code>值为<code>null</code>。此外，<code>ThreadLocal</code>还有些额外的逻辑清除整个<code>entry</code>的指针。其通过判断<code>entry</code>的<code>key</code>值是否为<code>null</code>来判断该<code>entry</code>是否过时。</p><h2 id="4-2-可见性"><a href="#4-2-可见性" class="headerlink" title="4.2 可见性"></a>4.2 可见性</h2><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即看到这个修改。在多线程环境中，由于线程之间的缓存机制，每个线程的工作内存（CPU三级缓存）都是独立的，会导致每个线程中做修改时，只改自己的工作内存，没有及时的同步到主内存，导致数据不一致问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;  </span><br><span class="line">                <span class="comment">// ....  </span></span><br><span class="line">            &#125;  </span><br><span class="line">            System.out.println(<span class="string">&quot;t1线程结束&quot;</span>);  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        t1.start();  </span><br><span class="line">        Thread.sleep(<span class="number">10</span>);  </span><br><span class="line">        flag = <span class="literal">false</span>;  </span><br><span class="line">        System.out.println(<span class="string">&quot;主线程将flag改为false&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码线程<code>t1</code>永远不会结束，因为它无法观察到<code>flag</code>已被修改。不同线程可能在各自的缓存中保存了相同变量的不同副本。如果一个线程修改了共享变量，其他线程可能不会立即看到这个修改。在上述代码中<code>main</code>线程修改了自己缓冲区中的<code>flag = false</code>，并写回主内存。但<code>t1</code>线程的<code>while(flag)</code>读取的依旧是自己缓冲区中的<code>flag(true)</code>因此无法退出循环。</p><p>解决方法一：(不推荐)在<code>while</code>循环中，使用<strong>某些语句</strong>读取一次<code>flag</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;  </span><br><span class="line">        <span class="comment">// ....  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;flag[t1]:&quot;</span>+flag);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    System.out.println(<span class="string">&quot;t1线程结束&quot;</span>);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这个具体的语句中，由于涉及字符串拼接和 <code>System.out.println</code> 的操作，Java 的虚拟机可能会进行一些特殊处理，例如强制从主内存中读取 <code>flag</code> 的最新值，而不使用线程的本地缓存。因此可以通过重新读取<code>flag</code>的方式刷新缓存。</p><p>解决方法二：使用<code>volatile</code>关键词<br><code>volatile</code>是一个关键字，用来修饰成员变量。<br>如果属性被volatile修饰，相当于会告诉CPU，对当前属性的操作，不允许使用CPU的缓存，必须去和主内存操作。</p><ul><li>volatile属性被写：当写一个volatile变量，JMM会将当前线程对应的CPU缓存及时的刷新到主内存中</li><li>volatile属性被读：当读一个volatile变量，JMM会将对应的CPU缓存中的内存设置为无效，必须去主内存中重新读取共享变量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li></ul><p>解决方法三：使用<code>synchronized</code>。<br>如果涉及到了<code>synchronized</code>的同步代码块或者是同步方法，获取锁资源之后，将内部涉及到的变量从CPU缓存中移除，必须去主内存中重新拿数据，而且在释放锁之后，会立即将CPU缓存中的数据同步到主内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;  </span><br><span class="line">                <span class="keyword">synchronized</span> (TestDemo.class)&#123;&#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            System.out.println(<span class="string">&quot;t1线程结束&quot;</span>);  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        t1.start();  </span><br><span class="line">        Thread.sleep(<span class="number">10</span>);  </span><br><span class="line">        flag = <span class="literal">false</span>;  </span><br><span class="line">        System.out.println(<span class="string">&quot;主线程将flag改为false&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;flag[main]:&quot;</span>+flag);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法四：使用锁<br>Lock锁保证可见性的方式和synchronized完全不同，synchronized基于他的内存语义，在获取锁和释放锁时，对CPU缓存做一个同步到主内存的操作。<br>Lock锁是基于volatile实现的。Lock锁内部再进行加锁和释放锁时，会对一个由volatile修饰的state属性进行加减操作。<br>如果对volatile修饰的属性进行写操作，CPU会执行带有lock前缀的指令，CPU会将修改的数据，从CPU缓存立即同步到主内存，同时也会将其他的属性也立即同步到主内存中。还会将其他CPU缓存行中的这个数据设置为无效，必须重新从主内存中拉取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;  </span><br><span class="line">                lock.lock();  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">  </span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;  </span><br><span class="line">                    lock.unlock();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            System.out.println(<span class="string">&quot;t1线程结束&quot;</span>);  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        t1.start();  </span><br><span class="line">        Thread.sleep(<span class="number">10</span>);  </span><br><span class="line">        flag = <span class="literal">false</span>;  </span><br><span class="line">        System.out.println(<span class="string">&quot;主线程将flag改为false&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;flag[main]:&quot;</span>+flag);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-有序性"><a href="#4-3-有序性" class="headerlink" title="4.3 有序性"></a>4.3 有序性</h2><p>有序性是指程序执行的顺序按照代码的先后顺序执行。在并发编程中，由于编译器的优化、指令重排等原因，程序的执行顺序可能被改变，导致程序的实际执行顺序与代码的顺序不一致。</p><p>一个指令重排的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> a,b,x,y;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;  </span><br><span class="line">            a = <span class="number">0</span>;  </span><br><span class="line">            b = <span class="number">0</span>;  </span><br><span class="line">            x = <span class="number">0</span>;  </span><br><span class="line">            y = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">                a = <span class="number">1</span>;  </span><br><span class="line">                x = b;  </span><br><span class="line">            &#125;);  </span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">                b = <span class="number">1</span>;  </span><br><span class="line">                y = a;  </span><br><span class="line">            &#125;);  </span><br><span class="line">            t1.start();  </span><br><span class="line">            t2.start();  </span><br><span class="line">            t1.join();  </span><br><span class="line">            t2.join();  </span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>)&#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次，x = &quot;</span>+ x + <span class="string">&quot;,y = &quot;</span> + y);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">第<span class="number">208802</span>次，x = <span class="number">0</span>,y = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>上述代码在正常情况下，<code>x</code>和<code>y</code>不同时为0。只有发生指令重排，即先执行了x&#x3D;b和y&#x3D;a，才会导致<code>x</code>和<code>y</code>同时为0。</p><p><code>happens-before</code> 规则：在如下规则下不允许指令重排</p><ol><li>单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。</li><li>锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。</li><li>volatile的happen-before原则： 对一个volatile变量的写操作happen-before对此变量的任意操作。</li><li>happen-before的传递性原则： 如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。</li><li>线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。</li><li>线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。</li><li>线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。</li><li>对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。</li></ol><p><code>volatile</code>修饰：被该关键词修饰的属性不会被指令重排。通过写前StoreStore 屏障和读后LoadLoad 屏障实现。</p><h1 id="五、锁"><a href="#五、锁" class="headerlink" title="五、锁"></a>五、锁</h1><p>重要！！！</p><h2 id="5-1-锁的分类"><a href="#5-1-锁的分类" class="headerlink" title="5.1 锁的分类"></a>5.1 锁的分类</h2><h3 id="可重入锁、不可重入锁"><a href="#可重入锁、不可重入锁" class="headerlink" title="可重入锁、不可重入锁"></a><strong>可重入锁、不可重入锁</strong></h3><p><strong>重入</strong>：当前线程获取到A锁，在获取之后尝试再次获取A锁是可以直接拿到的。<br><strong>不可重入</strong>：当前线程获取到A锁，在获取之后尝试再次获取A锁，无法获取到的，因为A锁被当前线程占用着，需要等待自己释放锁再获取锁。<br>Java中提供的synchronized，ReentrantLock，ReentrantReadWriteLock都是可重入锁。</p><h3 id="乐观锁、悲观锁"><a href="#乐观锁、悲观锁" class="headerlink" title="乐观锁、悲观锁"></a>乐观锁、悲观锁</h3><p><strong>悲观锁</strong>：悲观锁的基本思想是在整个操作过程中，将数据处于锁定状态，以确保在这个期间数据不会被其他线程修改。获取不到锁资源时，会将当前线程挂起（进入BLOCKED、WAITING），线程挂起会涉及到用户态和内核的太的切换，而这种切换是比较消耗资源的。<br><strong>乐观锁</strong>：乐观锁的基本思想是假设在并发访问的情况下，数据不会发生冲突，因此不对数据加锁，而是在更新时检查数据是否被其他线程修改。获取不到锁资源，可以再次让CPU调度，重新尝试获取锁资源。</p><p>Java中提供的synchronized，ReentrantLock，ReentrantReadWriteLock都是悲观锁。<br>Java中提供的CAS操作，就是乐观锁的一种实现。Atomic原子性类中，也是基于CAS乐观锁实现的。</p><h3 id="公平锁、非公平锁"><a href="#公平锁、非公平锁" class="headerlink" title="公平锁、非公平锁"></a>公平锁、非公平锁</h3><p>公平锁是指多个线程按照请求的顺序依次获取锁，而非公平锁则允许线程插队。<br>Java中提供的<code>synchronized</code>是非公平锁。<br>Java中提供的<code>ReentrantLock</code>，<code>ReentrantReadWriteLock</code>可以实现公平锁和非公平锁</p><h3 id="互斥锁、共享锁、读写锁"><a href="#互斥锁、共享锁、读写锁" class="headerlink" title="互斥锁、共享锁、读写锁"></a>互斥锁、共享锁、读写锁</h3><p><strong>互斥锁</strong>：同一时间点，只会有一个线程持有者当前互斥锁。<br><strong>共享锁</strong>：同一时间点，当前共享锁可以被多个线程同时持有。<br><strong>读写锁</strong>：读锁-读锁共享、写锁和其他锁互斥<br>Java中提供的synchronized、ReentrantLock是互斥锁。<br>Java中提供的ReentrantReadWriteLock，有互斥锁也有共享锁。</p><h2 id="5-2-synchronized详解"><a href="#5-2-synchronized详解" class="headerlink" title="5.2 synchronized详解"></a>5.2 synchronized详解</h2><h3 id="同步代码块和同步方法"><a href="#同步代码块和同步方法" class="headerlink" title="同步代码块和同步方法"></a>同步代码块和同步方法</h3><p>同步代码块：锁住<code>&#123;&#125;</code>之间的代码。锁可以使用某个对象或类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(xxx) &#123; </span><br><span class="line"><span class="comment">// todo some thing </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步方法：声明某个方法是同步方法，同一时间最多被一个线程访问。</p><ul><li>静态方法：此时使用的是当前类.class作为锁（类锁）</li><li>非静态方法：此时使用的是当前对象做为锁（对象锁）<br>类锁和其某个类实例的锁是相互独立的。下面代码中的两个线程可以同时执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">syncDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">LockDemo</span> <span class="variable">lockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockDemo</span>();  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            lockDemo.staticMethod();  </span><br><span class="line">        &#125;);  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            lockDemo.instanceMethod();  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        thread1.start();  </span><br><span class="line">        thread2.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockDemo</span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 静态方法上的类锁  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// synchronized code  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">formattedTime</span> <span class="operator">=</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));  </span><br><span class="line">        System.out.println(<span class="string">&quot;staticMethod() start Time: &quot;</span> + formattedTime);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;staticMethod() end Time: &quot;</span> + LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 实例方法上的对象锁  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">instanceMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// synchronized code  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">formattedTime</span> <span class="operator">=</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));  </span><br><span class="line">        System.out.println(<span class="string">&quot;instanceMethod() start Time: &quot;</span> + formattedTime);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;instanceMethod() end Time: &quot;</span> + LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="JIT优化方式"><a href="#JIT优化方式" class="headerlink" title="JIT优化方式"></a>JIT优化方式</h3><p><strong>锁消除</strong>：在synchronized修饰的代码中，如果不存在操作临界资源的情况，会触发锁消除，此时synchronized无效。比如只有一些局部变量。</p><p><strong>锁粗化</strong>：如果在一个循环中，频繁的获取和释放做资源，这样带来的消耗很大，锁膨胀就是将锁的范围扩大，避免频繁的竞争和获取锁资源带来不必要的消耗。(不一定会触发)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">999999</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这是上面的代码会触发锁膨胀</span></span><br><span class="line">    <span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">999999</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lockElimination</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">                method1();  </span><br><span class="line">            &#125;);  </span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">                method2();  </span><br><span class="line">            &#125;);  </span><br><span class="line">            thread1.start();  </span><br><span class="line">            thread2.start();  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (syncDemo.class)&#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;method1:&quot;</span>+i);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (syncDemo.class)&#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;method2:&quot;</span>+i);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 从控制台的输出看到</span></span><br><span class="line"><span class="comment">// thread1和thread2还是交错执行的，并没有触发锁膨胀</span></span><br></pre></td></tr></table></figure><p><strong>锁升级</strong>：锁的状态总共有四种，无锁状态、偏向锁、轻量级锁、重量级锁。<br>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。但是锁的升级是单向的，只能升级不能降级。</p><ul><li>无锁、匿名偏向：当前对象没有作为锁存在。</li><li>偏向锁：如果当前锁资源，只有一个线程在频繁的获取和释放，那么这个线程过来，只需要判断，当前指向的线程是否是当前线程 。<ul><li>如果是，直接拿着锁资源走。</li><li>如果当前线程不是我，基于CAS的方式，尝试将偏向锁指向当前线程。如果获取不到，触发锁升级，升级为轻量级锁。（偏向锁状态出现了锁竞争的情况）</li></ul></li><li>轻量级锁：会采用自旋锁的方式去频繁的以CAS的形式获取锁资源（采用的是自适应自旋锁）<ul><li>如果成功获取到，拿着锁资源走</li><li>如果自旋了一定次数，没拿到锁资源，锁升级。</li></ul></li><li>重量级锁：就是最传统的synchronized方式，拿不到锁资源，就挂起当前线程。（用户态&amp;内核态）</li></ul><p><img src="/../../../img/Pasted%20image%2020240221162748.png"></p><p>synchronized是基于对象实现的，那这些锁的信息存储在哪？<br><img src="/../../../img/Pasted%20image%2020240222102622.png"><br>实例数据：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。<br>内存填充：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。<br>Java<strong>头对象</strong>是是实现synchronized锁对象的基础，一般而言，synchronized使用的锁对象是存储在Java对象头里的，jvm中采用2个字节来存储对象头（数组是三个字节），其主要结构是由Mark Word和Class Metadata Address组成，其结构说明如下表：</p><table><thead><tr><th>头对象结构</th><th>说明</th></tr></thead><tbody><tr><td>Mark Word</td><td>存储对象的hashCode、锁信息或分代年龄或GC标志等信息</td></tr><tr><td>Class Metadata Address</td><td>类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。</td></tr><tr><td>Mark Word结构</td><td></td></tr><tr><td><img src="/../../../img/Pasted%20image%2020240222103301.png"></td><td></td></tr><tr><td>锁状态转变流程</td><td></td></tr><tr><td><img src="/../../../img/Pasted%20image%2020240222103620.png"></td><td></td></tr></tbody></table><h2 id="5-3-ReentrantLock详解"><a href="#5-3-ReentrantLock详解" class="headerlink" title="5.3 ReentrantLock详解"></a>5.3 ReentrantLock详解</h2><h3 id="ReentrantLock和synchronized区别"><a href="#ReentrantLock和synchronized区别" class="headerlink" title="ReentrantLock和synchronized区别"></a>ReentrantLock和synchronized区别</h3><ul><li>ReentrantLock是类，而synchronized是关键词。</li><li>底层都是基于JVM层面实现互斥锁</li><li>实现原理：ReentrantLock是基于AQS实现，而synchronized是关基于ObjectMonitor</li><li>ReentrantLock功能更全面，支持公平锁和非公平锁，支持限制等待时间。</li><li>效率区别：ReentranLock不存在锁升级概念；synchronized存在锁升级概念；</li></ul><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AbstractQueuedSynchronizer，即抽象的队列同步器，是一种用来构建锁和同步器的框架。JUC下的很多内容都是基于AQS实现了部分功能，比如ReentrantLock，ThreadPoolExecutor，BlockingQueue，CountDownLatch，Semaphore，CyclicBarrier等等都是基于AQS实现。</p><p>首先AQS中提供了一个由volatile修饰，并且采用CAS方式修改的int类型的state变量。<br>其次AQS中维护了一个双向链表，有head，有tail，并且每个节点都是Node对象。</p><h2 id="5-4-ReentrantReadWriteLock详解"><a href="#5-4-ReentrantReadWriteLock详解" class="headerlink" title="5.4 ReentrantReadWriteLock详解"></a>5.4 ReentrantReadWriteLock详解</h2><p>读写锁，多个线程可以同时进行读操作，提高了并发效率。读-读不互斥，读-写互斥，写-写互斥。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>ReentrantReadWriteLock还是基于AQS实现的，还是对state进行操作，拿到锁资源就去干活，如果没有拿到，依然去AQS队列中排队。</p><p>读锁操作：基于state的高16位进行操作。<br>写锁操作：基于state的低16位进行操作。</p><p>ReentrantReadWriteLock依然是<strong>可重入锁</strong>。</p><h1 id="六、阻塞队列"><a href="#六、阻塞队列" class="headerlink" title="六、阻塞队列"></a>六、阻塞队列</h1><p>阻塞队列基于生产者消费者模式。<br>生产者存储方法：</p><ul><li><code>add(E)</code> : 添加数据到队列，如果队列满了，无法存储，抛出异常</li><li><code>offer(E)</code> : 添加数据到队列，如果队列满了，返回false</li><li><code>offer(E,timeout,unit)</code> : 添加数据到队列，如果队列满了，阻塞timeout时间，如果阻塞一段时间，依然没添加进入，返回false</li><li><code>put(E)</code> : 添加数据到队列，如果队列满了，挂起线程，等到队列中有位置，再扔数据进去，死等！</li></ul><p>消费者读取方法：</p><ul><li><code>remove()</code> : 从队列中移除数据，如果队列为空，抛出异常</li><li><code>poll()</code> : 从队列中移除数据，如果队列为空，返回null</li><li><code>poll(timeout,unit)</code> : 从队列中移除数据，如果队列为空，挂起线程timeout时间，等生产者存入数据，再获取</li><li><code>take()</code> ：从队列中移除数据，如果队列为空，线程挂起，一直等到生产者扔数据，再获取</li></ul><h2 id="6-1-ArrayBlockingQueue"><a href="#6-1-ArrayBlockingQueue" class="headerlink" title="6.1 ArrayBlockingQueue"></a>6.1 ArrayBlockingQueue</h2><p><strong>ArrayBlockingQueue</strong>在初始化的时候，必须指定当前队列的长度。它是循环使用固定长度的数组实现，通过两个属性，<code>putIndex</code>和<code>takeIndex</code>来控制放入和取出元素的下标。</p><h2 id="6-2-LinkedBlockingQueue"><a href="#6-2-LinkedBlockingQueue" class="headerlink" title="6.2 LinkedBlockingQueue"></a>6.2 LinkedBlockingQueue</h2><p><strong>LinkedBlockingQueue</strong>是基于链表的，通过头节点和尾节点控制放入和取出。可以指定最大容量，也可以不指定。</p><h2 id="6-3-PriorityBlockingQueue"><a href="#6-3-PriorityBlockingQueue" class="headerlink" title="6.3 PriorityBlockingQueue"></a>6.3 PriorityBlockingQueue</h2><p>首先PriorityBlockingQueue是一个优先级队列，他不满足先进先出的概念。<br>会将查询的数据进行排序，排序的方式就是基于插入数据值的本身。<br>实现原理是基于<strong>数组</strong>实现的二叉堆。</p><h2 id="6-4-DelayQueue"><a href="#6-4-DelayQueue" class="headerlink" title="6.4 DelayQueue"></a>6.4 DelayQueue</h2><p>DelayQueue就是一个延迟队列，生产者写入一个消息，这个消息还有直接被消费的延迟时间。<br>DelayQueue会更具延迟时间进行排序，其本身也是一个PriorityBlockingQueue<br>其放入的元素需要实现<code>Delayed</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外卖订单超时自动取消场景</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">delayQ</span><span class="params">()</span>&#123;  </span><br><span class="line">    DelayQueue&lt;DelayTask&gt; delayQueue = <span class="keyword">new</span> <span class="title class_">DelayQueue</span>&lt;DelayTask&gt;();  </span><br><span class="line">    <span class="type">DelayTask</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelayTask</span>(<span class="string">&quot;A&quot;</span>, <span class="number">2000l</span>);  </span><br><span class="line">    delayQueue.add(task1);  </span><br><span class="line">    delayQueue.add(<span class="keyword">new</span> <span class="title class_">DelayTask</span>(<span class="string">&quot;B&quot;</span>,<span class="number">1000l</span>));  </span><br><span class="line">    delayQueue.add(<span class="keyword">new</span> <span class="title class_">DelayTask</span>(<span class="string">&quot;C&quot;</span>,<span class="number">3000l</span>));  </span><br><span class="line">    <span class="comment">// 只有到延迟时间才会取出，应用场景，订单超时自动取消。  </span></span><br><span class="line">    <span class="comment">// 商家正常接单，从超时队列中移除，走正常消费逻辑  </span></span><br><span class="line">    delayQueue.remove(task1);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 不断移除超时订单  </span></span><br><span class="line">    <span class="keyword">while</span> (delayQueue.size()&gt;<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            System.out.println(delayQueue.take());  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DelayTask</span> <span class="keyword">implements</span> <span class="title class_">Delayed</span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> Long delayTime;  </span><br><span class="line">    <span class="keyword">private</span> Long executeTime;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DelayTask</span><span class="params">(String name, Long delayTime)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">        <span class="built_in">this</span>.delayTime = delayTime;  </span><br><span class="line">        <span class="built_in">this</span>.executeTime = System.currentTimeMillis() + delayTime;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getExecuteTime</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> executeTime;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> unit.convert(executeTime - System.currentTimeMillis(),TimeUnit.MILLISECONDS);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Delayed o)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (<span class="built_in">this</span>.executeTime - ((DelayTask)o).getExecuteTime());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DelayTask&#123;&quot;</span> +  </span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +  </span><br><span class="line">                <span class="string">&quot;, delayTime=&quot;</span> + delayTime +  </span><br><span class="line">                <span class="string">&quot;, executeTime=&quot;</span> + executeTime +  </span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-5-SynchronousQueue"><a href="#6-5-SynchronousQueue" class="headerlink" title="6.5 SynchronousQueue"></a>6.5 SynchronousQueue</h2><p>这个队列比较特殊，它不存储元素。因为SynchronousQueue没有容量。与其他BlockingQueue（阻塞队列）不同,SynchronousQueue是一个不存储元素的BlockingQueue。只是它维护一组线程，这些线程在等待着把元素加入或移出队列。</p><p>可以理解为给线程“配对”。入和出必须是配对的，否则阻塞。<br>注意：有两种模式，分别为公平模式和非公平模式。公平模式按照先来先配对原则（TransferQueue），非公平按照后来先配对（TransferStack）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">syncBlockQ</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;  </span><br><span class="line">    SynchronousQueue&lt;String&gt; syncq = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(<span class="literal">false</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            syncq.put(<span class="string">&quot;生1&quot;</span>);  </span><br><span class="line">            System.out.println(<span class="string">&quot;生1放入数据&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;).start();  </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            syncq.put(<span class="string">&quot;生2&quot;</span>);  </span><br><span class="line">            System.out.println(<span class="string">&quot;生2放入数据&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;).start();  </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            syncq.put(<span class="string">&quot;生3&quot;</span>);  </span><br><span class="line">            System.out.println(<span class="string">&quot;生3放入数据&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;).start();  </span><br><span class="line">  </span><br><span class="line">    Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;消1：&quot;</span> + syncq.poll());  </span><br><span class="line">    &#125;).start();  </span><br><span class="line">    Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;消2：&quot;</span> + syncq.poll());  </span><br><span class="line">    &#125;).start();  </span><br><span class="line">    Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;消3：&quot;</span> + syncq.poll());  </span><br><span class="line">    &#125;).start();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">输出</span><br><span class="line">消<span class="number">1</span>：生<span class="number">3</span></span><br><span class="line">消<span class="number">2</span>：生<span class="number">2</span></span><br><span class="line">消<span class="number">3</span>：生<span class="number">1</span></span><br><span class="line"></span><br><span class="line">如果改为公平模式则输出</span><br><span class="line">消<span class="number">1</span>：生<span class="number">3</span></span><br><span class="line">消<span class="number">2</span>：生<span class="number">2</span></span><br><span class="line">消<span class="number">3</span>：生<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://blog.csdn.net/CoderTnT/article/details/112685116">Java多线程基础知识_waitset entrylist-CSDN博客</a><br><a href="https://blog.csdn.net/weixin_48321993/article/details/131475435?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170834835116800192213848%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170834835116800192213848&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-131475435-null-null.142%5Ev99%5Epc_search_result_base5&utm_term=java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B&spm=1018.2226.3001.4187">java并发编程(荣耀典藏版)-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.S081</title>
      <link href="/posts/3fdc6854/"/>
      <url>/posts/3fdc6854/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>课程网站：<a href="https://pdos.csail.mit.edu/6.828/2021/schedule.html">https://pdos.csail.mit.edu/6.828/2021/schedule.html</a></p><p>课程翻译：<a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/">https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/</a></p><h1 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h1><h2 id="Lecture1"><a href="#Lecture1" class="headerlink" title="Lecture1"></a>Lecture1</h2><h2 id="Lecture3"><a href="#Lecture3" class="headerlink" title="Lecture3"></a>Lecture3</h2><p><strong>隔离性（isolation)</strong><br>不同应用程序进程之间应该相互独立。<br>假设不存在操作系统层，应用程序直接和硬件进行交互。会产生CPU调度问题（某个应用程序一直占用CPU，其他应用无法被调度）、内存安全问题（应用程序修改了其他应用程序的内存数据）</p><p>应用程序不能直接与CPU交互，只能与进程交互。操作系统内核会完成不同进程在CPU上的切换。所以，操作系统不是直接将CPU提供给应用程序，而是向应用程序提供“进程”，进程抽象了CPU，这样操作系统才能在多个应用程序之间复用一个或者多个CPU。</p><p>多个进程同一时间不可以使用同一个CPU核，一般都是分时复用。</p><p><code>fork</code>抽象了<code>CPU</code>、<code>exec</code>抽象了<code>内存</code>、<code>files</code>抽象了<code>磁盘</code>。理解这些系统调用的抽象和隔离性。</p><p><strong>防御性（Defensive)</strong><br>需要考虑应用程序不能通过某些恶意手段使得操作系统崩溃或打破隔离，进而控制内核。由于内核拥有所有硬件资源，控制了内核就相当于可以做任何事情。</p><p><strong>硬件和强隔离性</strong><br>硬件对于强隔离的支持包括了：<strong>user&#x2F;kernle mode</strong>和<strong>虚拟内存</strong>。<br>处理器有两种运行模式，分别是<code>user mode</code>和<code>kernel mode</code>。在不同运行模式下，其可运行的指令权限不同。（通过处理器上的一个<strong>bit标志位</strong>区分两种模式，并拒绝在当前模式下不该执行的指令）</p><p>普通权限指令（unprivileged instructions）：如ADD、SUB、JRC等，允许所有应用程序执行。<br>特殊权限指令（privileged instructions）：如设置page table、关闭时钟中断。是一些直接操纵硬件的指令和设置保护的指令。</p><p>用户态到内核态的切换是通过硬件中断、陷阱或异常机制实现的。</p><p><strong>虚拟内存</strong><br>每个进程都维护了自己独立的page table，将虚拟内存和物理内存进行映射，使得进程间的物理内存都不重合。保证了进程和进程间内存的隔离性。</p><p><strong>User&#x2F;Kernel mode切换</strong><br>应用程序通过ECALL指令将程序的控制权交给内核。ECALL指令接收一个数字参数，代表想要调用的System Call。内核中的syscall会根据传入的参数去实际调用应用程序想调用的那个系统调用。</p><p><strong>宏内核 vs 微内核</strong><br>宏内核：整个操作系统代码都运行在kernel mode。大多数的Unix操作系统实现都运行在kernel mode。<br>优点：高集成性，可以提供很高的性能<br>缺点：内核复杂，容易引入BUG</p><p>微内核：在这种模式下，希望在kernel mode中运行尽可能少的代码。比如内核仅提供IPC，虚拟内存，page table的支持。像文件系统、虚拟内存等以用户应用程序运行在user mode。用户应用程序需要通过内核的IPC与这些文件系统、exec等进行调用。假设我们需要让Shell能与文件系统交互，比如Shell调用了exec，必须有种方式可以接入到文件系统中。通常来说，这里工作的方式是，Shell会通过内核中的IPC系统发送一条消息，内核会查看这条消息并发现这是给文件系统的消息，之后内核会把消息发送给文件系统。<br>优点：内核精简意味着更少的BUG和更高的安全性<br>缺点：性能低，需要多次用户空间-内核空间的跳转。以及无法共享缓存数据，如page cache。</p><h2 id="Lecture4"><a href="#Lecture4" class="headerlink" title="Lecture4"></a>Lecture4</h2><p><strong>虚拟内存</strong></p><p><strong>地址空间（Address Spaces）</strong><br>某个应用程序所拥有的一段专属内存空间。<br><img src="/../../../../img/Pasted%20image%2020240219122536.png"></p><p><strong>页表（Page Table)</strong><br>页表是在硬件中通过处理器和内存管理单元（Memory Management Unit）实现。内存管理单元负责虚拟地址和物理地址的转换。也就是说CPU通过MMU和MEM交互。<br>每个进程有自己的地址关系映射表单，其地址保存在SATP寄存器上，当进程切换的时候内核会将SATP寄存器修改为对应进程的地址关系表单的地址。</p><p>地址转换表是以page为粒度的，一个page为4KB，需要12bit。<br>虚拟地址占39位。27位index,12位offset。<br>物理地址占64位，44位index,12位offset。</p><p><strong>页表缓存</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> OS </category>
          
          <category> MIT6.S081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.830-Lab6</title>
      <link href="/posts/4d88feef/"/>
      <url>/posts/4d88feef/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在这个实验中，你将实现基于日志的回滚（rollback）用于撤销操作和基于日志的崩溃恢复。我们为你提供了定义日志格式并在事务期间在适当的时候向日志文件附加记录的代码。你将使用日志文件的内容来实现回滚和恢复。</p><p>我们提供的日志代码生成用于物理整页撤销和重做的记录。当首次读取页面时，我们的代码将原始内容记住为一个前镜像。当事务更新页面时，相应的日志记录包含该记住的前镜像以及修改后的页面内容作为后镜像。在中止期间，你将使用前镜像进行回滚，并在恢复期间撤销失败的事务，而使用后镜像在恢复期间重做成功的事务。</p><p>我们之所以能够使用整页物理撤销（而 ARIES 必须进行逻辑撤销）是因为我们使用页面级别的锁定，并且因为我们没有可能在 UNDO 时具有与初始写入日志时不同结构的索引。页面级别锁定简化了事情的原因在于，如果一个事务修改了一个页面，它必须拥有它的独占锁定，这意味着没有其他事务在同时修改它，因此我们可以通过简单地覆盖整个页面来 UNDO 对它的更改。</p><p>你的 <code>BufferPool</code> 已经通过删除脏页来实现中止，并通过仅在提交时将脏页强制写入磁盘来模拟原子提交。日志记录允许更灵活的缓冲区管理（<code>STEAL</code> 和<code> NO-FORCE</code>），我们的测试代码在某些时候调用 <code>BufferPool.flushAllPages()</code> 以行使这种灵活性。</p><h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>在你现有的代码中做出如下更改：</p><ul><li>在调用 <code>writePage(p)</code> 之前，将下面几行插入 <code>BufferPool.flushPage()</code>，其中 <code>p</code> 是对正在写入的页面的引用：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// append an update record to the log, with </span></span><br><span class="line"><span class="comment">// a before-image and after-image.</span></span><br><span class="line"><span class="type">TransactionId</span> <span class="variable">dirtier</span> <span class="operator">=</span> p.isDirty();</span><br><span class="line"><span class="keyword">if</span> (dirtier != <span class="literal">null</span>)&#123;</span><br><span class="line">  Database.getLogFile().logWrite(dirtier, p.getBeforeImage(), p);</span><br><span class="line">  Database.getLogFile().force();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将导致日志系统向日志写入更新。<br>在将页面写入磁盘之前，我们会强制日志确保日志记录在磁盘上。</p><ul><li><code>BufferPool.transactionComplete()</code> 会为已提交事务弄脏的每个页面调用<code>flushPage()</code>。在刷新页面后，为每个此类页面添加对 <code>p.setBeforeImage()</code> 的调用：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use current page contents as the before-image</span></span><br><span class="line"><span class="comment">// for the next transaction that modifies this page.</span></span><br><span class="line">p.setBeforeImage();</span><br></pre></td></tr></table></figure></li></ul><p>在提交更新后，页面的前镜像需要更新，以便稍后中止的事务回滚到该页面的已提交版本。（注意：我们不能在 <code>flushPage()</code> 中调用 <code>setBeforeImage()</code>，因为即使事务不提交，<code>flushPage()</code> 也可能被调用。我们的测试用例实际上就是这样做的！如果你通过调用 <code>flushPages()</code> 来实现 <code>transactionComplete()</code>，则可能需要向 <code>flushPages()</code> 传递一个额外的参数，以告诉它是否为提交的事务执行刷新。然而，在这种情况下，我们强烈建议你简单地重写 <code>transactionComplete()</code> 以使用 <code>flushPage()</code>。）</p><p>做完这些更改后，请执行一次 “清除 “构建（ant clean；ant  或 Eclipse 中 “项目 “菜单中的 “清理”）。</p><p>此时，您的代码应能通过 LogTest 系统测试的前三个子测试，其余的则会失败。</p><h2 id="Rollback"><a href="#Rollback" class="headerlink" title="Rollback"></a>Rollback</h2><p>阅读 <code>LogFile.java</code> 中关于日志文件格式的注释。在 <code>LogFile.java</code> 中，你应该会看到一组函数，比如 <code>logCommit()</code>，用于生成每种类型的日志记录并将其追加到日志文件中。</p><p>你的第一个任务是在 <code>LogFile.java</code> 中实现 <code>rollback()</code> 函数。当事务中止时，在事务释放其锁之前，将调用此函数。它的任务是撤消事务可能对数据库所做的任何更改。</p><p>你的<code>rollback()</code>应该读取日志文件，找到与中止事务相关联的所有更新记录，从中提取前镜像，并将前镜像写入表文件。使用 <code>raf.seek()</code> 在日志文件中移动，使用 <code>raf.readInt()</code> 等检查它。使用 <code>readPageData()</code> 读取每个前后镜像。你可以使用映射 <code>tidToFirstLogRecord</code>（将事务 id 映射到堆文件中的偏移量）来确定从哪里开始读取特定事务的日志文件。你需要确保丢弃缓冲池中任何其前镜像被写回表文件的页面。</p><p>在开发代码时，你可能会发现 <code>Logfile.print()</code> 方法对显示日志当前内容很有用。</p><h2 id="Exercise-1-LogFile-rollback"><a href="#Exercise-1-LogFile-rollback" class="headerlink" title="Exercise 1: LogFile.rollback()"></a><strong>Exercise 1: LogFile.rollback()</strong></h2><p>实现<code>LogFile.rollback()</code>。<br>完成此练习后，你应该能够通过<code>LogTest</code>系统测试的<code>TestAbort</code>和<code>TestAbortCommitInterleaved</code>子测试。</p><h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><p>如果数据库崩溃然后重新启动，将在任何新事务开始之前调用<code>LogFile.recover()</code>。您的实现应该：</p><ol><li>读取最后一个检查点（如果有的话）。</li><li>从检查点（或如果没有检查点，则从日志文件的开头）开始向前扫描，以构建失败事务的集合。在此过程中Redo执行更新。可以安全地从检查点开始Redo，因为<code>LogFile.logCheckpoint()</code>会将所有脏缓冲区刷新到磁盘。</li><li>Undo失败事务的更新。</li></ol><h2 id="Exercise-2-LogFile-recover"><a href="#Exercise-2-LogFile-recover" class="headerlink" title="Exercise 2: LogFile.recover()"></a><strong>Exercise 2: LogFile.recover()</strong></h2><p>实现LogFile.recover()。<br>完成此练习后，您应该能够通过LogTest系统测试的所有测试。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 数据库 </category>
          
          <category> MIT6.830 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.830-Lab5</title>
      <link href="/posts/d481af55/"/>
      <url>/posts/d481af55/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在这个实验中，你将实现一个B+树索引，用于高效的查找和范围扫描。我们已经为你提供了所有需要实现树结构的底层代码。你将实现搜索、页面分裂、在页面之间重新分配元组以及页面合并。</p><p>阅读教材中的第10.3至10.7节可能会对B+树的结构以及搜索、插入和删除的伪代码有详细的了解，这可能对你有所帮助。</p><p>正如教材和课堂上讨论的那样，B+树中的内部节点包含多个条目，每个条目由一个键值、一个左子指针和一个右子指针组成。相邻的键共享一个子指针，因此包含m个键的内部节点有m+1个子指针。叶子节点可以包含数据条目，也可以包含指向其他数据库文件中的数据条目的指针。为了简化起见，我们将实现一个B+树，其中叶子页面实际上包含数据条目。相邻的叶子页面通过右和左兄弟指针链接在一起，因此范围扫描只需要通过根和内部节点进行一次初始搜索，以找到第一个叶子页面。随后的叶子页面通过跟随右（或左）兄弟指针找到。</p><h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p>查看<code>index/</code>和<code>BTreeFile.java</code>。这是B+树实现的核心文件，也是你在本实验中编写<strong>所有代码</strong>的地方。与<code>HeapFile</code>不同，<code>BTreeFile</code>由<strong>四种不同类型</strong>的页面组成。正如你所预期的那样，树的节点有两种不同类型的页面：内部页面和叶子页面。内部页面的实现在<code>BTreeInternalPage.java</code>中，叶子页面的实现在<code>BTreeLeafPage.java</code>中。为了方便起见，我们在<code>BTreePage.java</code>中创建了一个抽象类，其中包含对叶子和内部页面都通用的代码。此外，头部页面的实现在<code>BTreeHeaderPage.java</code>中，用于跟踪文件中哪些页面正在使用。最后，在每个<code>BTreeFile</code>的开头有一个页面，它指向树的根页面和第一个头部页面。这个单例页面的实现在<code>BTreeRootPtrPage.java</code>中。熟悉这些类的接口，特别是<code>BTreePage</code>、<code>BTreeInternalPage</code>和<code>BTreeLeafPage</code>。你需要在实现B+树时使用这些类。</p><p>你的第一个任务是在<code>BTreeFile.java</code>中实现<code>findLeafPage()</code>函数。该函数用于找到给定特定键值的适当叶子页面，用于搜索和插入操作。例如，假设我们有一个具有两个叶子页面的B+树（见图1）。根节点是一个内部页面，带有一个条目其包含了一个键（在本例中为6）和两个子指针。给定值1，此函数应返回第一个叶子页面。同样，给定值8，此函数应返回第二个页面。较不明显的情况是，如果我们给定键值6，由于可能存在重复的键，因此两个叶子页面上可能都有6。在这种情况下，该函数应返回第一个（<strong>左侧</strong>）叶子页面。<br><img src="/../../../../img/Pasted%20image%2020240209101345.png"></p><p>你的<code>findLeafPage()</code>函数应该通过递归搜索内部节点，直到找到与提供的键值相对应的叶子页面。为了找到每一步的适当子页面，你应该迭代内部页面中的条目，并将条目值与提供的键值进行比较。<code>BTreeInternalPage.iterator()</code>提供了使用<code>BTreeEntry.java</code>中定义的接口访问内部页面条目的方式。这个迭代器允许你遍历内部页面的键值，并访问每个键的左右子页面ID。递归的基本情况是当传入的<code>BTreePageId</code>的<code>pgcateg()</code>等于<code>BTreePageId.LEAF</code>时，表示它是一个叶子页面。在这种情况下，你只需从缓冲池中获取页面并返回。无需确认它是否实际包含提供的键值 <code>f</code>。</p><p>你的<code>findLeafPage()</code>代码还必须处理提供的键值 <code>f</code> 为 null 的情况。如果提供的值为 null，则每次都要递归到最左侧的子页面，以找到最左侧的叶子页面。找到正确的叶子页面后，应返回它。如上所述，你可以使用<code>BTreePageId.java</code>中的<code>pgcateg()</code>函数检查页面的类型。你可以假设只有叶子页面和内部页面会传递到此函数。</p><p>建议使用我们提供的包装函数<code>BTreeFile.getPage()</code>，而不是直接调用<code>BufferPool.getPage()</code>来获取每个内部页面和叶子页面。它的工作方式与<code>BufferPool.getPage()</code>完全相同，但接受额外的参数来跟踪脏页列表。在接下来的两个练习中，你将实际更新数据，因此需要跟踪脏页，这使得这个函数变得重要。</p><p>你的<code>findLeafPage()</code>实现访问的每个内部（非叶）页面应该以<strong>READ_ONLY</strong>权限获取，除了返回的叶子页面，叶子页面应该以作为函数参数提供的权限获取。虽然权限级别在本实验中可能不重要，但对于代码在未来实验中正确运行至关重要。</p><hr><h2 id="Exercise-1-BTreeFile-findLeafPage"><a href="#Exercise-1-BTreeFile-findLeafPage" class="headerlink" title="Exercise 1: BTreeFile.findLeafPage()"></a><strong>Exercise 1: BTreeFile.findLeafPage()</strong></h2><p>实现<code>BTreeFile.findLeafPage()</code>.<br>完成这个练习后，你应该能够通过<code>BTreeFileReadTest.java</code>中的所有单元测试和<code>BTreeScanTest.java</code>中的系统测试。</p><h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h2><p>为了保持B+树元组的有序性并维护树的完整性，我们必须将元组插入到具有包围键范围的叶子页面中。正如上面提到的，<code>findLeafPage()</code>可以用于找到应将元组插入的正确叶子页面。然而，每个页面有限数量的插槽，我们需要能够插入元组，即使相应的叶子页面已满。</p><p>如教材所述，尝试将元组插入已满的叶子页面应导致该页面拆分，使元组均匀分布在两个新页面之间。每当叶子页面拆分时，将需要向父节点添加一个对应于第二页中的第一个元组的新条目。偶尔，内部节点可能也已满，无法接受新的条目。在这种情况下，父节点应拆分并向其父节点添加一个新条目。这可能导致递归拆分，最终创建一个新的根节点。</p><p>在这个练习中，你将在<code>BTreeFile.java</code>中实现<code>splitLeafPage()</code>和<code>splitInternalPage()</code>。如果被拆分的页面是根页面，你将需要创建一个新的内部节点作为新的根页面，并更新<code>BTreeRootPtrPage</code>。否则，你将需要以READ_WRITE权限获取父页面，如果有必要，递归拆分它，并添加一个新条目。你将发现<code>getParentWithEmptySlots()</code>函数非常有用，用于处理这些不同的情况。在<code>splitLeafPage()</code>中，你应该将键“复制”到父页面，而在<code>splitInternalPage()</code>中，你应该将键“推送”到父页面。如果这令人困惑，请参阅图2并回顾教材第10.5节。记得根据需要更新新页面的父指针（为简单起见，在图中我们未显示父指针）。当内部节点被拆分时，你将需要更新所有已移动的子节点的父指针。你可能会发现<code>updateParentPointers()</code>函数对于这个任务很有用。此外，请记得更新任何已拆分的叶子页面的兄弟指针。最后，返回应插入新元组或条目的页面，如提供的键字段所示。（提示：你不需要担心提供的键实际上可能正好位于要拆分的元组&#x2F;条目的正中央。在拆分过程中，你应该忽略键，仅使用它来确定应返回的两个页面中的哪一个。）<br><img src="/../../../../img/Pasted%20image%2020240209164059.png"></p><p>在创建新页面时，无论是由于拆分页面还是创建新的根页面，都要调用<code>getEmptyPage()</code>来获取新页面。此函数是一个抽象，它将允许我们重用由于合并而被删除的页面（在下一节中讨论）。</p><p>我们期望你将使用<code>BTreeLeafPage.iterator()</code>和<code>BTreeInternalPage.iterator()</code>与叶子页面和内部页面进行交互，以遍历每个页面中的<code>Tuple/Entry</code>。为方便起见，我们还为两种类型的页面提供了反向迭代器：<code>BTreeLeafPage.reverseIterator()</code>和<code>BTreeInternalPage.reverseIterator()</code>。这些反向迭代器在从页面移到其右兄弟的子集中特别有用。</p><p>如上所述，内部页面迭代器使用<code>BTreeEntry.java</code>中定义的接口，该接口具有一个键和两个子指针。它还有一个<code>recordId</code>，用于标识底层页面上键和子指针的位置。我们认为一次处理一个条目是与内部页面交互的一种自然方式，但重要的是要记住，底层页面实际上并不存储条目列表，而是存储有序列表的 m 个键和 m+1 个子指针。由于<code>BTreeEntry</code>只是一个接口，而不是实际存储在页面上的对象，更新<code>BTreeEntry</code>的字段不会修改底层页面。为了更改页面上的数据，你需要调用<code>BTreeInternalPage.updateEntry()</code>。此外，删除一个条目实际上只删除一个键和一个单独的子指针，因此我们提供了函数<code>BTreeInternalPage.deleteKeyAndLeftChild()</code>和<code>BTreeInternalPage.deleteKeyAndRightChild()</code>来明确此操作。条目的<code>recordId</code>用于找到要删除的键和子指针。插入一个条目也只插入一个键和一个单独的子指针（除非是第一个条目），因此<code>BTreeInternalPage.insertEntry()</code>检查提供的条目中的一个子指针是否与页面上的现有子指针重叠，并且在该位置插入条目是否会保持键的排序顺序。</p><p>在<code>splitLeafPage()</code>和<code>splitInternalPage()</code>中，你将需要更新脏页集，其中包括任何新创建的页面以及由于新指针或新数据而修改的任何页面。这就是<code>BTreeFile.getPage()</code>将会派上用场的地方。每次获取页面时，<code>BTreeFile.getPage()</code>都会检查页面是否已存储在本地缓存（<code>dirtypages</code>）中，如果在那里找不到请求的页面，则从缓冲池中获取它。由于<code>BTreeFile.getPage()</code>假设很快这些页面将被标记为脏页，因此它还会将以读写权限获取的页面添加到<code>dirtypages</code>缓存中。这种方法的一个优点是它防止在单个元组插入或删除期间多次访问相同页面时丢失更新。</p><p>请注意，与<code>HeapFile.insertTuple()</code>有很大不同，<code>BTreeFile.insertTuple()</code>可能会返回一组大的脏页，特别是如果有任何内部页面被拆分。正如你可能记得的之前的实验中一样，返回脏页集是为了防止缓冲池在刷新之前驱逐脏页。</p><hr><p>警告：由于B+树是一种复杂的数据结构，在修改它之前了解每个合法B+树必需的属性是有帮助的。以下是一个非正式的列表：</p><ol><li>如果父节点指向子节点，则子节点必须指回相同的父节点。</li><li>如果叶节点指向右兄弟，则右兄弟必须指回该叶节点作为左兄弟。</li><li>第一个和最后一个叶子必须分别指向 null 的左兄弟和右兄弟。</li><li>记录 ID 必须与它们实际所在的页面匹配。</li><li>在具有非叶子子节点的节点中，键必须大于左子节点中的任何键，并且小于右子节点中的任何键。</li><li>在具有叶子子节点的节点中，键必须大于或等于左子节点中的任何键，并且小于或等于右子节点中的任何键。</li><li>一个节点要么具有全部是非叶子子节点，要么具有全部是叶子子节点。</li><li>非根节点不能少于半满。</li></ol><p>我们在文件<code>BTreeChecker.java</code>中实现了对所有这些属性的机械检查。这种方法还用于在<code>systemtest/BTreeFileDeleteTest.java</code>中测试您的B+树实现。请随时添加对此函数的调用以帮助调试您的实现，就像我们在<code>BTreeFileDeleteTest.java</code>中所做的那样。</p><h2 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h2><p>为了保持树的平衡并避免浪费不必要的空间，B+树中的删除操作可能导致页面重新分配元组（图3），或者最终合并（见图4）。您可能会发现复习教材中的第10.6节对此有帮助。<br><img src="/../../../../img/Pasted%20image%2020240210190501.png"></p><p><img src="/../../../../img/Pasted%20image%2020240210190535.png"></p><p>正如教科书所述，尝试从少于半满的叶子页面中删除元组应导致该页面要么从其兄弟那里窃取元组，要么与其兄弟合并。如果页面的某个兄弟有多余的元组，则应在两个页面之间均匀分配这些元组，并相应更新父节点的条目（参见图3）。然而，如果兄弟节点也处于最小占用状态，则这两个页面应合并，并从父节点中删除相应的条目（图4）。反过来，从父节点删除条目可能导致父节点变得少于半满。在这种情况下，父节点应从其兄弟那里窃取条目或与一个兄弟合并。这可能导致递归合并甚至是根节点的删除，如果从根节点删除最后一个条目。</p><p>在这个练习中，您将在<code>BTreeFile.java</code>中实现<code>stealFromLeafPage()</code>、<code>stealFromLeftInternalPage()</code>、<code>stealFromRightInternalPage()</code>、<code>mergeLeafPages()</code>和<code>mergeInternalPages()</code>。在前三个函数中，如果兄弟节点有多余的元组&#x2F;条目，您将实现代码以均匀重新分配元组&#x2F;条目。记得更新父节点中相应的键字段（仔细查看图3中的操作方式，键实际上通过父节点“旋转”）。在<code>stealFromLeftInternalPage()</code>&#x2F;<code>stealFromRightInternalPage()</code>中，您还需要更新已移动的子节点的父指针。您应该能够重用<code>updateParentPointers()</code>函数来实现此目的。</p><p>在<code>mergeLeafPages()</code>和<code>mergeInternalPages()</code>中，您将实现代码以合并页面，实际上是执行<code>splitLeafPage()</code>和<code>splitInternalPage()</code>的反操作。您会发现<code>deleteParentEntry()</code>函数对于处理所有不同的递归情况非常有用。确保在删除页面时调用<code>setEmptyPage()</code>，以使它们可用于重新使用。与之前的练习一样，我们建议使用<code>BTreeFile.getPage()</code>来封装获取页面的过程，并保持脏页列表的最新状态。</p><h2 id="Exercise-3-Redistributing-pages"><a href="#Exercise-3-Redistributing-pages" class="headerlink" title="Exercise 3: Redistributing pages"></a><strong>Exercise 3: Redistributing pages</strong></h2><p>在<code>BTreeFile.java</code>中实现<code>stealFromLeafPage()</code>、<code>stealFromLeftInternalPage()</code>和<code>stealFromRightInternalPage()</code>。</p><p>完成此练习后，您应该能够通过<code>BTreeFileDeleteTest.java</code>中的一些单元测试（例如<code>testStealFromLeftLeafPage</code>和<code>testStealFromRightLeafPage</code>）。</p><p>系统测试可能需要几秒钟才能完成，因为它们创建了一个大型的B+树，以便充分测试系统。</p><h2 id="Exercise-4-Merging-pages"><a href="#Exercise-4-Merging-pages" class="headerlink" title="Exercise 4: Merging pages"></a><strong>Exercise 4: Merging pages</strong></h2><p>在<code>BTreeFile.java</code>中实现<code>mergeLeafPages()</code>和<code>mergeInternalPages()</code>。</p><p>现在，您应该能够通过<code>BTreeFileDeleteTest.java</code>中的所有单元测试以及<code>systemtest/BTreeFileDeleteTest.java</code>中的系统测试。</p><h2 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h2><p>你可能还记得，B+树通过使用next-key locking可以防止幻影元组在两次连续的范围扫描之间出现。由于SimpleDB使用基于页面级别的严格两阶段锁定，如果B+树的实现正确，对抗幻影元组的保护就会相对容易实现。因此，在这一点上，你应该能够通过<code>BTreeNextKeyLockingTest</code>。</p><p>此外，如果你在B+树代码中正确实现了锁定，你还应该能够通过<code>test/simpledb/BTreeDeadlockTest.java</code>中的测试。</p><p>如果一切都正确实现了，你应该能够通过BTreeTest系统测试。我们预计很多人会觉得<code>BTreeTest</code>很困难，因此这不是必需的，但如果有人能够成功运行它，我们将给予额外的学分。请注意，此测试可能需要最多一分钟才能完成。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>先明白<code>BTree</code>这几个类的关系。</p><p><img src="/../../../../img/Pasted%20image%2020240210172341.png"></p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>在运行<code>systemtest/BTreeFileDeleteTest.java</code>中的系统测试时，发现<code>BufferPool</code>中的一个Bug，修正如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在删除页面的时候，需要先刷新页面到磁盘，然后在LRU中移除</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(K key)</span>&#123;  </span><br><span class="line"><span class="comment">// 不能用get(key),get(key)返回的是V，data.get返回的是LRUNode</span></span><br><span class="line">    LRUNode&lt;K, V&gt; node = data.get(key);  </span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> (Page) node.value;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        Database.getBufferPool().flushPage(page.getId());  </span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;  </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">    deleteNode(node);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之前（错误版）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(K key)</span>&#123;</span><br><span class="line"><span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> get(key);  </span><br><span class="line"><span class="type">LRUNode</span> <span class="variable">node</span> <span class="operator">=</span> (LRUNode) v;  </span><br><span class="line"><span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> (Page) node.value;  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    Database.getBufferPool().flushPage(page.getId());  </span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e)&#123;  </span><br><span class="line">    e.printStackTrace();  </span><br><span class="line">&#125;  </span><br><span class="line">deleteNode((LRUNode)v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BTreeTest</code>无法通过，将<code>findLeafPage</code>中做如下修改后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BTreeInternalPage</span> <span class="variable">internalPage</span> <span class="operator">=</span> (BTreeInternalPage) getPage(tid, dirtypages, pid, Permissions.READ_ONLY);</span><br><span class="line">-&gt;</span><br><span class="line"><span class="type">BTreeInternalPage</span> <span class="variable">internalPage</span> <span class="operator">=</span> (BTreeInternalPage) getPage(tid, dirtypages, pid, perm);</span><br></pre></td></tr></table></figure><p>这样偶尔可以通过，猜测是并发插入和删除的时候，脏页丢失了修改。</p><p><code>BTreeTest</code>会启动大量线程同时向B+树中执行插入或删除操作，很可能某个线程执行操作的时候对页面进行了修改，使它变为了脏页。但此时另一个线程也同时在该页进行了修改，导致了更新丢失。</p><p>用等待图</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 数据库 </category>
          
          <category> MIT6.830 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.830-Lab4</title>
      <link href="/posts/a3869fc3/"/>
      <url>/posts/a3869fc3/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在本实验中，您将在 SimpleDB 中实现一个简单的基于锁的事务系统。您需要在代码的适当位置添加锁和解锁调用，并添加代码来跟踪每个事务持有的锁，并在需要时向事务授予锁。  </p><p>本文档的其余部分将介绍添加事务支持所涉及的内容，并提供如何在数据库中添加该支持的基本概要。  </p><p>与前一个实验室一样，我们建议您尽早开始。锁定和事务的调试可能相当棘手！</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>在开始之前，您应该确保了解什么是事务，以及严格的两阶段锁（您将使用它来确保事务的隔离性和原子性）是如何工作的。  </p><p>在本节的其余部分，我们将简要概述这些概念，并讨论它们与 SimpleDB 的关系。</p><h3 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h3><p>事务是一组以原子方式执行的数据库操作（如插入、删除和读取），也就是说，要么所有操作都完成，要么一个操作都没完成，而且数据库外部观察者不会发现这些操作不是作为一个不可分割的单一操作的一部分完成的。</p><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>为了帮助您了解事务管理在 SimpleDB 中的工作原理，我们将简要回顾它是如何确保满足 ACID 属性的：</p><ul><li>原子性：严格的两阶段锁定和谨慎的缓冲区管理可确保原子性。  </li><li>一致性：由于原子性，数据库具有事务一致性。其他一致性问题（如键约束）在 SimpleDB 中未涉及。  </li><li>隔离性：严格的两阶段锁提供了隔离性。  </li><li>持久性：FORCE 缓冲区管理策略可确保持久性（参见下文第 2.3 节）。</li></ul><h3 id="Recovery-and-Buffer-Management"><a href="#Recovery-and-Buffer-Management" class="headerlink" title="Recovery and Buffer Management"></a>Recovery and Buffer Management</h3><p>为了简化您的工作，我们建议您执行<code>NO STEAL/FORCE</code>缓冲区管理政策。  </p><p>正如我们在课堂上所讨论的，这意味着:</p><ul><li>你不应该将缓冲池中的脏（已更新）的页面驱逐，如果他们被未提交的事务锁定。(这是<code>NO STEAL</code>)</li><li>在事务提交时，你应当强制将脏页面转到磁盘，比如将页面写出（这是<code>FORCE</code>)</li></ul><p>为了进一步简化你的工作，你可以认为SimpleDB将不会崩溃当处理<code>transactionComplete</code>命令时。请注意这三点意味着你不需要实现基于日志的恢复机制在本Lab中，既然你永远不需要撤销任何工作（你不会驱逐脏页面）并且你永远不需要重做任何工作（你会在提交时强制更新而且并不会在提交过程中崩溃）</p><h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><h2 id="Granting-Locks"><a href="#Granting-Locks" class="headerlink" title="Granting Locks"></a>Granting Locks</h2><p>您需要向SimpleDB添加调用（例如，在<code>BufferPool</code>中），允许调用者代表特定事务<strong>请求或释放</strong>对特定对象的（共享或排他）锁。</p><p>我们建议以<code>page</code>为粒度进行锁定；出于测试简化的原因，请不要实现表级锁定（尽管这是可能的）。本文档的其余部分和我们的单元测试假定是<code>page</code>级锁定。</p><p>您将需要创建<strong>数据结构</strong>来跟踪每个事务持有的锁，并在请求时检查是否应授予事务锁。</p><p>您将需要实现<strong>共享锁和互斥锁</strong>；请注意，它们的工作方式如下：</p><ul><li>在事务读取对象之前，必须对其具有共享锁。</li><li>在事务写入对象之前，必须对其具有互斥锁。</li><li>多个事务可以对一个对象持有共享锁。</li><li>只有一个事务可以对一个对象持有互斥锁。</li><li>如果事务<code>t</code>是唯一持有对象<code>o</code>上的共享锁的事务，则<code>t</code>可以将其在<code>o</code>上的锁升级为互斥锁。</li></ul><p>如果事务请求一个不能立即授予的锁，您的代码应该阻塞，等待该锁变得可用（即由在不同线程中运行的另一个事务释放）。在锁的实现中小心竞态条件 — 考虑并发调用锁可能如何影响行为。（您可能希望阅读有关Java中的同步的资料）。</p><hr><h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a><strong>Exercise 1</strong></h2><p>编写在<code>BufferPool</code>中获取和释放锁的方法。假设使用的是页面级锁定，则需要完成以下工作：</p><ul><li>修改 <code>getPage()</code> 方法，在返回页面之前阻塞并获取所需的锁。 </li><li>实现 <code>unsafeReleasePage()</code> 方法。该方法主要用于测试和事务结束时。</li><li>实现 <code>holdsLock()</code> 方法，以便 Exercise 2 中的逻辑可以确定页面是否已被事务锁定。</li></ul><p>您可能会发现定义一个 <code>LockManager</code> 类有助于维护有关事务和锁的状态，但设计决策由您决定。 在您的代码通过 <code>LockingTest</code> 单元测试之前，您可能需要实现下一个练习。</p><hr><h2 id="Lock-Lifetime"><a href="#Lock-Lifetime" class="headerlink" title="Lock Lifetime"></a>Lock Lifetime</h2><p>你需要实现严格的两阶段（Strick 2PL）锁定。这意味着在访问对象之前，事务应该在该对象上获取适当类型的锁，并且在事务<strong>提交之前</strong>不应该释放任何锁。</p><p>幸运的是，SimpleDB 的设计使得在 <code>BufferPool.getPage()</code> 中可以在读取或修改页面之前获取页面上的锁定。因此，我们建议在 <code>getPage()</code> 中获取锁，而不是在每个操作符中添加锁定例程的调用。根据你的实现，可能你不必在其他地方获取锁。这取决于你来验证！</p><p>在读取任何页面（或元组）之前，你需要获取共享锁，并在写入任何页面（或元组）之前，你需要获取独占锁。你会注意到在 BufferPool 中我们已经传递了 <code>Permissions</code> 对象；这些对象指示调用方希望对所访问的对象获得的锁的类型（我们已经为 <code>Permissions</code> 类提供了代码）。</p><p>注意，<code>HeapFile.insertTuple()</code> 和 <code>HeapFile.deleteTuple()</code> 的实现，以及由 <code>HeapFile.iterator()</code> 返回的迭代器的实现应该使用 <code>BufferPool.getPage()</code> 访问页面。仔细检查<code>getPage()</code> 的这些不同用法是否传递了正确的权限对象（例如，<code>Permissions.READ_WRITE</code> 或 <code>Permissions.READ_ONLY</code>）。你可能还希望仔细检查 BufferPool.insertTuple() 和 BufferPool.deleteTupe() 的实现，确保它们在访问的任何页面上调用 <code>markDirty()</code>（在实现此代码时，你应该已经这样做了，但我们没有测试这种情况）。</p><p>在获取了锁之后，你需要考虑何时释放它们。显然，你应该在事务提交或中止后释放与事务关联的所有锁，以确保严格的两阶段锁定。然而，在事务结束之前释放锁可能会在其他情况下也是有用的。例如，你可能在扫描页面以查找空槽后释放对页面的共享锁（如下所述）。</p><hr><h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a><strong>Exercise 2</strong></h2><p>确保在整个SimpleDB中获取和释放锁。有一些（但不一定是全部）你应该验证是否正常工作的操作包括：</p><ul><li>在 SeqScan 过程中从页面上读取元组（如果你在 <code>BufferPool.getPage()</code> 中实现了锁定，只要你的 <code>HeapFile.iterator()</code> 使用 <code>BufferPool.getPage()</code>，这应该可以正确工作）。</li><li>通过 BufferPool 和 HeapFile 方法插入和删除元组（如果你在 <code>BufferPool.getPage()</code> 中实现了锁定，只要 <code>HeapFile.insertTuple()</code> 和 <code>HeapFile.deleteTuple()</code> 使用 <code>BufferPool.getPage()</code>，这应该可以正确工作）。</li></ul><p>你还需要特别考虑在以下情况下获取和释放锁：</p><ul><li>向 <code>HeapFile</code> 添加新页面。何时将页面实际写入磁盘？是否存在与其他事务（在其他线程上）的竞争条件，可能需要在 <code>HeapFile</code> 层面上特别关注，而不考虑页面级别的锁定？</li><li>寻找可以插入元组的空槽。大多数实现会扫描页面以查找空槽，并且将需要使用 READ_ONLY 锁来执行此操作。然而，令人惊讶的是，如果事务 t 在页面 p 上找不到空槽，t 可能会立即释放对 p 的锁。尽管这显然违反了两阶段锁定的规则，但这是可以接受的，因为 t 没有使用页面的任何数据，因此并发事务 t’ 更新 p 不能影响 t 的答案或结果。</li></ul><p>到目前为止，你的代码应该能够通过<code>LockingTest</code>中的单元测试。</p><hr><h2 id="Implementing-NO-STEAL"><a href="#Implementing-NO-STEAL" class="headerlink" title="Implementing NO STEAL"></a>Implementing NO STEAL</h2><p>事务的修改只有在提交后才会被写入磁盘。这意味着我们可以通过丢弃脏页并从磁盘重新读取它们来中止事务。因此，我们不能淘汰脏页。这种策略称为“NO STEAL”。</p><p>你需要修改<code>BufferPool</code>中的<code>evictPage</code>方法。特别是，它绝不能淘汰脏页。如果你的淘汰策略更喜欢淘汰脏页，你将不得不找到一种淘汰备用页面的方法。在缓冲池中的所有页面都是脏的情况下，你应该抛出一个DbException。如果你的淘汰策略淘汰了一个干净的页面，请注意事务可能已经持有对被淘汰页面的任何锁，并在实现中适当地处理它们。</p><h2 id="Exercise3"><a href="#Exercise3" class="headerlink" title="Exercise3"></a><strong>Exercise3</strong></h2><p>在 <code>BufferPool</code> 的 <code>evictPage</code> 方法中实现必要的页面驱逐逻辑，而不驱逐脏页面。</p><hr><h2 id="Transactions-1"><a href="#Transactions-1" class="headerlink" title="Transactions"></a>Transactions</h2><p>在SimpleDB中，每个查询开始时都会创建一个<code>TransactionId</code>对象。这个对象被传递给参与查询的每个操作符。当查询完成时，会调用<code>BufferPool</code>方法<code>transactionComplete</code>。</p><p>调用这个方法将根据参数flag <code>commit</code>来<code>提交或中止</code>事务。在执行过程中，运算符可以在任何时候抛出<code>TransactionAbortedException</code>异常，表示发生了内部错误或死锁。我们为您提供的测试用例会创建适当的<code>TransactionId</code>对象，以适当的方式将它们传递给您的运算符，并在查询完成时调用<code>transactionComplete</code>。我们还实现了<code>TransactionId</code>。</p><hr><h2 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a><strong>Exercise 4</strong></h2><p>在<code>BufferPool</code>中实现<code>transactionComplete()</code>方法。请注意，有两个版本的<code>transactionComplete</code>，一个接受额外的布尔型参数<code>commit</code>，另一个不接受。没有额外参数的版本应该始终提交，因此可以通过调用<code>transactionComplete(tid, true)</code>来简单实现。</p><ul><li>在提交时，你应该将与事务关联的脏页刷新到磁盘。</li><li>在中止时，你应该通过将页面恢复到其磁盘状态来撤销事务所做的任何更改。</li></ul><p>无论事务是提交还是中止，你还应该释放<code>BufferPool</code>保留的有关事务的任何状态，包括释放事务持有的任何锁。</p><p>在此时，你的代码应该能够通过<code>TransactionTest</code>单元测试和<code>AbortEvictionTest</code>系统测试。你可能会发现<code>TransactionTest</code>系统测试很有启发性，但在完成下一个练习之前，它可能会失败。</p><hr><h2 id="Deadlocks-and-Aborts"><a href="#Deadlocks-and-Aborts" class="headerlink" title="Deadlocks and Aborts"></a>Deadlocks and Aborts</h2><p>在SimpleDB中，事务发生死锁是可能的（如果你不了解为什么，我们建议阅读Ramakrishnan＆Gehrke中关于死锁的内容）。你需要检测这种情况并抛出<code>TransactionAbortedException</code>异常。</p><p>有许多可能的方法来检测死锁。一个初步的例子是实现一个简单的超时策略，如果事务在一定时间内没有完成，则中止它。对于一个真实的解决方案，你可以在依赖图数据结构中实现循环检测，就像在讲座中所示。在这种方案中，你会定期或每当尝试授予新锁时检查依赖图中是否存在循环，并在存在循环时中止某些事务。在检测到死锁存在后，你必须决定如何改善情况。假设在事务t等待锁时检测到死锁。如果你愿意放弃一切，你可能会中止t正在等待的所有事务；这可能导致大量工作被撤销，但你可以保证t将取得进展。或者，你可能决定中止t，以便让其他事务有机会取得进展。这意味着最终用户将不得不重试事务t。</p><p>另一种方法是使用事务的全局顺序来避免构建等待图。出于性能原因，有时这种方法更受欢迎，但在该方案下，可能会错误地中止本可以成功的事务。其中一些例子包括<code>WAIT-DIE</code>和<code>WOUND-WAIT</code>方案。</p><hr><h2 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h2><p>在<code>src/simpledb/BufferPool.java</code>中实现死锁检测或预防。关于死锁处理系统，你有许多设计决策的选择，但不一定需要做得非常复杂。我们期望你的设计比每个事务的简单超时要好。一个良好的起点是在每个锁请求之前实现在等待图中的循环检测，对于这样的实现，你将获得全部学分。请在实验报告中描述你的选择，并列出与其他选择相比的优缺点。</p><p>你的代码应该能够在发生死锁时通过抛出 <code>TransactionAbortedException</code> 来正确中止事务。这个异常会被执行事务的代码捕获（例如，<code>TransactionTest.java</code>），该代码应该调用 <code>transactionComplete()</code> 来在事务中进行清理。你不需要自动重新启动由于死锁而失败的事务 - 你可以假设更高级别的代码将处理这个问题。</p><p>我们在 <code>test/simpledb/DeadlockTest.java</code> 中提供了一些（不太单元的）测试。它们实际上有点复杂，所以可能需要一些时间来运行（取决于你的策略）。如果它们似乎无限期地挂起，那么你可能有一个未解决的死锁。这些测试构建了简单的死锁情况，你的代码应该能够成功解除死锁。</p><p>请注意，<code>DeadLockTest.java</code> 文件顶部有两个时间参数；它们确定测试检查锁是否被获取的频率以及中止事务重新启动之前的等待时间。如果你使用基于超时的检测方法，可以通过调整这些参数来观察不同的性能特征。测试将在控制台上输出与已解决的死锁相对应的 <code>TransactionAbortedException</code>。</p><p>你的代码现在应该能够通过 <code>TransactionTest</code> 系统测试（根据你的实现可能会运行相当长的时间）。</p><p>在这一点上，你应该拥有一个可恢复的数据库，即如果数据库系统崩溃（除了 <code>transactionComplete()</code> 外的任何时候）或者用户明确中止一个事务，任何正在运行的事务的效果在系统重新启动后（或事务中止后）将不可见。你可以通过运行一些事务并显式关闭数据库服务器来验证这一点。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>本实验需要实现数据库的并发控制。<br>锁的类型：实验只需要实现共享锁X和排他锁S<br>锁的粒度：实验测试是基于<code>page</code>级别的，因此实现基于<code>page</code>的锁即可。</p><p>为了解耦，我们创建一个<code>LockManager</code>类来负责管理和分配所有的锁。需要注意<code>LockManager</code>应该设计成数据库级别还是数据库服务器级别。</p><p>在MySQL中，不同的数据库共享同一个<code>BufferPool</code>,因此<code>BufferPool</code>是数据库服务器级别的。而<code>LockManager</code>则是每个数据库单独的，这是因为可能不同数据库的隔离级别有差异。在本实验中，只涉及一个数据库，因此<code>LockManager</code>应当被设计为单例的，理应把<code>LockManager</code>实例放在<code>Database</code>类中，通过类似获取<code>BufferPool</code>的方式<code>Database.getBufferPool()</code>来获取<code>LockManager</code>实例。但由于测试代码调用<code>resetBufferPool</code>来重置<code>BufferPool</code>的时候不会重置<code>LockManager</code>，因此会导致构建测试数据@Before代码的锁无法释放，在后续测试中无法获得锁，导致无法通过测试。因此我们这里把<code>LockManager</code>作为<code>BufferPool</code>的成员变量，这样在重置<code>BufferPool</code>时，也能够通过构造函数来重置<code>LockManager</code>来释放@Before时获取的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forget about locks associated to tid, so they don&#x27;t conflict with  </span></span><br><span class="line"><span class="comment">// test cases  </span></span><br><span class="line">bp.getPage(tid, p0, Permissions.READ_WRITE).markDirty(<span class="literal">true</span>, tid);  </span><br><span class="line">bp.getPage(tid, p1, Permissions.READ_WRITE).markDirty(<span class="literal">true</span>, tid);  </span><br><span class="line">bp.getPage(tid, p2, Permissions.READ_WRITE).markDirty(<span class="literal">true</span>, tid);  </span><br><span class="line">bp.flushAllPages();  </span><br><span class="line">bp = Database.resetBufferPool(BufferPool.DEFAULT_PAGES);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BufferPool <span class="title function_">resetBufferPool</span><span class="params">(<span class="type">int</span> pages)</span> &#123;  </span><br><span class="line">        java.lang.reflect.Field bufferPoolF=<span class="literal">null</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            bufferPoolF = Database.class.getDeclaredField(<span class="string">&quot;_bufferpool&quot;</span>);  </span><br><span class="line">            bufferPoolF.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">            bufferPoolF.set(_instance.get(), <span class="keyword">new</span> <span class="title class_">BufferPool</span>(pages));  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException | IllegalArgumentException | SecurityException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line"><span class="comment">//        _instance._bufferpool = new BufferPool(pages);  </span></span><br><span class="line">        <span class="keyword">return</span> _instance.get()._bufferpool;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="PageLock实现"><a href="#PageLock实现" class="headerlink" title="PageLock实现"></a>PageLock实现</h2><p><code>PageLock</code>只被用在<code>LockManager</code>内部，因此可以设计成内部私有类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PageLock</span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> LockType type;  </span><br><span class="line">    <span class="keyword">private</span> PageId pageId;  </span><br><span class="line">    <span class="keyword">private</span> TransactionId tid;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageLock</span><span class="params">(LockType type, PageId pageId, TransactionId tid)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.type = type;  </span><br><span class="line">        <span class="built_in">this</span>.pageId = pageId;  </span><br><span class="line">        <span class="built_in">this</span>.tid = tid;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateToXLock</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.type = LockType.XLOCK;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> LockType <span class="title function_">getType</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> type;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> PageId <span class="title function_">getPageId</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> pageId;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> TransactionId <span class="title function_">getTid</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> tid;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> Objects.hash(tid, pageId);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj)&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> PageLock))&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="type">PageLock</span> <span class="variable">p1</span> <span class="operator">=</span> (PageLock) obj;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.pageId.equals(p1.pageId) &amp;&amp; <span class="built_in">this</span>.tid.equals(p1.tid);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>PageLock</code>重写<code>hashCode()</code>和<code>equals()</code>时，不可以涉及到<code>LockType</code>属性。因为共享锁可能会升级为排他锁导致<code>LockType</code>发生改变，因此它的<code>hashCode</code>也会随之改变，和它被最初<code>add</code>到<code>hashSet</code>时的<code>hashCode</code>不同，导致之后无法通过<code>set.remove()</code>方法删除该锁，从而释放锁。具体原理请参照<code>Set</code>的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Constants used for LockType */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">LockType</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;  </span><br><span class="line">    XLOCK,SLOCK;  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == XLOCK)  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;XLOCK&quot;</span>;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == SLOCK)  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;SLOCK&quot;</span>;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;impossible to reach here&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LockManager实现"><a href="#LockManager实现" class="headerlink" title="LockManager实现"></a>LockManager实现</h2><p>首先需要明确锁-页面-事务之间的关系。一个事务可以持有多个锁，一个页面也可以被多个锁锁定(共享锁)。因此事务和锁是一对多关系。页面和锁也是一对多关系。那么维护两个映射：</p><ul><li><code>TransactionId-&gt;Set&lt;PageLock&gt;</code>：事务和事务持有的锁集合。</li><li><code>PageId-&gt;Set&lt;PageLock&gt;</code>：页面和作用于该页面上的锁集合。</li></ul><p>主要需要实现如下方法：</p><ul><li>授予锁：某事务需要获取某页面上的锁。<ol><li>先判断该事务是否已经有该页面上的锁<ol><li>有，则判断锁类型是否符合<ol><li>不符合，尝试升级为排他锁</li><li>符合，返回true</li></ol></li><li>无，则尝试获取锁，判断该页面上是否被其他锁锁定。<ol><li>被排他锁锁定，返回false</li><li>被共享锁锁定，判断获取锁类型</li><li>无锁，返回true</li></ol></li></ol></li></ol></li><li>释放特定事务持有的锁：当事务提交后，需要释放该事务持有的所有锁。通过<code>TransactionId-&gt;Set&lt;PageLock&gt;</code>的映射，获取所有该事务申请的锁，从而释放。这就是2PL阶段的第二阶段。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockManager</span> &#123;  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * PageId -&gt; set of pageLocks */</span><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;PageId, HashSet&lt;PageLock&gt;&gt; pid2Locks;  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * TransactionId -&gt; set of pageLocks,i.e All locks hold by one transaction */</span><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;TransactionId,HashSet&lt;PageLock&gt;&gt; tid2Locks; </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LockManager</span><span class="params">()</span> &#123;  </span><br><span class="line">        pid2Locks = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();  </span><br><span class="line">        tid2Locks = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * Release lock on the specific page     * <span class="doctag">@param</span> pageId pid of page  </span></span><br><span class="line"><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">(PageId pageId,TransactionId tid)</span>&#123;  </span><br><span class="line">        <span class="type">PageLock</span> <span class="variable">lock</span> <span class="operator">=</span> getLockByPidAndTid(tid, pageId);  </span><br><span class="line">        <span class="keyword">if</span> (lock!=<span class="literal">null</span>)&#123;  </span><br><span class="line">            HashSet&lt;PageLock&gt; pageLocks = pid2Locks.get(pageId);  </span><br><span class="line">            HashSet&lt;PageLock&gt; tidLocks = tid2Locks.get(tid);  </span><br><span class="line">            pageLocks.remove(lock);  </span><br><span class="line">            tidLocks.remove(lock);  </span><br><span class="line">            <span class="keyword">if</span> (pageLocks.isEmpty())&#123;  </span><br><span class="line">                pid2Locks.remove(pageId);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (tidLocks.isEmpty())&#123;  </span><br><span class="line">                tid2Locks.remove(tid);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="built_in">this</span>.notifyAll();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * Release all lock hold by the transaction     * <span class="doctag">@param</span> tid tid of transaction  </span></span><br><span class="line"><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">releaseByTid</span><span class="params">(TransactionId tid)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (tid2Locks.containsKey(tid))&#123;  </span><br><span class="line">            HashSet&lt;PageLock&gt; tidLocks = tid2Locks.get(tid);  </span><br><span class="line">            <span class="keyword">for</span> (PageLock lock : tidLocks) &#123;  </span><br><span class="line">                <span class="type">PageId</span> <span class="variable">pageId</span> <span class="operator">=</span> lock.getPageId();  </span><br><span class="line">                <span class="keyword">if</span> (pid2Locks.containsKey(pageId))&#123;  </span><br><span class="line">                    HashSet&lt;PageLock&gt; pageLocks = pid2Locks.get(pageId);  </span><br><span class="line">                    pageLocks.remove(lock);  </span><br><span class="line">                    <span class="keyword">if</span> (pageLocks.isEmpty())&#123;  </span><br><span class="line">                        pid2Locks.remove(pageId);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="built_in">this</span>.notifyAll();  </span><br><span class="line">            tid2Locks.remove(tid);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">grantLock</span><span class="params">(TransactionId tid, PageId pageId, Permissions perm, <span class="type">int</span> retry)</span> <span class="keyword">throws</span> InterruptedException&#123;  </span><br><span class="line">        <span class="keyword">if</span> (retry == <span class="number">3</span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//holds the lock originally  </span></span><br><span class="line">        <span class="type">PageLock</span> <span class="variable">lock</span> <span class="operator">=</span> getLockByPidAndTid(tid, pageId);  </span><br><span class="line">        <span class="keyword">if</span> (lock!=<span class="literal">null</span>)&#123;  </span><br><span class="line">            <span class="keyword">if</span> (perm == Permissions.READ_ONLY)&#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (perm == Permissions.READ_WRITE)&#123;  </span><br><span class="line">                <span class="keyword">if</span> (lock.getType().equals(LockType.XLOCK))&#123;  </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (lock.getType().equals(LockType.SLOCK))&#123;  </span><br><span class="line">                    <span class="comment">// try to update lock  </span></span><br><span class="line">                    HashSet&lt;PageLock&gt; locksByPid = pid2Locks.get(pageId);  </span><br><span class="line">                    <span class="keyword">if</span> (locksByPid!=<span class="literal">null</span>&amp;&amp;locksByPid.size()==<span class="number">1</span>)&#123;  </span><br><span class="line">                        <span class="comment">// update to XLock  </span></span><br><span class="line">                        lock.updateToXLock();  </span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;                    &#125;  </span><br><span class="line">                    wait(<span class="number">50</span>);  </span><br><span class="line">                    <span class="keyword">return</span> grantLock(tid,pageId,perm,retry+<span class="number">1</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//try to acquire a lock  </span></span><br><span class="line">        <span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">if</span> (canLockPage(pageId,perm))&#123;  </span><br><span class="line">                <span class="type">PageLock</span> <span class="variable">pageLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageLock</span>(perm == Permissions.READ_ONLY ? LockType.SLOCK : LockType.XLOCK, pageId, tid);  </span><br><span class="line">                HashSet&lt;PageLock&gt; pageLockSet = pid2Locks.getOrDefault(pageId, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());  </span><br><span class="line">                HashSet&lt;PageLock&gt; tidLockSet = tid2Locks.getOrDefault(tid, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());  </span><br><span class="line">                pageLockSet.add(pageLock);  </span><br><span class="line">                tidLockSet.add(pageLock);  </span><br><span class="line">                pid2Locks.put(pageId,pageLockSet);  </span><br><span class="line">                tid2Locks.put(tid,tidLockSet);  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                wait(<span class="number">50</span>);  </span><br><span class="line">                <span class="keyword">return</span> grantLock(tid,pageId,perm,retry+<span class="number">1</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> PageLock <span class="title function_">getLockByPidAndTid</span><span class="params">(TransactionId tid,PageId pageId)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.tid2Locks.containsKey(tid))&#123;  </span><br><span class="line">            HashSet&lt;PageLock&gt; locks = <span class="built_in">this</span>.tid2Locks.get(tid);  </span><br><span class="line">            <span class="keyword">for</span> (PageLock pageLock : locks) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (pageLock.getPageId().equals(pageId))&#123;  </span><br><span class="line">                    <span class="keyword">return</span> pageLock;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">canLockPage</span><span class="params">(PageId pageId,Permissions perm)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.pid2Locks.containsKey(pageId))&#123;  </span><br><span class="line">            HashSet&lt;PageLock&gt; pageLocks = <span class="built_in">this</span>.pid2Locks.get(pageId);  </span><br><span class="line">            <span class="keyword">if</span> (!pageLocks.isEmpty() &amp;&amp; perm == Permissions.READ_WRITE)&#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">for</span> (PageLock pageLock : pageLocks) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (pageLock.type.equals(LockType.XLOCK))&#123;  </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (perm == Permissions.READ_ONLY)&#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">holdsLock</span><span class="params">(TransactionId tid,PageId pageId)</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> getLockByPidAndTid(tid,pageId) != <span class="literal">null</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 数据库 </category>
          
          <category> MIT6.830 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.830-Lab3</title>
      <link href="/posts/3de20a60/"/>
      <url>/posts/3de20a60/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在这个实验中，您将在 SimpleDB 的基础上实现一个查询优化器。主要任务包括实现一个选择性估算框架和一个基于成本的优化器。您在具体实现方面有一定的自由度，但我们建议使用类似于课堂上讨论的 Selinger 基于成本的优化器（第9讲）。</p><p>本文档的其余部分描述了添加优化器支持所涉及的内容，并提供了如何进行的基本概述。</p><p>与之前的实验一样，我们建议您尽早开始。</p><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><ul><li>实现 <code>TableStats</code> 类中的方法，使其能够使用直方图（为 <code>IntHistogram</code> 类提供了框架）或您设计的其他形式的统计信息，估算过滤器的选择性和扫描成本。</li><li>实现 <code>JoinOptimizer</code> 类中的方法，使其能够估算连接的成本和选择性。</li><li>编写 <code>JoinOptimizer</code> 中的 <code>orderJoins</code> 方法。该方法必须针对一系列连接（可能使用 <code>Selinger</code> 算法），根据在前两个步骤中计算的统计信息生成最佳的连接顺序。</li></ul><h1 id="优化大纲"><a href="#优化大纲" class="headerlink" title="优化大纲"></a>优化大纲</h1><p>请记住，基于成本的优化器的主要思想是：</p><ul><li>利用关于表的统计信息来估算不同查询计划的“成本”。通常，计划的成本与中间连接和选择所产生的元组数量（基数），以及过滤和连接谓词的选择性相关。</li><li>利用这些统计信息以最佳方式对连接和选择进行排序，并从多个备选的连接算法中选择最佳实现。 在这个实验中，您将实现代码来执行这两个功能。</li></ul><p>优化器将从 <code>simpledb/Parser.java</code> 中调用。在开始本实验之前，您可能需要回顾一下<code>实验 2</code> 中的解析器练习。简而言之，如果你有一个描述表的目录文件 <code>catalog.txt</code>，你可以通过键入以下内容运行解析器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar dist/simpledb.jar parser catalog.txt</span><br></pre></td></tr></table></figure><p>调用解析器时，它将计算所有表的统计数据（使用您提供的统计代码）。当发出查询时，解析器会将查询转换为逻辑计划表示，然后调用查询优化器生成最优计划。</p><h2 id="优化器结构"><a href="#优化器结构" class="headerlink" title="优化器结构"></a>优化器结构</h2><p>在开始实施之前，您需要了解 SimpleDB 优化器的整体结构。SimpleDB 模块的<code>parser</code>和<code>optimizer</code>的整体控制流程如图 1 所示。</p><p><img src="/../../../../img/Pasted%20image%2020240201113135.png"></p><p>底部的键解释了这些符号；您将实现双边框的组件。在接下来的文本中，将更详细地解释类和方法（您可能希望参考这个图表），但基本操作如下：</p><ul><li>当<code>Parser.java</code>初始化时，它构造了一组表统计信息（存储在<code>statsMap</code>容器中）。然后，它等待输入查询，并在该查询上调用<code>parseQuery</code>方法。 </li><li><code>parseQuery</code>首先构造了一个表示解析查询的<code>LogicalPlan</code>。然后，<code>parseQuery</code>调用<code>LogicalPlan</code>实例上的<code>physicalPlan</code>方法。<code>physicalPlan</code>方法返回一个<code>DBIterator</code>对象，可用于实际运行查询。</li></ul><p>在即将进行的练习中，您将实现帮助<code>physicalPlan</code>设计最佳计划的方法。</p><h2 id="统计估算"><a href="#统计估算" class="headerlink" title="统计估算"></a>统计估算</h2><p>准确估算计划成本是相当棘手的。在这个实验中，我们将仅关注连接顺序和基表访问的成本。我们不会考虑访问方法的选择（因为我们只有一种访问方法，即表扫描）或其他运算符（如聚合）的成本。</p><p>在这个实验中，您只需要考虑左深度计划。有关额外的“奖励”优化器功能的描述，请参见第2.3节，其中包括您可以实现的处理杂乱计划的方法。</p><h3 id="整体计划成本"><a href="#整体计划成本" class="headerlink" title="整体计划成本"></a>整体计划成本</h3><p>我们将会编写<code>join</code>计划，以如下的形式<code>p=t1 join t2 join ... tn</code>。它表示一个左深连接。其中<code>t1</code>是最左边的连接（树中最深的连接）。给定一个如<code>p</code>的计划，其成本可以表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scancost(t1) + scancost(t2) + joincost(t1 join t2) +</span><br><span class="line">scancost(t3) + joincost((t1 join t2) join t3) +</span><br><span class="line">... </span><br></pre></td></tr></table></figure><p>这里，<code>scancost(t1)</code>表示扫描表<code>t1</code>的I&#x2F;O成本，<code>joincost(t1, t2)</code>表示将<code>t1</code>与<code>t2</code>连接的CPU成本。为了使I&#x2F;O和CPU成本可比较，通常会使用一个常数缩放因子，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cost(predicate application) = 1</span><br><span class="line">cost(pageScan) = SCALING_FACTOR x cost(predicate application)</span><br></pre></td></tr></table></figure><p>在这个实验中，您可以忽略缓存效应（例如，假设对表的每次访问都会产生完整的扫描成本）——同样，这是您可以在第2.3节中作为实验的可选奖励扩展添加的内容。因此，<code>scancost(t1)</code>简单地是<code>t1</code>中页面的数量 <code>x SCALING_FACTOR</code>。</p><h3 id="连接成本"><a href="#连接成本" class="headerlink" title="连接成本"></a>连接成本</h3><p>在使用嵌套循环连接时，请记住两个表 t1 和 t2（其中 t1 是外层表）之间的连接成本很简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">joincost(t1 join t2) = scancost(t1) + ntups(t1) x scancost(t2) //IO cost</span><br><span class="line">                       + ntups(t1) x ntups(t2)  //CPU cost</span><br></pre></td></tr></table></figure><p>这里，<code>ntups(t1)</code>是表<code>t1</code>中的<code>tuples</code>数量。</p><h3 id="过滤器的选择性"><a href="#过滤器的选择性" class="headerlink" title="过滤器的选择性"></a>过滤器的选择性</h3><p><code>ntups</code> 可以通过扫描基表直接计算。对于具有一个或多个选择谓词的表来估算 <code>ntups</code> 可能会更加棘手 — 这是<em>过滤选择性估算</em>的问题。以下是您可能采用的一种方法，基于在表中的值上计算直方图：</p><ul><li><p>计算表中每个属性的最小值和最大值（通过一次扫描实现）。 </p></li><li><p>为表中的每个属性构建直方图。一种简单的方法是使用固定数量的桶（NumB），每个桶代表直方图属性域中固定范围内的记录数量。例如，如果字段 f 范围从 1 到 100，且有 10 个桶，那么桶 1 可能包含记录数，其值在 1 到 10 之间，桶 2 包含记录数，在 11 到 20 之间，依此类推。 </p></li><li><p>再次扫描表，选择所有元组的所有字段，并使用它们来填充每个直方图的桶计数。 </p></li><li><p>要估算相等表达式 f&#x3D;const 的选择性，请计算包含值 const 的桶。假设桶的宽度（值范围）为 w，高度（元组数量）为 h，表中的元组数量为 ntups。然后，假设值在整个桶中均匀分布，表达式的选择性大致为 (h &#x2F; w) &#x2F; ntups，因为 (h&#x2F;w) 代表具有值 const 的桶中的预期元组数量。 </p></li><li><p>要估算范围表达式 f&gt;const 的选择性，请计算包含 const 的桶 b，其宽度为 w_b，高度为 h_b。然后，b 包含总元组的分数 b_f &#x3D; h_b &#x2F; ntups。假设元组在 b 中均匀分布，则 b 中 &gt; const 的部分 b_part 为 (b_right - const) &#x2F; w_b，其中 b_right 是 b 桶的右端点。因此，桶 b 对谓词贡献了 (b_f x b_part) 的选择性。此外，桶 b+1…NumB-1 贡献了它们所有的选择性（可以使用类似于 b_f 的公式计算）。将所有桶的选择性贡献相加将得到表达式的整体选择性。图 2 阐明了这个过程。 </p></li><li><p>涉及小于的表达式的选择性可以类似于大于的情况，查看从 0 开始的桶。</p></li></ul><p><img src="/../../../../img/Pasted%20image%2020240201152356.png"></p><p>在接下来的两个练习中，您将用代码来执行连接和筛选器的选择性估计。</p><hr><h3 id="Exercise-1-IntHistogram-java"><a href="#Exercise-1-IntHistogram-java" class="headerlink" title="Exercise 1: IntHistogram.java"></a><strong>Exercise 1: IntHistogram.java</strong></h3><p>你需要实现某种记录表统计信息以进行选择性估算的方法。我们提供了一个骨架类 <code>IntHistogram</code> 用于执行此操作。我们的意图是让你使用上述描述的基于桶的方法来计算直方图，但只要提供合理的选择性估算，你可以自由选择其他方法。</p><p>我们提供了一个名为 <code>StringHistogram</code> 的类，它使用 <code>IntHistogram</code> 来计算字符串谓词的选择性。如果你希望实现更好的估算器，你可以修改 <code>StringHistogram</code>，尽管为完成此实验，你可能不需要这样做。</p><p>完成此练习后，你应该能够通过 <code>IntHistogramTest</code> 单元测试（如果选择不实现基于直方图的选择性估算，则不必通过此测试）。</p><hr><h3 id="Exercise-2-TableStats-java"><a href="#Exercise-2-TableStats-java" class="headerlink" title="Exercise 2: TableStats.java"></a><strong>Exercise 2: TableStats.java</strong></h3><p><code>TableStats</code>类包含一些计算表中元组和页数以及估算谓词在该表字段上的选择性的方法。我们已经创建的查询解析器为每个表创建一个<code>TableStats</code>实例，并将这些结构传递给你的查询优化器（在后续练习中会用到）。</p><p>你应该在TableStats中填充以下方法和类：</p><ol><li>实现<code>TableStats</code>构造函数：一旦你实现了跟踪直方图等统计信息的方法，就应该实现<code>TableStats</code>构造函数，添加代码来扫描表（可能多次）以构建你需要的统计信息。</li><li>实现<code>estimateSelectivity(int field, Predicate.Op op, Field constant)</code>：使用你的统计信息（例如，根据字段类型使用IntHistogram或StringHistogram），估算在表上对字段执行谓词操作<code>constant</code> 的选择性。</li><li>实现<code>estimateScanCost()</code>：此方法估算顺序扫描文件的成本，假设读取一页的成本是<code>costPerPageIO</code>。可以假设没有寻找，且没有页面在缓冲池中。该方法可能使用你在构造函数中计算的成本或大小。</li><li>实现estimateTableCardinality(double selectivityFactor)：此方法返回在应用具有选择性selectivityFactor的谓词时关系中的元组数量。该方法可能使用你在构造函数中计算的成本或大小。</li></ol><p>你可能需要修改<code>TableStats.java</code>的构造函数，例如，为了进行谓词选择性估算而计算字段上的直方图。</p><p>完成这些任务后，你应该能够通过<code>TableStatsTest</code>中的单元测试。</p><hr><h3 id="Join-Cardinality"><a href="#Join-Cardinality" class="headerlink" title="Join Cardinality"></a>Join Cardinality</h3><p>最后，注意到上述<code>join</code>计划 <code>p</code> 的成本包括形式为 <code>joincost((t1 join t2) join t3)</code>的表达式。要评估这个表达式，你需要一种估计 <code>t1 join t2</code>的大小（<code>ntups</code>）的方法。这个<code>join</code>基数估算问题比过滤选择性估算问题更为困难。在本实验中，你不需要为此做任何复杂的事情，尽管第2.4节中的一个可选练习包括基于直方图的联接选择性估算方法。</p><p>在实现简单解决方案时，你应该记住以下事项：</p><ul><li>对于等值连接，当其中一个属性是主键时，连接产生的元组数不能大于非主键属性的基数。</li><li>对于等值连接，当没有主键时，很难准确说输出的大小是多少，可能是表的基数的乘积的大小（如果两个表的所有元组都有相同的值）——或者可能是0。可以采用一个简单的启发式方法（例如，两个表中较大表的大小）。</li><li>对于范围扫描，关于大小准确说起来同样困难。输出的大小应与输入的大小成比例。可以假设范围扫描发出交叉乘积的固定分数（例如，30%）。通常情况下，范围连接的成本应大于两个大小相同的表的非主键等值连接的成本。</li></ul><h3 id="Exercise-3-Join-Cost-Estimation"><a href="#Exercise-3-Join-Cost-Estimation" class="headerlink" title="Exercise 3: Join Cost Estimation"></a><strong>Exercise 3: Join Cost Estimation</strong></h3><p> <code>JoinOptimizer.java</code> 类包含所有关于连接的排序和计算成本的方法。在这个练习中，你将编写用于估算连接选择性和成本的方法，具体包括：</p><ul><li>实现 <code>estimateJoinCost(LogicalJoinNode j, int card1, int card2, double cost1, double cost2)</code>：该方法估算连接 j 的成本，假设左输入的基数为 card1，右输入的基数为 card2，扫描左输入的成本为 cost1，访问右输入的成本为 cost2。你可以假设连接是一个NL连接，并应用前面提到的公式。</li><li>实现 <code>estimateJoinCardinality(LogicalJoinNode j, int card1, int card2, boolean t1pkey, boolean t2pkey)</code>：该方法估算连接 j 输出的元组数量，假设左输入的大小为 card1，右输入的大小为 card2，以及指示左和右字段是否唯一（分别是主键）的标志 t1pkey 和 t2pkey。</li></ul><p>完成这些方法的实现后，你应该能够通过 JoinOptimizerTest.java 中的单元测试 <code>estimateJoinCostTest</code> 和 <code>estimateJoinCardinality</code>。</p><h3 id="Join-Ordering"><a href="#Join-Ordering" class="headerlink" title="Join Ordering"></a><strong>Join Ordering</strong></h3><p>您已经实现了用于评估成本的方法，接下来你将要实现<code>Selinger optimizer</code>。对于这些方法，连接由一系列的<code>join nodes</code>来表达，比如两个表的谓词。而不是像课堂上描述的以连接关系的列表来表示。</p><p>将讲义中给出的算法转换成上述的连接节点列表形式，伪代码大纲就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> j = set of join nodes</span><br><span class="line"><span class="number">2.</span> <span class="keyword">for</span> (i in <span class="number">1.</span>..|j|):</span><br><span class="line"><span class="number">3.</span>     <span class="keyword">for</span> s in &#123;all length i subsets of j&#125;</span><br><span class="line"><span class="number">4.</span>       bestPlan = &#123;&#125;</span><br><span class="line"><span class="number">5.</span>       <span class="keyword">for</span> s<span class="string">&#x27; in &#123;all length d-1 subsets of s&#125;</span></span><br><span class="line"><span class="string">6.            subplan = optjoin(s&#x27;</span>)</span><br><span class="line"><span class="number">7.</span>            plan = best way to <span class="title function_">join</span> <span class="params">(s-s<span class="string">&#x27;) to subplan</span></span></span><br><span class="line"><span class="string"><span class="params">8.            if (cost(plan) &lt; cost(bestPlan))</span></span></span><br><span class="line"><span class="string"><span class="params">9.               bestPlan = plan</span></span></span><br><span class="line"><span class="string"><span class="params">10.      optjoin(s) = bestPlan</span></span></span><br><span class="line"><span class="string"><span class="params">11. return optjoin(j)</span></span></span><br></pre></td></tr></table></figure><p>为了帮助您实现这个算法，我们已经提供了几个类和方法来协助你。首先在<code>JoinOptimizer.java</code>中的<code>enumerateSubsets(List v,int size)</code>方法会返回一系列大小为<code>size</code>的<code>v</code>的子集。这个方法十分低效对于大规模的集合。你可以获得额外的学分通过实现更高效的<code>enumertor</code>（提示：考考虑使用in-place生成算法和懒迭代器或流接口来避免将整个幂集具体化）。</p><p>此外，我们能提供了如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CostCard <span class="title function_">computeCostAndCardOfSubplan</span><span class="params">(Map&lt;String, TableStats&gt; stats, </span></span><br><span class="line"><span class="params">                                               Map&lt;String, Double&gt; filterSelectivities, </span></span><br><span class="line"><span class="params">                                               LogicalJoinNode joinToRemove,  </span></span><br><span class="line"><span class="params">                                               Set&lt;LogicalJoinNode&gt; joinSet,</span></span><br><span class="line"><span class="params">                                               <span class="type">double</span> bestCostSoFar,</span></span><br><span class="line"><span class="params">                                               PlanCache pc)</span></span><br></pre></td></tr></table></figure><p>给定连接的子集（<code>joinSet</code>）和要从该集合中移除的连接（<code>joinToRemove</code>），此方法计算将<code>joinToRemove</code>连接到<code>joinSet - &#123;joinToRemove&#125;</code> 的最佳方式。它以<code>CostCard</code>对象的形式返回这个最佳方法，其中包括成本、基数和最佳连接顺序（作为列表）。如果computeCostAndCardOfSubplan返回null，可能是因为找不到计划（例如，因为没有可能的左深连接），或者所有计划的成本都大于<code>bestCostSoFar</code>参数。该方法使用称为<code>pc</code>（上述伪代码中的optjoin）的先前连接的缓存来快速查找连接<code>joinSet - &#123;joinToRemove&#125;</code>的最快方式。其他参数（<code>stats</code> 和 <code>filterSelectivities</code>）传递到你必须作为练习4的一部分实现的<code>orderJoins</code>方法中，并在下面进行解释。该方法基本上执行先前描述的伪代码的第6到8行。</p><p>接下来，我们提供了方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printJoins</span><span class="params">(List&lt;LogicalJoinNode&gt; js, </span></span><br><span class="line"><span class="params">                        PlanCache pc,</span></span><br><span class="line"><span class="params">                        Map&lt;String, TableStats&gt; stats,</span></span><br><span class="line"><span class="params">                        Map&lt;String, Double&gt; selectivities)</span></span><br></pre></td></tr></table></figure><p>这个方法可用于显示连接计划的图形表示（例如，当通过优化器的“-explain”选项设置“explain”标志时）。</p><p>第四，我们提供了一个名为<code>PlanCache</code>的类，它可以用于缓存到目前为止在你的<code>Selinger</code>实现中考虑的连接子集的最佳连接方式（使用<code>computeCostAndCardOfSubplan</code>需要此类的一个实例）。</p><hr><h3 id="Exercise-4-Join-Ordering"><a href="#Exercise-4-Join-Ordering" class="headerlink" title="Exercise 4: Join Ordering"></a><strong>Exercise 4: Join Ordering</strong></h3><p>在<code>JoinOptimizer.java</code>中实现方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;LogicalJoinNode&gt; <span class="title function_">orderJoins</span><span class="params">(Map&lt;String, TableStats&gt; stats, </span></span><br><span class="line"><span class="params">                   Map&lt;String, Double&gt; filterSelectivities,  </span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> explain)</span></span><br></pre></td></tr></table></figure><p>这个方法应该操作 <code>joins</code> 类成员，返回一个新的列表，指定连接应该执行的顺序。列表的第一个项指示左侧最底部的连接在左深计划中的位置。返回的列表中相邻的连接应该共享至少一个字段，以确保计划是左深的。其中，<code>stats</code> 是一个允许你查找查询的 <code>FROM</code> 列表中出现的给定表名的 <code>TableStats</code> 的对象。<code>filterSelectivities</code>允许你查找任何谓词在表上的选择性；它保证对于查询的 <code>FROM</code> 列表中的每个表名都有一个条目。最后，<code>explain</code> 指定你应该输出连接顺序的表示，用于信息目的。</p><p>你可能希望使用上述描述的辅助方法和类来帮助实现。大致而言，你的实现应该遵循上述伪代码，循环遍历子集大小、子集和子集的子计划，调用 <code>computeCostAndCardOfSubplan</code> 并构建一个 PlanCache 对象，用于存储执行每个子集连接的最小成本方式。</p><p>在实现了这个方法之后，你应该能够通过 <code>JoinOptimizerTest</code> 中的所有单元测试。你还应该通过系统测试 <code>QueryTest</code>。</p><h3 id="额外挑战"><a href="#额外挑战" class="headerlink" title="额外挑战"></a>额外挑战</h3><p>在本节中，我们将介绍几个可选练习，您可以通过这些练习获得额外学分。这些练习没有前面的练习那么明确，但可以让您有机会展示您对查询优化的掌握！请在报告中明确标出您选择完成的练习，并简要说明您的实施情况和结果（基准数据、经验报告等）。</p><hr><p>奖励练习。每项奖励最多可获得 5%的额外学分：</p><ul><li>添加代码来执行更先进的连接基数估计。而不是使用简单的启发式搜索来评估连接基数，设计一个更复杂的算法：<ul><li>一种方法是在每对表 t1 和 t2 中的每对属性 a 和 b 之间使用联合直方图。我们的想法是创建属性a的桶，并为每个 a桶中的桶 A 创建一个与 A 中的 a 值共同出现的 b 值直方图。</li><li>估计连接基数的另一种方法是假设较小表中的每个值都与较大表中的一个匹配值相对应。然后，连接选择性的计算公式为：<code>1 /(Max( num-distinct(t1，column1)</code>，<code>num-distinct(t2，column2)))</code>。这里，column1 和 column2 是连接的属性。连接的基数然后是 t1 和 t2 的基数乘以选择性的乘积。</li></ul></li><li>改进子集迭代器。我们的<code>enumerateSubsets</code>实现效率相当低，因为每次调用都会创建大量的Java对象。在这个附加练习中，您将提高enumerateSubsets的性能，以便系统可以在包含20个或更多连接的计划上执行查询优化（目前这样的计划需要几分钟甚至几小时来计算）。</li><li>考虑缓存的成本模型。用于估算扫描和连接成本的方法并未考虑缓存在缓冲池中的影响。您应该扩展成本模型以考虑缓存效果。由于多个连接同时运行，这是一个棘手的问题，因此可能难以预测每个连接将使用先前实现的简单缓冲池时将访问多少内存。</li><li>改进连接算法和算法选择。我们当前的成本估算和连接操作选择算法（请参见JoinOptimizer.java中的instantiateJoin()）仅考虑嵌套循环连接。扩展这些方法以使用一个或多个附加的连接算法（例如，使用HashMap进行内存哈希）。</li><li>丛生计划。改进提供的<code>orderJoins()</code>和其他辅助方法以生成丛生连接。我们的查询计划生成和可视化算法完全能够处理丛生计划；例如，如果<code>orderJoins()</code>返回列表（t1 join t2；t3 join t4；t2 join t3），则对应于一个具有(t2 join t3)节点在顶部的丛生计划。</li></ul><hr><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/../../../../img/Pasted%20image%2020240206203213.png"><br>查询优化器：优化器的目的是按照一定原则来得到她认为的目标SQL在当前情形下最有效的执行路径,优化器的目的是为了得到目标SQL的执行计划。</p><p>传统关系型数据库里面的优化器分为<strong>CBO</strong>和<strong>RBO</strong>两种。<br>**RBO— Rule_Based Potimizer基于规则的优化器:</p><p>RBO所用的判断规则是一组内置的规则，这些规则是硬编码在数据库的编码中的，RBO会根据这些规则去从SQL诸多的路径中来选择一条作为执行计划（比如在RBO里面，有这么一条规则：有索引使用索引。那么所有带有索引的表在任何情况下都会走索引）所以，RBO现在被很多数据库抛弃（oracle默认是CBO，但是仍然保留RBO代码，MySQL只有CBO）</p><p>RBO最大问题在于硬编码在数据库里面的一系列固定规则，来决定执行计划。并没有考虑目标SQL中所涉及的对象的实际数量，实际数据的分布情况，这样一旦规则不适用于该SQL，那么很可能选出来的执行计划就不是最优执行计划了。</p><p>**CBO—Cost_Based Potimizer基于成本的优化器:</p><p>CBO在会从目标诸多的执行路径中选择一个成本最小的执行路径来作为执行计划。这里的成本他实际代表了MySQL根据相关统计信息计算出来目标SQL对应的步骤的IO，CPU等消耗。也就是意味着数据库里的成本实际上就是对于执行目标SQL所需要IO,CPU等资源的一个估计值。而成本值是根据索引，表，行的统计信息计算出来的。(计算过程比较复杂)</p><p>本实验是基于CBO的，即评估成本。包括CPU，I&#x2F;O。Lab3主要针对SQL查询中的查询优化器部分实现。本实验仅需要实现<code>过滤选择性</code>和<code>连接成本</code>。</p><h2 id="构建直方图"><a href="#构建直方图" class="headerlink" title="构建直方图"></a>构建直方图</h2><p>构建直方图的思想是对于表的每个属性都基于属性的值建立一张直方图，并假设属性的取值尽可能均匀。以此来大致估算在某个谓词下，可能的过滤选择性值为多少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">estimateSelectivity</span><span class="params">(Predicate.Op op, <span class="type">int</span> v)</span> &#123;  </span><br><span class="line">    <span class="keyword">switch</span> (op)&#123;  </span><br><span class="line">        <span class="keyword">case</span> EQUALS:&#123;  </span><br><span class="line">            <span class="keyword">return</span> estimateEqual(v);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">case</span> GREATER_THAN:&#123;  </span><br><span class="line">            <span class="keyword">return</span> estimateGreat(v);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">case</span> LESS_THAN:&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>-(estimateSelectivity(Predicate.Op.GREATER_THAN_OR_EQ,v));  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">case</span> LESS_THAN_OR_EQ:&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>-estimateGreat(v);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">case</span> GREATER_THAN_OR_EQ:&#123;  </span><br><span class="line">            <span class="keyword">return</span> estimateGreat(v)+estimateEqual(v);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">case</span> LIKE:&#123;  </span><br><span class="line">            <span class="keyword">return</span> estimateEqual(v);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">case</span> NOT_EQUALS:&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span> - estimateEqual(v);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   <span class="comment">// some code goes here  </span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1.0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.bctNum; i++) &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> i== <span class="built_in">this</span>.bctNum-<span class="number">1</span>?<span class="built_in">this</span>.max-<span class="built_in">this</span>.min+<span class="number">1</span>-<span class="built_in">this</span>.interval*(<span class="built_in">this</span>.bctNum-<span class="number">1</span>):<span class="built_in">this</span>.interval;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="built_in">this</span>.min + i*interval;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + w -<span class="number">1</span>;  </span><br><span class="line">        sb.append(String.format(<span class="string">&quot;[%d,%d]:%d\n&quot;</span>,left,right,<span class="built_in">this</span>.backets[i]));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> sb.toString();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> <span class="title function_">estimateGreat</span><span class="params">(<span class="type">int</span> v)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (v&lt;<span class="built_in">this</span>.min)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (v&gt;=<span class="built_in">this</span>.max)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> vToIdx(v);  </span><br><span class="line">    <span class="comment">// to solve difference the width of last backet  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> idx == <span class="built_in">this</span>.bctNum-<span class="number">1</span>?<span class="built_in">this</span>.max-<span class="built_in">this</span>.min+<span class="number">1</span>-<span class="built_in">this</span>.interval*(<span class="built_in">this</span>.bctNum-<span class="number">1</span>):<span class="built_in">this</span>.interval;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="built_in">this</span>.backets[idx];  </span><br><span class="line">    <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> (v-<span class="built_in">this</span>.min)-idx*<span class="built_in">this</span>.interval;  </span><br><span class="line">    <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0.0</span>;  </span><br><span class="line">    res += ((w-mod-<span class="number">1</span>)/(w*<span class="number">1.0</span>)) * (h*<span class="number">1.0</span>)/(<span class="built_in">this</span>.total*<span class="number">1.0</span>);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx+<span class="number">1</span>; i &lt; <span class="built_in">this</span>.bctNum; i++) &#123;  </span><br><span class="line">        res += (<span class="built_in">this</span>.backets[i]*<span class="number">1.0</span>)/(<span class="built_in">this</span>.total*<span class="number">1.0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述实现假定某属性取值最大为<code>max</code>,最小为<code>min</code>，桶的数量为<code>bctNum</code>。因此每个桶的区间长度为<code>(max-min+1)/bctNum</code>。如果不能够整除，则最后一个桶的长度会比其他桶多<code>(max-min+1)/%bctNum</code>。比如<code>min=0,max=10,bctNum=3</code>则每个桶负责的区间依次为<code>[0,1,2],[3,4,5],[6,7,8,9,10]</code>。在实现的时候需要特别考虑数落到最后一个桶的情况。</p><p>不同的谓词实现技巧：比如大于号和小于等于号的关系。</p><h2 id="计算连接成本"><a href="#计算连接成本" class="headerlink" title="计算连接成本"></a>计算连接成本</h2><p>连接基数估计<br>连接基数估计是指在按某些谓词条件下<code>join</code>两个表时，结果中的行数估计值。显而易见，这个值应该不大于<code>M * N</code>，<code>M</code>和<code>N</code>分别指两表的行数。</p><ul><li>对于等值连接，即 <code>join on t1.field1=t2.field2</code>。如果<code>field1</code>或<code>field2</code>是主键，那么连接后的指不可能超过非主键表的数量。因为对于非主键表中的每条记录，在主键表中最多只有一条和他匹配。（因为主键不可能重复）。</li><li>对于等值连接，且都不是主键的情况。这种情况很难估计，采用了额外挑战中<code>1 /(Max( num-distinct(t1，column1)</code>，<code>num-distinct(t2，column2)))</code>的实现。这里<code>num-distinct</code>指表1中column1去重取值后的集合，也就是有多少个不同的取值。这个评估基于一个前提，认为该属性取每个值的数量是尽可能平衡的。那么对于另一个表中的每条记录，最多有<code>M/num-distinct(t1，column1)*N</code>条记录和它匹配。反之，如果以另一表作为基准，最多有<code>N/num-distinct(t2，column2)*M</code>。取两者的较小值作为评估值即可。（为什么取较小值，因为假设连接的数量为<code>res</code>，<code>res&lt;res1且res&lt;res2</code>即<code>res</code>小于两者较小值。）</li><li>对于非等值的连接，同样很难估计。输出的大小应该与输入的大小成正比。假设范围扫描会产生固定比例的交叉积（例如 **30%**）也是可以的。一般来说，范围连接的成本应该大于两个相同大小表的非主键相等连接的成本。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">estimateTableJoinCardinality</span><span class="params">(Predicate.Op joinOp,  </span></span><br><span class="line"><span class="params">                                               String table1Alias, </span></span><br><span class="line"><span class="params">                                               String table2Alias,String field1PureName,  </span></span><br><span class="line"><span class="params">                                               String field2PureName, </span></span><br><span class="line"><span class="params">                                               <span class="type">int</span> card1, <span class="type">int</span> card2,</span></span><br><span class="line"><span class="params">                                               <span class="type">boolean</span> t1pkey,<span class="type">boolean</span> t2pkey, </span></span><br><span class="line"><span class="params">                                               Map&lt;String, TableStats&gt; stats,  </span></span><br><span class="line"><span class="params">                                               Map&lt;String, Integer&gt; tableAliasToId)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">card</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line">    <span class="comment">// some code goes here  </span></span><br><span class="line">    <span class="keyword">if</span> (joinOp.equals(Predicate.Op.EQUALS))&#123;  </span><br><span class="line">        <span class="keyword">if</span> (t1pkey || t2pkey)&#123;  </span><br><span class="line">            <span class="keyword">if</span> (t1pkey &amp;&amp; !t2pkey)&#123;  </span><br><span class="line">                card = card2;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!t1pkey &amp;&amp; t2pkey)&#123;  </span><br><span class="line">                card = card1;  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                card = Math.min(card1,card2);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="comment">// improved method  </span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">tabldId1</span> <span class="operator">=</span> tableAliasToId.get(table1Alias);  </span><br><span class="line">            <span class="type">Integer</span> <span class="variable">tabldId2</span> <span class="operator">=</span> tableAliasToId.get(table2Alias);  </span><br><span class="line">            <span class="type">String</span> <span class="variable">tableName1</span> <span class="operator">=</span> Database.getCatalog().getTableName(tabldId1);  </span><br><span class="line">            <span class="type">String</span> <span class="variable">tableName2</span> <span class="operator">=</span> Database.getCatalog().getTableName(tabldId2);  </span><br><span class="line">            <span class="type">TableStats</span> <span class="variable">stats1</span> <span class="operator">=</span> stats.get(tableName1);  </span><br><span class="line">            <span class="type">TableStats</span> <span class="variable">stats2</span> <span class="operator">=</span> stats.get(tableName2);  </span><br><span class="line">            <span class="type">int</span> <span class="variable">distinct1</span> <span class="operator">=</span> stats1.getFieldDistinct(Database.getCatalog().getTupleDesc(tabldId1).fieldNameToIndex(field1PureName));  </span><br><span class="line">            <span class="type">int</span> <span class="variable">distinct2</span> <span class="operator">=</span> stats2.getFieldDistinct(Database.getCatalog().getTupleDesc(tabldId2).fieldNameToIndex(field2PureName));  </span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>)((card1 * card2 * <span class="number">1.0</span>)/(Math.max(distinct1,distinct2)));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Math.max((<span class="type">int</span>)(<span class="number">0.3</span>*(card1 * card2)),Math.max(card1,card2));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> card &lt;= <span class="number">0</span> ? <span class="number">1</span> : card;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算连接顺序"><a href="#计算连接顺序" class="headerlink" title="计算连接顺序"></a>计算连接顺序</h2><p>考虑到不同的连接顺序产生的成本不同。<br>比如<code>t1 join t2</code>的成本大致为：<br><code>card1 * card2 * 1.0 + cost1 + card1 * cost2</code><br>而<code>t2 join t1</code>的成本大致为：<br><code>card1 * card2 * 1.0 + cost2 + card2 * cost1</code><br>我们需要计算给定的查询计划中，可能的连接顺序成本最小的方案。这里通过DFS枚举了所有连接顺序，然后通过DP算法来计算每种连接次序所需的成本。假设对于需要<code>join</code>的三个节点<code>A,B,C</code>,我们如果知道了<code>A,B</code>连接（可能的其中一个子计划）具有最小成本的顺序为<code>AB</code>,那么只需要考虑<code>C(AB),(AB)C</code>，当然还需要考虑将<code>BC</code>或<code>AC</code>先连接的情况。我们称<code>AB,BC,AC</code>为子计划，将他们进行缓存，之后就可以快速得到<code>A和B</code>，<code>B和C</code>，<code>A和C</code>连接的最佳顺序。源文件提供了给定连接的子集（<code>joinSet</code>）和要从该集合中移除的连接（<code>joinToRemove</code>），此方法计算将<code>joinToRemove</code>连接到<code>joinSet - &#123;joinToRemove&#125;</code> 的最佳方式。上述的<code>C</code><br>节点在这是<code>joinToRemove</code>，<code>s</code>是指集合<code>&#123;A,B,C&#125;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;LogicalJoinNode&gt; <span class="title function_">orderJoins</span><span class="params">(  </span></span><br><span class="line"><span class="params">        Map&lt;String, TableStats&gt; stats,  </span></span><br><span class="line"><span class="params">        Map&lt;String, Double&gt; filterSelectivities, <span class="type">boolean</span> explain)</span>  </span><br><span class="line">        <span class="keyword">throws</span> ParsingException &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// some code goes here  </span></span><br><span class="line">    <span class="comment">//Replace the following    PlanCache pc = new PlanCache();  </span></span><br><span class="line">    <span class="type">CostCard</span> <span class="variable">bCard</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="built_in">this</span>.joins.size(); i++) &#123;  </span><br><span class="line">        Set&lt;Set&lt;LogicalJoinNode&gt;&gt; jsSets = enumerateSubsets(<span class="built_in">this</span>.joins, i);  </span><br><span class="line">        <span class="keyword">for</span> (Set&lt;LogicalJoinNode&gt; s : jsSets) &#123;  </span><br><span class="line">            <span class="type">CostCard</span> <span class="variable">bestCard</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">            <span class="keyword">for</span> (LogicalJoinNode remove : s) &#123;  </span><br><span class="line">                <span class="type">CostCard</span> <span class="variable">costCard</span> <span class="operator">=</span> computeCostAndCardOfSubplan(stats, filterSelectivities, remove, s, bestCard==<span class="literal">null</span>?Double.MAX_VALUE:bestCard.cost, pc);  </span><br><span class="line">                <span class="keyword">if</span> (costCard!=<span class="literal">null</span>)&#123;  </span><br><span class="line">                    <span class="keyword">if</span> (bestCard==<span class="literal">null</span> || (bestCard!=<span class="literal">null</span>&amp;&amp;costCard.cost&lt;bestCard.cost))&#123;  </span><br><span class="line">                        bestCard = costCard;  </span><br><span class="line">                        <span class="keyword">if</span> (i==<span class="built_in">this</span>.joins.size())&#123;  </span><br><span class="line">                            bCard = costCard;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (bestCard!=<span class="literal">null</span>)&#123;  </span><br><span class="line">                pc.addPlan(s,bestCard.cost,bestCard.card,bestCard.plan);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    List&lt;LogicalJoinNode&gt; js = <span class="built_in">this</span>.joins;  </span><br><span class="line">    <span class="keyword">if</span> (bCard!=<span class="literal">null</span>)&#123;  </span><br><span class="line">        js = bCard.plan;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (explain)&#123;  </span><br><span class="line">        printJoins(js,pc,stats,filterSelectivities);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> js;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 数据库 </category>
          
          <category> MIT6.830 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.830-Lab2</title>
      <link href="/posts/4ae53af6/"/>
      <url>/posts/4ae53af6/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在这个实验任务中，你将编写一组SimpleDB的运算符，用于实现表的修改（例如，插入和删除记录）、选择、连接和聚合操作。这些操作将在Lab 1中构建的基础之上，为你提供一个能够在多个表上执行简单查询的数据库系统。</p><p>此外，在Lab 1中我们忽略了缓冲池管理的问题：我们没有处理在数据库的生命周期内引用超过内存容量的页面时会出现的问题。在Lab 2中，你将设计一种逐出策略，以将陈旧的页面从缓冲池中清除。</p><p>在这个Lab中，你不需要实现事务或锁。</p><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><p>实现<code>Filter</code>和<code>Join</code>运算符，并验证它们相应的测试是否有效。这些运算符的Javadoc注释包含了它们应该如何工作的详细信息。我们已经为你提供了<code>Project</code>和<code>OrderBy</code>的实现，这可能有助于你理解其他运算符的工作原理。</p><p>实现<code>IntegerAggregator</code>和<code>StringAggregator</code>。在这里，你将编写实际计算在一系列输入元组中跨多个组对特定字段执行聚合的逻辑。对于计算平均值，使用<strong>整数除法</strong>，因为SimpleDB只支持整数。<code>StringAggregator</code>只需要支持<code>COUNT</code>聚合，因为其他操作对于字符串来说没有意义。</p><p>实现<code>Aggregate</code>运算符。与其他运算符一样，聚合运算符实现了<code>OpIterator</code>接口，以便将它们放入SimpleDB查询计划中。注意，<code>Aggregate</code>运算符的输出是每次调用<code>next()</code>时整个组的聚合值，聚合构造函数接受聚合和分组字段。</p><p>在<code>BufferPool</code>中实现与元组插入、删除和页面逐出相关的方法。目前不需要担心事务。</p><p>实现<code>Insert</code>和<code>Delete</code>运算符。与所有运算符一样，<code>Insert</code>和<code>Delete</code>实现<code>OpIterator</code>，接受要插入或删除的元组流，并输出一个具有整数字段的单个元组，该字段指示插入或删除的元组数量。这些运算符将需要调用<code>BufferPool</code>中实际修改磁盘上页面的适当方法。确保插入和删除元组的测试正常工作。</p><p>请注意，SimpleDB 不实现任何一种<strong>一致性</strong>或<strong>完整性</strong>检查，因此可以将重复的记录插入文件中，并且无法强制执行<strong>主键或外键约束</strong>。 </p><p>在这一点上，你应该能够通过 systemtest 目标来通过测试，这是这个实验的目标。 </p><p>你还将能够使用提供的 SQL 解析器对你的数据库运行 SQL 查询！详见第2.7节的简短教程。 </p><p>最后，你可能会注意到在这个实验中，迭代器扩展了 <code>Operator</code> 类而不是实现 <code>OpIterator</code> 接口。由于<code>next/hasNext</code>的实现通常是重复的、烦人的，并且容易出错，<code>Operator</code> 通用地实现了这个逻辑，只需要你实现一个更简单的 <code>readNext</code>。请随意使用这种风格的实现，或者如果你更喜欢，只需实现 <code>OpIterator</code>接口。要实现 <code>OpIterator</code> 接口，请从迭代器类中删除 <code>extends Operator</code>，并在其位置上放置 <code>implements OpIterator</code>。</p><h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><h2 id="Filter-and-Join"><a href="#Filter-and-Join" class="headerlink" title="Filter and Join"></a>Filter and Join</h2><p>回顾一下，SimpleDB 的 <code>OpIterator</code> 类实现了关系代数的操作。现在，你将实现两个运算符，使你能够执行比表扫描更有趣一些的查询。</p><ul><li><p>Filter（过滤器）：该运算符仅返回满足作为其构造函数的一部分指定的 <code>Predicate</code> 的元组。因此，它会过滤掉不符合<code>Predicate</code>的任何元组。</p></li><li><p>Join（连接）：该运算符根据作为其构造函数的一部分传递的 <code>JoinPredicate</code> 连接其两个子运算符的元组。我们仅需要一个简单的嵌套循环连接，但你可以探索更有趣的连接实现。在实验报告中描述你的实现。</p></li></ul><h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a><strong>Exercise 1</strong></h2><p>Implement the skeleton methods in:</p><hr><ul><li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;Predicate.java</li><li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;JoinPredicate.java</li><li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;Filter.java</li><li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;Join.java</li></ul><hr><p>至此，你的代码应该能通过单元测试<code>PredicateTest</code>, <code>JoinPredicateTest</code>, <code>FilterTest</code>和<code>JoinTest</code>。 进一步地，你应该可以通过系统测试<code>FilterTest</code> 和 <code>JoinTest</code>。</p><p><img src="/../../../../img/Pasted%20image%2020240129094209.png"></p><h2 id="Aggregates"><a href="#Aggregates" class="headerlink" title="Aggregates"></a>Aggregates</h2><p>附加的SimpleDB操作符实现了带有<code>GROUP BY</code>子句的基本SQL聚合。您应该实现五个SQL聚合（<code>COUNT，SUM，AVG，MIN，MAX</code>）并支持分组。您只需要支持单个字段的聚合，以及按单个字段分组。 </p><p>为了计算聚合，我们使用一个聚合器（<code>Aggregator</code>）接口，该接口将一个新元组合并到现有聚合计算中。在构造过程中，聚合器被告诉应该使用什么操作进行聚合。随后，客户端代码应该对子迭代器中的每个元组调用<code>Aggregator.mergeTupleIntoGroup()</code>。合并所有元组后，客户端可以检索聚合结果的<code>OpIterator</code>。除非<code>group by</code>字段的值是<code>Aggregator.NO_GROUPING</code>，否则结果中的每个元组都是<code>（groupValue，aggregateValue）</code>的形式，在这种情况下，结果是单个（<code>aggregateValue</code>）形式的元组。</p><p>请注意，此实现需要与不同组的数量成线性的空间。在本实验中，您不需要担心<strong>组数超过可用内存</strong>的情况。</p><h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h2><p>实现下面类中的方法:</p><hr><ul><li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;IntegerAggregator.java</li><li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;StringAggregator.java</li><li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;Aggregate.java</li></ul><hr><p>此时你的代码应该能够通过单元测试 <code>IntegerAggregatorTest</code>, <code>StringAggregatorTest</code>, and <code>AggregateTest</code>。进一步地，你应该能够通过<code>AggregateTest</code>系统测试。</p><h2 id="HeapFile-Mutability"><a href="#HeapFile-Mutability" class="headerlink" title="HeapFile Mutability"></a>HeapFile Mutability</h2><p>现在，我们将开始实现支持修改表的方法。我们从单个页面和文件的级别开始。有两组主要的操作：添加元组和删除元组。</p><p>删除元组：要删除一个元组，您需要实现<code>deleteTuple</code>方法。元组包含<code>RecordIDs</code>，这允许您找到它们所在的页面，因此这只是定位属于元组的页面并适当修改页面的标头。</p><p>添加元组：<code>HeapFile.java</code>中的<code>insertTuple</code>方法负责将元组添加到堆文件中。要向<code>HeapFile</code>添加新元组，您需要找到一个具有空槽的页面。如果在<code>HeapFile</code>中不存在这样的页面，则需要创建一个新页面并将其追加到磁盘上的物理文件中。您需要确保元组中的<code>RecordID</code>被正确更新。</p><h2 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a><strong>Exercise 3</strong></h2><p>实现以下类中的方法：</p><hr><ul><li>src&#x2F;java&#x2F;simpledb&#x2F;storage&#x2F;HeapPage.java</li><li>src&#x2F;java&#x2F;simpledb&#x2F;storage&#x2F;HeapFile.java<br>  (Note that you do not necessarily need to implement writePage at this point).</li></ul><hr><p>要实现<code>HeapPage</code>，您需要修改头部位图以支持<code>insertTuple()</code>和<code>deleteTuple()</code>等方法。您可能会发现我们在实验1中要求您实现的<code>getNumEmptySlots()</code>和<code>isSlotUsed()</code>方法作为有用的抽象。请注意，有一个<code>markSlotUsed</code>方法作为一个抽象，用于修改页面标头中元组的填充或清除状态。</p><p>请注意，<code>HeapFile.insertTuple()</code>和<code>HeapFile.deleteTuple()</code>方法重要的一点是要使用<code>BufferPool.getPage()</code>方法访问页面；否则，在下一个实验中，您对事务的实现可能不会正常工作。</p><p>实现类src&#x2F;simpledb&#x2F;BufferPool.java中的方法:</p><hr><ul><li>insertTuple()</li><li>deleteTuple()</li></ul><hr><p>这些方法应该调用属于被修改表的<code>HeapFile</code>中的适当方法（这种额外的间接性是为了在将来支持其他类型的文件，比如索引）。</p><p>在这一点上，您的代码应该通过<code>HeapPageWriteTest</code>和<code>HeapFileWriteTest</code>以及<code>BufferPoolWriteTest</code>中的单元测试。</p><h2 id="Insertion-and-deletion"><a href="#Insertion-and-deletion" class="headerlink" title="Insertion and deletion"></a>Insertion and deletion</h2><p>现在您已经编写了所有用于添加和删除元组的HeapFile机制，接下来您将实现插入<code>Insert</code>和删除<code>Delete</code>运算符。</p><p>对于实现插入和删除查询的计划，最顶层的运算符是一个特殊的插入<code>Insert</code>或删除<code>Delete</code>运算符，它修改磁盘上的页面。这些运算符返回受影响的元组数量。通过返回包含计数的单个元组来实现这一点，该元组包含一个整数字段。</p><p>插入（Insert）：该运算符将从其子运算符读取的元组添加到其构造函数中指定的<code>tableid</code>。它应该使用<code>BufferPool.insertTuple()</code>方法来执行此操作。</p><p>删除（Delete）：该运算符将从其子运算符读取的元组从其构造函数中指定的<code>tableid</code>中删除。它应该使用<code>BufferPool.deleteTuple()</code>方法来执行此操作。</p><h2 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a><strong>Exercise 4</strong></h2><p>实现下面类中的方法:</p><hr><ul><li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;Insert.java</li><li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;Delete.java</li></ul><hr><p>在这一点上，您的代码应该通过 <code>InsertTest</code> 。我们没有提供单元测试对于<code>Delete</code>。进一步的你应该能够通过单元测试<code>InsertTest</code> and <code>DeleteTest</code>。</p><h2 id="Page-eviction"><a href="#Page-eviction" class="headerlink" title="Page eviction"></a>Page eviction</h2><p>在Lab 1中，我们没有正确观察由构造函数参数numPages定义的缓冲池中最大页面数的限制。现在，您将选择一个页面驱逐策略，并对任何先前读取或创建页面的代码进行修改，以实现您的策略。</p><p>当缓冲池中存在超过numPages个页面时，在加载下一个页面之前，应该从缓冲池中驱逐一个页面。对于驱逐策略的选择取决于您；并不需要实现过于复杂的策略。在实验文档中描述您的策略。</p><p>请注意，BufferPool要求您实现flushAllPages()方法。这在实际实现缓冲池时是不需要的。然而，出于测试目的，我们需要这个方法。您不应该从任何真实的代码中调用这个方法。</p><p>由于我们已经实现了ScanTest.cacheTest的方式，您需要确保您的flushPage和flushAllPages方法不从缓冲池中驱逐页面，以确保通过这个测试。</p><p>flushAllPages应该调用BufferPool中所有页面的flushPage，并且flushPage应该将任何脏页面写入磁盘并将其标记为非脏，同时保留在缓冲池中。</p><p>唯一应该从缓冲池中移除页面的方法是evictPage，它应该在驱逐任何脏页面时调用flushPage。</p><h2 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a><strong>Exercise 5</strong></h2><p>在以下类中实现 <code>flushPage()</code> 方法和其他额外的辅助方法</p><hr><ul><li>src&#x2F;java&#x2F;simpledb&#x2F;storage&#x2F;BufferPool.java</li></ul><hr><p>如果您在上面的HeapFile.java中没有实现writePage()，则您还需要在这里进行实现。最后，您还应该实现discardPage()以从缓冲池中移除页面而不将其刷新到磁盘。在这个实验中，我们不会测试discardPage()，但它将在未来的实验中变得必要。</p><p>在这一点上，您的代码应该通过EvictionTest系统测试。</p><p>由于我们不会检查任何特定的驱逐策略，这个测试通过创建一个包含16个页面的BufferPool来进行工作（注意：虽然DEFAULT_PAGES是50，但我们初始化BufferPool时使用的是更少的页面！），然后扫描一个具有远多于16个页面的文件，看看JVM的内存使用是否增加了超过5 MB。如果您没有正确实现驱逐策略，您将无法驱逐足够的页面，从而超过了大小限制，导致测试失败。</p><p>您现在已经完成了这个实验。做得好！</p><h2 id="Query-walkthrough"><a href="#Query-walkthrough" class="headerlink" title="Query walkthrough"></a>Query walkthrough</h2><p>以下代码实现了两个表之间的简单连接查询，每个表都由三列整数组成。 （文件 some_data_file1.dat 和 some_data_file2.dat 是该文件中页面的二进制表示）。此代码等效于以下SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> some_data_file1,</span><br><span class="line">     some_data_file2</span><br><span class="line"><span class="keyword">WHERE</span> some_data_file1.field1 <span class="operator">=</span> some_data_file2.field1</span><br><span class="line">  <span class="keyword">AND</span> some_data_file1.id <span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>为了更全面地了解查询操作的示例，您可能会发现浏览连接、筛选和聚合的单元测试对您有帮助。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simpledb;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">jointest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> &#123;</span><br><span class="line">        <span class="comment">// construct a 3-column table schema</span></span><br><span class="line">        Type types[] = <span class="keyword">new</span> <span class="title class_">Type</span>[]&#123;Type.INT_TYPE, Type.INT_TYPE, Type.INT_TYPE&#125;;</span><br><span class="line">        String names[] = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;field0&quot;</span>, <span class="string">&quot;field1&quot;</span>, <span class="string">&quot;field2&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">TupleDesc</span> <span class="variable">td</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TupleDesc</span>(types, names);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create the tables, associate them with the data files</span></span><br><span class="line">        <span class="comment">// and tell the catalog about the schema  the tables.</span></span><br><span class="line">        <span class="type">HeapFile</span> <span class="variable">table1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeapFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;some_data_file1.dat&quot;</span>), td);</span><br><span class="line">        Database.getCatalog().addTable(table1, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">HeapFile</span> <span class="variable">table2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeapFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;some_data_file2.dat&quot;</span>), td);</span><br><span class="line">        Database.getCatalog().addTable(table2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// construct the query: we use two SeqScans, which spoonfeed</span></span><br><span class="line">        <span class="comment">// tuples via iterators into join</span></span><br><span class="line">        <span class="type">TransactionId</span> <span class="variable">tid</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionId</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">SeqScan</span> <span class="variable">ss1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeqScan</span>(tid, table1.getId(), <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="type">SeqScan</span> <span class="variable">ss2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeqScan</span>(tid, table2.getId(), <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a filter for the where condition</span></span><br><span class="line">        <span class="type">Filter</span> <span class="variable">sf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Filter</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Predicate</span>(<span class="number">0</span>,</span><br><span class="line">                        Predicate.Op.GREATER_THAN, <span class="keyword">new</span> <span class="title class_">IntField</span>(<span class="number">1</span>)), ss1);</span><br><span class="line"></span><br><span class="line">        <span class="type">JoinPredicate</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JoinPredicate</span>(<span class="number">1</span>, Predicate.Op.EQUALS, <span class="number">1</span>);</span><br><span class="line">        <span class="type">Join</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Join</span>(p, sf1, ss2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// and run it</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            j.open();</span><br><span class="line">            <span class="keyword">while</span> (j.hasNext()) &#123;</span><br><span class="line">                <span class="type">Tuple</span> <span class="variable">tup</span> <span class="operator">=</span> j.next();</span><br><span class="line">                System.out.println(tup);</span><br><span class="line">            &#125;</span><br><span class="line">            j.close();</span><br><span class="line">            Database.getBufferPool().transactionComplete(tid);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个表都有三个整数字段。为了表示这一点，我们创建了一个TupleDesc对象，并向其传递了一个Type对象数组，指示字段类型，以及一个String对象数组，指示字段名称。创建了TupleDesc之后，我们初始化了两个表示表的HeapFile对象。一旦创建了这些表，我们将它们添加到Catalog中（如果这是一个已经运行的数据库服务器，我们将加载这个目录信息；我们只需要为这个测试加载这些信息）。</p><p>一旦我们完成了数据库系统的初始化，我们就创建了一个查询计划。我们的计划包括两个SeqScan运算符，它们从磁盘上的每个文件中扫描元组，连接到第一个HeapFile上的一个Filter运算符，连接到一个Join运算符，根据JoinPredicate连接表中的元组。通常，这些运算符被实例化为引用适当的表（在SeqScan的情况下）或子运算符（在Join的情况下）。测试程序然后重复调用Join运算符上的next，Join运算符依次从其子运算符中拉取元组。当元组从Join输出时，它们将在命令行上打印出来。</p><h2 id="Query-Parser"><a href="#Query-Parser" class="headerlink" title="Query Parser"></a>Query Parser</h2><p>我们为您提供了一个用于SimpleDB的查询解析器，您可以在完成本实验中的练习后使用它来编写和运行对数据库的SQL查询。</p><p>第一步是创建一些数据表和一个目录。假设您有一个名为data.txt的文件，其内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1,10</span><br><span class="line">2,20</span><br><span class="line">3,30</span><br><span class="line">4,40</span><br><span class="line">5,50</span><br><span class="line">5,50</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>您可以使用 convert 命令将其转换为 <code>SimpleDB</code> 表（确保先键入 <code>ant</code>！）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar dist/simpledb.jar convert data.txt 2 <span class="string">&quot;int,int&quot;</span></span><br></pre></td></tr></table></figure><p>这样就创建了一个文件 <code>data.dat</code>。除了表格的原始数据外，两个附加参数还指定每条记录有两个字段，其类型分别为 <code>int 和 int</code>。  </p><p>接下来，创建一个目录文件 <code>catalog.txt</code>，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data (f1 int, f2 int)</span><br></pre></td></tr></table></figure><p>这会告诉 SimpleDB 有一个表，即 data（存储在 data.dat），其中有两个名为 f1 和 f2 的整数字段。<br>最后，调用解析器。你必须从命令行运行 java（ant 不能在交互式目标下正常工作）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar dist/simpledb.jar parser catalog.txt</span><br></pre></td></tr></table></figure><p>你会看到如下类似的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Added table : data with schema INT(f1), INT(f2), </span><br><span class="line">SimpleDB&gt; </span><br></pre></td></tr></table></figure><p>最后，您可以运行查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SimpleDB&gt; select d.f1, d.f2 from data d;</span><br><span class="line">Started a new transaction tid = 1221852405823</span><br><span class="line"> ADDING TABLE d(data) TO tableMap</span><br><span class="line">     TABLE HAS  tupleDesc INT(d.f1), INT(d.f2), </span><br><span class="line">1       10</span><br><span class="line">2       20</span><br><span class="line">3       30</span><br><span class="line">4       40</span><br><span class="line">5       50</span><br><span class="line">5       50</span><br><span class="line"></span><br><span class="line"> 6 rows.</span><br><span class="line">----------------</span><br><span class="line">0.16 seconds</span><br><span class="line"></span><br><span class="line">SimpleDB&gt; </span><br></pre></td></tr></table></figure><p>解析器相对功能齐全（包括对SELECT、INSERT、DELETE和事务的支持），但存在一些问题，并且不一定提供完全详细的错误消息。以下是一些需要注意的限制：</p><ol><li>必须在每个字段名前加上其表名，即使字段名是唯一的（可以使用表名别名，如上面的示例，但不能使用AS关键字）。</li><li>WHERE子句中支持嵌套查询，但FROM子句中不支持。</li><li>不支持算术表达式（例如，不能对两个字段求和）。</li><li>最多允许一个GROUP BY和一个聚合列。</li><li>不允许使用IN、UNION和EXCEPT等面向集合的运算符。</li><li>只允许在WHERE子句中使用AND表达式。</li><li>不支持UPDATE表达式。</li><li>允许使用字符串运算符LIKE，但必须完全写出（即，不允许使用Postgres的波浪符[~]缩写）。</li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="Exercise1-2"><a href="#Exercise1-2" class="headerlink" title="Exercise1-2"></a>Exercise1-2</h2><p>需要理解各个运算符的规则。本质上所有的运算符都是在处理<code>Tuple</code>，比如<code>Filter</code>运算符会过滤掉不符合条件的<code>Tuple</code>。<code>Join</code>运算符会连接多个输入流，并保留满足条件的。比如<code>t1.oid = t2.oid</code>。运算符自顶向下，且都继承了<code>OpIterator</code>。<code>OpIterator</code>是一个迭代器，可以对<code>Tuple</code>进行迭代。<br><img src="/../../../../img/Pasted%20image%2020240129094209.png"><br>上层运算符调用<code>Open</code>方法开始接收其子运算符输入的<code>Tuple</code>。注意上层运算符的<code>Open</code>方法中，先调用了其子运算符的<code>Open</code>，所以整个过程是递归进行的，自下而上（如图所示）。底层运算符将<code>Tuple</code>源源不断地传递到它的上层，上层对<code>Tuple</code>进行特定处理（过滤、聚合等）后，继续向上传递。直至顶层出口。</p><p>Example</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SeqScan</span> <span class="variable">ss1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeqScan</span>(tid, table1.getId(), <span class="string">&quot;t1&quot;</span>);  </span><br><span class="line"><span class="type">SeqScan</span> <span class="variable">ss2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeqScan</span>(tid, table2.getId(), <span class="string">&quot;t2&quot;</span>);  </span><br><span class="line"><span class="comment">// create a filter for the where condition  </span></span><br><span class="line"><span class="type">Filter</span> <span class="variable">sf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Filter</span>(  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Predicate</span>(<span class="number">0</span>,  </span><br><span class="line">                Predicate.Op.GREATER_THAN, <span class="keyword">new</span> <span class="title class_">IntField</span>(<span class="number">1</span>)), ss1);  </span><br><span class="line">  </span><br><span class="line"><span class="type">JoinPredicate</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JoinPredicate</span>(<span class="number">1</span>, Predicate.Op.EQUALS, <span class="number">1</span>);  </span><br><span class="line"><span class="type">Join</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Join</span>(p, sf1, ss2);</span><br><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM some_data_file1,</span><br><span class="line">     some_data_file2</span><br><span class="line">WHERE some_data_file1.field1 = some_data_file2.field1</span><br><span class="line">  AND some_data_file1.field0 &gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">-------Equal SQL----------</span><br><span class="line">SELECT * </span><br><span class="line">FROM some_data_file1</span><br><span class="line">JOIN some_data_file2</span><br><span class="line">ON t1.field1 = t2.field1 </span><br><span class="line">WHERE t1.field0 &gt; <span class="number">1</span>;</span><br><span class="line">--------------------------</span><br><span class="line">t1:     |   t2:</span><br><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>   |   <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>   |   <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="number">3</span>,<span class="number">3</span>,<span class="number">9</span>   |   <span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">--------------------------</span><br><span class="line">output:</span><br><span class="line"><span class="number">3</span><span class="number">3</span><span class="number">9</span><span class="number">3</span><span class="number">3</span><span class="number">4</span></span><br></pre></td></tr></table></figure><p><img src="/../../../../img/Pasted%20image%2020240131215236.png"></p><h2 id="Exercise3-5"><a href="#Exercise3-5" class="headerlink" title="Exercise3-5"></a>Exercise3-5</h2><p><img src="/../../../../img/Pasted%20image%2020240131203829.png"></p><p>注意：</p><ul><li>对<code>Page</code>的操作必须在<code>BufferPool</code>中操作，因为其后续提供了锁机制，脏页的处理。</li><li>对内存（也就是<code>BufferPool</code>中）中的<code>Page</code>修改后，其存储在磁盘上的数据（以<code>DB File</code>形式）并不会同步修改，更具体地，内存中的<code>Page</code>只是一个java对象。修改后，该<code>Page</code>被标记为脏页，并驻留在<code>BufferPool</code>中，因此后续其他操作需要读取该页时，可以读取到最新修改。（但这里的隔离级别是读未提交）</li></ul><h1 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h1><p>操作符实现的不正确，是否应该在<code>open()</code>的时候从<code>child()</code>中读入所有的<code>tuples</code>数据，并存放到一个支持迭代的容器中？</p><p>对于<code>OrderBy</code>：这个是必须的，因为需要对所有<code>tuples</code>进行排序。上层操作符通过<code>fetchNext</code>就能从上述容器中获取结果。如果通过<code>fetchNext</code>一次拿一个数据，那就无法实现全局排序了。</p><p>对于<code>join</code>：不能在<code>open</code>的时候加载它<code>child</code>的所有数据，考虑一张非常大的表，直接全部加载到内存中会OOM，因此必须通过<code>child.fetchNext</code>一条一条的拿取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Tuple <span class="title function_">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;  </span><br><span class="line">    <span class="comment">// some code goes here  </span></span><br><span class="line">    <span class="keyword">while</span> (child1.hasNext() || <span class="built_in">this</span>.curTupleLeft != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">// 判断左表当前行是否遍历结束  </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.curTupleLeft == <span class="literal">null</span> &amp;&amp; child1.hasNext())&#123;  </span><br><span class="line">            <span class="built_in">this</span>.curTupleLeft = child1.next();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">while</span> (child2.hasNext())&#123;  </span><br><span class="line">            <span class="type">Tuple</span> <span class="variable">t2</span> <span class="operator">=</span> child2.next();  </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.p.filter(<span class="built_in">this</span>.curTupleLeft,t2))&#123;  </span><br><span class="line">                <span class="type">Tuple</span> <span class="variable">tuple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tuple</span>(<span class="built_in">this</span>.td);  </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numField1; i++) &#123;  </span><br><span class="line">                    tuple.setField(i,<span class="built_in">this</span>.curTupleLeft.getField(i));  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numField2; i++) &#123;  </span><br><span class="line">                    tuple.setField(i+numField1,t2.getField(i));  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">return</span> tuple;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对左表的下一行进行join  </span></span><br><span class="line">        <span class="built_in">this</span>.curTupleLeft = <span class="literal">null</span>;  </span><br><span class="line">        child2.rewind();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于大部分其他操作符，也必须如此。</p><p>对于<code>Aggregator</code>：题目说了不需要考虑<strong>组数超过可用内存</strong>，因此直接存储所有<code>child</code>传递的<code>tuple</code>后，一起处理即可。但只需要存储<code>tuple</code>中分组字段和聚合字段即可。其他属性不需要存，节省空间。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 数据库 </category>
          
          <category> MIT6.830 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.830</title>
      <link href="/posts/7700681/"/>
      <url>/posts/7700681/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>课程官网：<a href="https://dsg.csail.mit.edu/6.5830/assign.php">6.5830&#x2F;6.5831: Lecture Notes and Assignments (mit.edu)</a><br>项目仓库：<a href="https://github.com/MIT-DB-Class/simple-db-hw-2021">MIT-DB-Class&#x2F;simple-db-hw-2021 (github.com)</a></p><h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h2 id="Lecture5"><a href="#Lecture5" class="headerlink" title="Lecture5"></a>Lecture5</h2><p><strong>Buffer Pool Optimizations</strong></p><h2 id="Lecture7"><a href="#Lecture7" class="headerlink" title="Lecture7"></a>Lecture7</h2><p><strong>Basic Join Summary</strong><br><img src="/../../../../img/Pasted%20image%2020240203144800.png"><br>上面的图列举了将两个表进行<code>join</code>操作时，CPU和I&#x2F;O的开销。<code>&#123;R&#125;</code>指表R中行数，<code>|R|</code>指表R在磁盘上存储的页面数，如果每页存<em>B</em>条记录，则<code>|R|=&#123;R&#125;/B</code>。</p><p><strong>External Join Summary</strong><br><img src="/../../../../img/Pasted%20image%2020240203151130.png"></p><h2 id="Lecture8"><a href="#Lecture8" class="headerlink" title="Lecture8"></a>Lecture8</h2><p><strong>Query Optimization Objective</strong></p><p>谓词下推（Predicate Pushdown)：将尽可能多的判断更贴近数据源，以使查询时能跳过无关的数据<strong>。用在SQL优化上来说，就是</strong>先过滤再做聚合**等操作。</p><h2 id="Lecture10"><a href="#Lecture10" class="headerlink" title="Lecture10"></a>Lecture10</h2><p><strong>Transaction:</strong></p><ul><li>Begin：在开始修改数据库的SQL语句之后</li><li>Commit：使事务生效，即持久化到磁盘中，对其他事务可见。即使数据库崩溃了也同样有效。</li><li>Abort：撤销事务的所有操作。</li></ul><p><strong>View Serializability（视图可串行化）</strong><br>一个在调度S中特定的指令顺序被认为是等价于串行顺序S’当仅当：</p><ul><li>在 S 中读取的每个值都与在 S’ 中读取的相同。</li><li>每个对象的最终写入都由 S 和 S’ 中的同一个事务 T 完成。</li></ul><p>以较为简略的表达方式，所有在S中的事务“观察”到的<strong>数值</strong>与在S’中的相同，并且事务运行后的<strong>最终</strong>状态是相同的。</p><p><img src="/../../../../img/Pasted%20image%2020240207133132.png"><br>左边的调度次序S，和右边的串行化先T1后T2的等价。<br><img src="/../../../../img/Pasted%20image%2020240207134312.png"></p><ol><li>先T1后T2，那么最后写入的B是由T2执行的，不符合”每个对象的最终写入都由 S 和 S’ 中的同一个事务 T 完成。“</li><li>先T2后T1，那么T1读取到的A是被T2更新之后的，不符合”在 S 中读取的每个值都与在 S’ 中读取的相同。“</li></ol><p><strong>Conflict Serializability</strong>（冲突可串行化）<br>如果可以通过交换不冲突的操作得出串行调度，那么该调度就是可冲突串行化的。<br>换言之：<br>对于所有冲突操作对，<code>（o1 in T1，o2 in T2）</code>要么o1恒先于o2，要么o2恒先于o1。</p><p><img src="/../../../../img/Pasted%20image%2020240207134845.png"></p><p>判断方法：优先图无环<br><img src="/../../../../img/Pasted%20image%2020240207135102.png"><br><img src="/../../../../img/Pasted%20image%2020240207135110.png"></p><p>是冲突可串行化的一定是视图可串行化的，反之不一定。</p><p>实现冲突可串行化<br>两段锁</p><ul><li>共享锁S 排他锁X</li><li>实现了冲突可串行化</li><li>访问对象需要获得共享锁，写入对象需要获得排他锁（或将共享锁升级为排他锁）</li><li>一个事务不可以释放任何锁，直到它获取了所有锁。</li><li>只有在最后一个锁被获取且对该对象的操作完成后，才释放锁。先获取后释放。（也就是只能在扩张阶段获取锁，不可释放锁；在收缩阶段只能释放锁，不可以获取锁）如下图<br><img src="/../../../../img/Pasted%20image%2020240207142116.png"><br><img src="/../../../../img/Pasted%20image%2020240207142159.png"></li></ul><p>二段锁问题：<br><strong>Deadlocks</strong><br>相互等待获取锁，而导致谁都无法释放锁。<br><img src="/../../../../img/Pasted%20image%2020240207142745.png"></p><p><strong>Cascading Aborts(级联终止)</strong><br><img src="/../../../../img/Pasted%20image%2020240207142925.png"></p><p><strong>Strict Two-Phase Locking (Strict 2PL):</strong></p><ul><li>可以避免级联终止通过持有排他锁直到事务结束</li><li>保证事务永远不会读取其他事务为提交的数据</li><li>可以解决”脏读“问题<br>不同：</li><li>在对于某个对象操作结束和已经获取最新的锁后，仅释放<strong>共享锁</strong></li><li>只有当事务提交后，才释放<strong>排他锁</strong></li></ul><p><strong>Rigorous Two-Phase Locking Protocol:</strong></p><ul><li>仅当事务提交后，才释放所有的锁。</li><li>提交顺序与串行顺序一致</li></ul><p><img src="/../../../../img/Pasted%20image%2020240207193129.png"></p><p><strong>隔离等级</strong><br><img src="/../../../../img/Pasted%20image%2020240207210829.png"></p><p><img src="/../../../../img/Pasted%20image%2020240207211006.png"><br><a href="https://blog.csdn.net/qq_42799615/article/details/110942949">再探幻读！什么是幻读?为什么会产生幻读，MySQL中是怎么解决幻读的？-CSDN博客</a></p><p><strong>OCC（Optimistic concurrency control）</strong><br>假定事务在访问数据时，不发生冲突。只在验证阶段，检测冲突，冲突则abort。<br>三个阶段：Read  Validation Wrte<br>Forward Validation（前馈验证）。如果事务Ti的验证时刻&lt;事务Tj的验证时刻</p><ul><li>事务Ti在事务Tj开始前就已经完成。意味着无相互影响</li><li>事务Ti在事务Tj开始Write阶段前完成，并且<code>WriteSet(Ti) ∩ ReadSet(Tj) = Ø</code>。也就是Ti没有写入任何被Tj读取的对象。</li><li>事务Ti完成了Read阶段在事务Tj完成其Read阶段之前，并且<code>WriteSet(Ti) ∩ ReadSet(Tj) = Ø</code> 和 <code>WriteSet(Ti) ∩ WriteSet(Tj) = Ø</code>。也就是事务Ti没有写入任何被Tj读取或写入的对象。</li></ul><p><strong>意向锁</strong><br>IS：意向共享锁：表明事务在其子节点（表&#x2F;页&#x2F;记录）设置共享锁<br>IX：意向排他锁：表明事务在其子节点（表&#x2F;页&#x2F;记录）设置互斥锁<br><img src="/../../../../img/Pasted%20image%2020240207220211.png"></p><p>获取和释放锁的顺序：</p><ul><li>自上而下获取锁，先获取祖先节点的意向锁，再获取共享&#x2F;排他锁</li><li>自下而上释放锁。</li></ul><p><strong>MVCC（Multi-Version Concurrency Control）</strong><br><a href="https://blog.csdn.net/SnailMann/article/details/94724197?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170731596116777224425151%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170731596116777224425151&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-94724197-null-null.142%5Ev99%5Epc_search_result_base5&utm_term=MVCC&spm=1018.2226.3001.4187">【MySQL笔记】正确的理解MySQL的MVCC及实现原理_mysqlmvcc实现原理-CSDN博客</a></p><p><strong>Snapshot Isolation</strong></p><ul><li>当事务启动时，它会记录一个时间戳T。</li><li>所有读取均从DB版本为T执行。</li><li>所有的写都在各自的缓冲区进行</li><li>当事务提交时，DBMS检查冲突<br>  废弃时间戳为T1的TA1，如果存在TA2<ul><li>TA2在T1之后，但在TA1之前提交</li><li>TA1和TA2更新了相同的对象<br><img src="/../../../../img/Pasted%20image%2020240207222116.png"><br>因为T2在操作W(X:&#x3D;v3)之前，T3已经提交了对X的修改，并且该修改位于T2开始之后，T2提交之前。<br>快照隔离不能防止写-读冲突，因为它不检查是否读取从另一个事务写入的内容</li></ul></li></ul><h2 id="Lecture13"><a href="#Lecture13" class="headerlink" title="Lecture13"></a>Lecture13</h2><p><strong>数据库故障类型</strong></p><ul><li>事务故障：由于某些内部错误（如违反完整性约束条件）导致事务无法完成；内部状态错误（死锁）</li><li>系统故障：软件故障（OS或DBMS，除零错误等）；主机异常奔溃</li><li>存储介质故障：磁盘损坏。这个类型是无法恢复的，没有DBMS可以从该类异常中恢复。</li></ul><p>易失性内存主要充当缓冲区，用户与数据库的交互全都是在内存中完成，然后写回磁盘的</p><ul><li>首先将目标记录复制到内存中</li><li>在内存中执行写入操作</li><li>将脏数据写回磁盘</li></ul><p>数据库崩溃后</p><ul><li>内存会被重置</li><li>磁盘是持久化的</li></ul><p>在崩溃后，Recovery机制需要保证：</p><ul><li><strong>原子性</strong>：部分完成的事务需要回滚</li><li><strong>持久性</strong>：已提交的事务需要在稳定的存储中，如磁盘</li></ul><p>使数据库进入事务一致状态，已提交的事务得到完全反映，未提交的事务被完全撤销。</p><p><img src="/../../../../img/Pasted%20image%2020240213104822.png"><br>UNDO：消除不完整或终止的事务对数据库的影响。某些事务可能已将其未提交状态写入表中–需要撤销<br>REDO：重新执行已提交的事务对数据库的影响。某些事务在提交之前可能还没有刷新所有的状态到他们的表中–需要重做</p><p><strong>Steal Policy</strong>：DBMS是否允许未提交的事务覆盖磁盘上最新已提交的数据。<br>STEAL：允许，意味着磁盘上可能有uncommitted的数据，需要通过undo日志支持回滚。(原子性)<br>NO-STEAL：不允许</p><p><strong>Force Policy</strong>：DBMS是否要求事务提交时，必须将所有更新刷盘。<br>FORCE：需要<br>NO-FORCE：不需要。这种情况磁盘上可能还是前镜像状态，需要redo日志来恢复后镜像状态。(持久性)</p><p><strong>当代数据库存储引擎大部分都有 undo log 和 redo log，那么它们就是 <code>steal/no-force</code> 策略的数据库</strong>。</p><p><strong>提前写入日志(WAL)原则</strong>：在执行实际操作时，先写日志后操作。避免操作失败后，无法通过日志恢复。<br><img src="/../../../../img/Pasted%20image%2020240214132748.png"></p><p><strong>Checkpoint</strong><br>数据库的日志会无限增长，导致crash后，重新执行日志来恢复数据的时间越来越长。checkpoint的机制就是用来解决这个问题的。它类似于快照，创建一个checkpoint之后，之前已提交的事务的日志则不必重新执行。</p><ul><li>暂停所有查询</li><li>写日志记录到磁盘中</li><li>写缓冲池中的脏页到磁盘中</li><li>添加Checkpoint的日志条目到磁盘中</li><li>重新开始查询</li></ul><p><strong>ARIES</strong></p><ul><li>Write-Ahead Logging：写前日志+（<strong>STEAL+NO-FORCE</strong> policies）</li><li>使用Redo重复历史</li><li>记录Undo过程中的更改</li></ul><p><strong>Fuzzy Checkpoint</strong><br><a href="https://my.oschina.net/fileoptions/blog/2988622">图解数据库Aries事务Recovery算法 - 黑客画家的个人空间 - OSCHINA - 中文开源技术交流社区</a></p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p><img src="/../../../../img/Pasted%20image%2020240201155537.png"></p><h2 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h2><p><a href="../../posts/d3ec6b4c">MIT6.830 Lab1</a></p><h2 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h2><p><a href="../../posts/4ae53af6">MIT6.830 Lab2</a></p><h2 id="Lab3"><a href="#Lab3" class="headerlink" title="Lab3"></a>Lab3</h2><p><a href="../../posts/3de20a60">MIT6.830 Lab3</a></p><h2 id="Lab4"><a href="#Lab4" class="headerlink" title="Lab4"></a>Lab4</h2><p><a href="../../posts/a3869fc3">MIT6.830 Lab4</a></p><h2 id="Lab5"><a href="#Lab5" class="headerlink" title="Lab5"></a>Lab5</h2><p><a href="../../posts/d481af55">MIT6.830 Lab5</a></p><h2 id="Lab6"><a href="#Lab6" class="headerlink" title="Lab6"></a>Lab6</h2><p><a href="../../posts/4d88feef">MIT6.830 Lab6</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 数据库 </category>
          
          <category> MIT6.830 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.830-Lab1</title>
      <link href="/posts/d3ec6b4c/"/>
      <url>/posts/d3ec6b4c/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h1><p>在6.830的实验作业中，你将编写一个名为SimpleDB的基本数据库管理系统。在本实验中，您将专注于实现访问磁盘上存储的数据所需的核心模块;在未来的实验中，您将添加对各种查询处理操作符以及事务、锁定和并发查询的支持。<br>SimpleDB用Java编写。我们为您提供了一组大部分未实现的类和接口。您需要为这些类编写代码。我们将通过运行一组使用[JUnit]编写的系统测试来给你的代码打分。我们还提供了一些单元测试，我们不会将其用于评分，但您可能会发现它们在验证代码工作时很有用。我们还鼓励您在我们的测试之外开发您自己的测试套件。<br>本文的其余部分描述了SimpleDB的基本架构，给出了一些关于如何开始编码的建议，并讨论了如何提交实验。我们强烈建议你尽早开始这个实验。它需要您编写相当多的代码!</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>您需要填写任何未实现的代码。在我们认为您应该编写代码的地方，这将是显而易见的。您可能需要添加私有方法或辅助类。您可以更改 API，但确保我们的评分测试仍然运行，并确保在写作中提到、解释和捍卫您的决定。</li><li>以下是您实施 SimpleDB 的一种粗略方法：<ul><li>你正在实现用于管理元组的类，即Tuple和TupleDesc。我们已经为您实现了Field、IntField、StringField和Type。由于您只需要支持整数和（固定长度的）字符串字段以及固定长度的元组，因此这些都很简单。</li><li>请实现Catalog（这应该非常简单）。</li><li>实现BufferPool的构造函数和getPage()方法。</li><li>实现访问方法，HeapPage和HeapFile以及相关的ID类。其中许多文件的大部分已经为您编写。</li><li>实现操作符SeqScan。<br>  在这一点上，您应该能够通过ScanTest系统测试，这是此实验的目标。</li></ul></li></ul><h2 id="事务、锁和恢复"><a href="#事务、锁和恢复" class="headerlink" title="事务、锁和恢复"></a>事务、锁和恢复</h2><p>当您查看我们提供给您的接口时，您会看到许多与锁、事务和恢复有关的引用。在这个实验中，您无需支持这些功能，但应该在代码的接口中保留这些参数，因为您将在以后的实验中实现事务和锁。我们提供给您的测试代码生成了一个虚假的事务ID，将其传递给运行查询的操作符；您应该将此事务ID传递给其他操作符和缓冲池。</p><h2 id="SimpleDB-架构和实现指南"><a href="#SimpleDB-架构和实现指南" class="headerlink" title="SimpleDB 架构和实现指南"></a>SimpleDB 架构和实现指南</h2><ol><li>代表字段、元组和元组模式的类；</li><li>将谓词和条件应用于元组的类；</li><li>一个或多个访问方法（例如，堆文件），用于在磁盘上存储关系并提供通过这些关系的元组的迭代方式；</li><li>一组操作符类（例如，select、join、insert、delete等），用于处理元组；</li><li>一个缓冲池，用于在内存中缓存活动元组和页面，并处理并发控制和事务（在此实验中，您无需担心这两者）；</li><li>一个存储有关可用表及其模式的信息的目录。</li></ol><p>SimpleDB并不包括您可能认为是“数据库”一部分的许多内容。特别是，SimpleDB没有：</p><ul><li>（在此实验中）SQL前端或解析器，允许您直接在SimpleDB中输入查询。相反，查询是通过将一组操作符链接到手动构建的查询计划中而构建的（参见第2.7节）。我们将在以后的实验中提供一个简单的解析器。</li><li>视图。</li><li>除整数和固定长度字符串之外的数据类型。</li><li>（在此实验中）查询优化器。</li><li>（在此实验中）索引。</li></ul><p>在本节的其余部分，我们将描述SimpleDB的每个主要组件，您需要在此实验中实现这些组件。您应该使用本讨论中的练习来指导您的实现。这份文档并不是SimpleDB的完整规范；您需要决定如何设计和实现系统的各个部分。请注意，在实验1中，您无需实现任何操作符（例如，select、join、project），只需顺序扫描。您将在以后的实验中添加对其他操作符的支持。</p><h3 id="Database-class"><a href="#Database-class" class="headerlink" title="Database class"></a>Database class</h3><p>Database 类提供对一组静态对象的访问，这些对象是数据库的全局状态。具体而言，这包括访问目录（数据库中所有表的列表）、缓冲池（当前驻留在内存中的数据库文件页面的集合）以及日志文件的方法。在此实验中，您无需担心日志文件。我们已经为您实现了 Database 类。您应该查看这个文件，因为您将需要访问这些对象。</p><h3 id="Fields和Tuples"><a href="#Fields和Tuples" class="headerlink" title="Fields和Tuples"></a>Fields和Tuples</h3><p>SimpleDB 中的元组非常基础。它们由一组 <code>Field</code> 对象组成，每个元组中有一个 Field。Field 是一个接口，不同的数据类型（例如，整数、字符串）都会实现它。Tuple 对象由底层访问方法（例如，堆文件或 B 树）创建，如下一节所述。元组还有一个类型（或模式），称为元组描述符（_tuple descriptor_），由 TupleDesc 对象表示。该对象包含一组 Type 对象，每个字段对应一个 Type，它描述相应字段的类型。</p><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h3><p><strong>实现下面类中的部分方法:</strong></p><hr><ul><li>src&#x2F;java&#x2F;simpledb&#x2F;storage&#x2F;TupleDesc.java</li><li>src&#x2F;java&#x2F;simpledb&#x2F;storage&#x2F;Tuple.java</li></ul><hr><p>此时，您的代码应能通过单元测试 <code>TupleTest</code> 和 <code>TupleDescTest</code>。此时，<code>modifyRecordId()</code> 应该会失败，因为您还没有实现它。</p><h3 id="Catalog"><a href="#Catalog" class="headerlink" title="Catalog"></a>Catalog</h3><p>目录（<code>SimpleDB</code> 中的 <code>Catalog</code> 类）包含当前数据库中的表和表模式的列表。您需要支持添加新表的功能，以及获取关于特定表的信息。与每个表相关联的是一个 <code>TupleDesc</code> 对象，它允许操作符确定表中字段的类型和数量。</p><p>全局目录是 <code>SimpleDB</code> 进程中分配的 <code>Catalog</code> 的单个实例。可以通过 <code>Database.getCatalog()</code> 方法检索全局目录，全局缓冲池也是如此（使用 <code>Database.getBufferPool()</code> 方法）。</p><h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h3><p><strong>实现下面类中的部分方法:</strong></p><hr><ul><li>src&#x2F;java&#x2F;simpledb&#x2F;common&#x2F;Catalog.java</li></ul><hr><p>此时你应该可以通过<code>CatalogTest</code></p><h3 id="BufferPool"><a href="#BufferPool" class="headerlink" title="BufferPool"></a>BufferPool</h3><p>缓冲池（SimpleDB 中的 <code>BufferPool</code> 类）负责缓存最近从磁盘读取的页面到内存中。所有操作符通过缓冲池从磁盘的不同文件中读取和写入页面。它由一定数量的页面组成，该数量由 <code>BufferPool</code> 构造函数的 <code>numPages</code> 参数定义。在后续的实验中，您将实现一个淘汰策略。对于这个实验，您只需要实现构造函数和被 SeqScan 操作符使用的 <code>BufferPool.getPage()</code> 方法。缓冲池应该最多存储 <code>numPages</code> 个页面。对于这个实验，如果对不同页面进行了超过 <code>numPages</code> 次的请求，而没有实现淘汰策略，您可以抛出一个 DbException。在以后的实验中，您将被要求实现淘汰策略。</p><h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h3><p><strong>实现 <code>getPage()</code> 方法：</strong></p><hr><ul><li>src&#x2F;java&#x2F;simpledb&#x2F;storage&#x2F;BufferPool.java</li></ul><hr><p>我们没有为 <code>BufferPool</code> 提供单元测试。您实现的功能将在下面的 <code>HeapFile</code> 实现中进行测试。您应使用 <code>DbFile.readPage</code> 方法访问 DbFile 的页面。</p><h3 id="HeapFile-access-method"><a href="#HeapFile-access-method" class="headerlink" title="HeapFile access method"></a>HeapFile access method</h3><p>访问方法提供了一种从磁盘读取或写入以特定方式排列的数据的方式。常见的访问方法包括<code>heap</code>文件（<code>Tuples</code>的无序文件）和 B 树；对于这个任务，您只需要实现堆文件访问方法，我们已经为您编写了部分代码。</p><p>一个<code>HeapFile</code> 对象被组织成一组页面，每个页面包括用于存储元组的固定字节数（由常量 <code>BufferPool.DEFAULT_PAGE_SIZE</code> 定义），包括一个头部。在 SimpleDB 中，每个<strong>数据库</strong>表对应一个 <strong>HeapFile</strong> 对象。HeapFile 中的每个页面都被组织为一组插槽，每个插槽可以容纳一个元组（在 SimpleDB 中，给定表的元组大小都相同）。除了这些插槽外，每个页面都有一个头部，包括一个位图，每个位表示一个元组插槽。如果与特定元组对应的位为 1，则表示该元组有效；如果为 0，则该元组无效（例如，已删除或从未初始化）。<code>HeapFile</code> 对象的页面属于 HeapPage 类型，该类实现了 <code>Page</code> 接口。页面存储在缓冲池中，但由 <code>HeapFile</code> 类进行读取和写入。</p><p>SimpleDB 在磁盘上以大致相同的格式存储堆文件，如同它们在内存中存储的方式。每个文件由按顺序排列在磁盘上的页面数据组成。每个页面包括表示头部的一个或多个字节，后跟实际页面内容的 <em>页面大小</em> 字节。每个元组需要 tuple size * 8 位用于其内容和 1 位用于头部。因此，一个单页中可以容纳的元组数量是：<br>$$<br>tuplesPerPage &#x3D; floor((pageSize * 8) &#x2F; (tupleSize * 8 + 1))<br>$$<br>其中，<code>tupleSize</code> 是页面中元组的大小，以<strong>字节</strong>为单位。这里的思路是每个元组在头部需要额外的一位存储空间。我们计算页面中的位数（通过将页面大小乘以 8），并将此数量除以元组中的位数（包括这个额外的头部位），以得到每页的<code>Tuple</code>数。floor 操作向下取整到最接近的整数元组数（我们不希望在页面上存储部分元组！）<br>一旦我们知道每页的元组数，存储头部所需的字节数就是：（1个元组需要1bit，换算向上取整就得到了）<br>$$headerBytes &#x3D; ceiling(tuplesPerPage &#x2F; 8)<br>$$<br>ceiling 操作向上取整到最接近的整数字节数（我们永远不存储少于一个完整字节的头部信息）。</p><p>每个字节的低位（最不重要位）表示文件中较早的插槽的状态。因此，第一个字节的最低位表示页面中第一个插槽是否正在使用。第一个字节的次低位表示页面中第二个插槽是否正在使用，依此类推。还要注意，最后一个字节的高位可能不对应于实际在文件中的插槽，因为插槽的数量可能不是 8 的倍数。同时注意，所有的 Java 虚拟机都是<strong>大端序</strong>。</p><h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h3><p><strong>实现以下类中的方法:</strong></p><hr><ul><li>src&#x2F;java&#x2F;simpledb&#x2F;storage&#x2F;HeapPageId.java</li><li>src&#x2F;java&#x2F;simpledb&#x2F;storage&#x2F;RecordId.java</li><li>src&#x2F;java&#x2F;simpledb&#x2F;storage&#x2F;HeapPage.java</li></ul><hr><p>尽管在Lab 1中您不会直接使用它们，但我们要求您在 <code>HeapPage</code> 中实现 <code>getNumEmptySlots()</code> 和 <code>isSlotUsed()</code> 方法。这些方法需要在页面头部传递位。您可能会发现查看已在 <code>HeapPage</code> 或 <code>src/simpledb/HeapFileEncoder.java</code> 中提供的其他方法有助于理解页面的布局。</p><p>您还需要在页面上实现一个迭代器，用于遍历其中的元组，这可能涉及到一个辅助类或数据结构。</p><p>在此阶段，您的代码应该通过 <code>HeapPageIdTest</code>、<code>RecordIDTest</code> 和 <code>HeapPageReadTest</code> 中的单元测试。</p><p>在您实现了 <code>HeapPage</code> 后，您将在此实验中为 <code>HeapFile</code> 编写方法，以计算文件中的页面数并从文件中读取页面。然后，您将能够从存储在磁盘上的文件中获取元组。</p><h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h3><p><strong>实现以下类中的方法:</strong></p><hr><ul><li>src&#x2F;java&#x2F;simpledb&#x2F;storage&#x2F;HeapFile.java</li></ul><hr><p>为了从磁盘读取页面，首先需要计算文件中的正确偏移量。提示：为了能够在任意偏移量读取和写入页面，你需要对文件进行随机访问。在从磁盘读取页面时，不应调用 BufferPool 方法。</p><p>你还需要实现 <code>HeapFile.iterator()</code> 方法，该方法应该迭代遍历 <code>HeapFile</code> 中每个页面的元组。迭代器必须使用 <code>BufferPool.getPage()</code> 方法来访问 <code>HeapFile</code> 中的页面。此方法将页面加载到缓冲池中，并最终将在以后的实验中用于实现基于锁的并发控制和恢复。不要在 <code>open()</code> 调用时将整个表加载到内存中，这会导致对于非常大的表发生内存溢出错误。</p><p>到目前为止，你的代码应该通过 <code>HeapFileReadTest</code> 中的单元测试。</p><h3 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h3><p>运算符负责执行查询计划的实际操作，它们实现了关系代数的各种操作。在SimpleDB中，运算符是基于迭代器的；每个运算符实现了<code>DbIterator</code>接口。</p><p>运算符通过将较低级别的运算符传递到较高级别运算符的构造函数中连接在一起，即通过“链接它们在一起”。在计划的底层，叶子节点处的特殊访问方法运算符负责从磁盘读取数据（因此它们下面没有任何运算符）。</p><p>在计划的顶部，与SimpleDB交互的程序只需对根运算符调用<code>getNext</code>；然后，此运算符在其子运算符上调用<code>getNext</code>，依此类推，直到调用这些叶子运算符。它们从磁盘获取元组并将其传递到树上（作为<code>getNext</code>的返回参数）；元组以这种方式在计划中传播，直到它们在根处输出，或者由计划中的另一个运算符组合或拒绝。</p><p>在这个实验中，您只需要实现一个SimpleDB运算符。</p><h3 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h3><p><strong>实现以下类中的方法:</strong></p><hr><ul><li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;SeqScan.java</li></ul><hr><p>这个运算符按顺序扫描构造函数中指定的<code>tableid</code>对应表的所有元组。这个运算符应该通过<code>DbFile.iterator()</code>方法访问元组。</p><p>在这一点上，您应该能够完成ScanTest系统测试。做得好！</p><p>在后续的实验中，您将填写其他运算符。</p><h3 id="A-simple-query"><a href="#A-simple-query" class="headerlink" title="A simple query"></a>A simple query</h3><p>这部分的目的是说明这些不同的组件是如何连接在一起来处理一个简单的查询的。</p><p>假设你有一个名为 “some_data_file.txt” 的数据文件，其内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,1,1</span><br><span class="line">2,2,2 </span><br><span class="line">3,4,4</span><br></pre></td></tr></table></figure><p>您可以将其转换为SimpleDB可以查询的二进制文件，如下所示：<br><code>java -jar dist/simpledb.jar convert some_data_file.txt 3</code><br>这里，参数 “3” 告诉 <code>convert</code> 输入有3列。<br>以下代码实现了对此文件的简单选择查询。该代码等效于 SQL 语句 <code>SELECT * FROM some_data_file</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simpledb;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> &#123;</span><br><span class="line">        <span class="comment">// construct a 3-column table schema</span></span><br><span class="line">        Type types[] = <span class="keyword">new</span> <span class="title class_">Type</span>[]&#123; Type.INT_TYPE, Type.INT_TYPE, Type.INT_TYPE &#125;;</span><br><span class="line">        String names[] = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123; <span class="string">&quot;field0&quot;</span>, <span class="string">&quot;field1&quot;</span>, <span class="string">&quot;field2&quot;</span> &#125;;</span><br><span class="line">        <span class="type">TupleDesc</span> <span class="variable">descriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TupleDesc</span>(types, names);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create the table, associate it with some_data_file.dat</span></span><br><span class="line">        <span class="comment">// and tell the catalog about the schema of this table.</span></span><br><span class="line">        <span class="type">HeapFile</span> <span class="variable">table1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeapFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;some_data_file.dat&quot;</span>), descriptor);</span><br><span class="line">        Database.getCatalog().addTable(table1, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// construct the query: we use a simple SeqScan, which spoonfeeds</span></span><br><span class="line">        <span class="comment">// tuples via its iterator.</span></span><br><span class="line">        <span class="type">TransactionId</span> <span class="variable">tid</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionId</span>();</span><br><span class="line">        <span class="type">SeqScan</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeqScan</span>(tid, table1.getId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// and run it</span></span><br><span class="line">            f.open();</span><br><span class="line">            <span class="keyword">while</span> (f.hasNext()) &#123;</span><br><span class="line">                <span class="type">Tuple</span> <span class="variable">tup</span> <span class="operator">=</span> f.next();</span><br><span class="line">                System.out.println(tup);</span><br><span class="line">            &#125;</span><br><span class="line">            f.close();</span><br><span class="line">            Database.getBufferPool().transactionComplete(tid);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println (<span class="string">&quot;Exception : &quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建的表具有三个整数字段。为了表示这一点，我们创建一个 <code>TupleDesc</code> 对象，并向其传递一个 <code>Type</code> 对象的数组，以及一个可选的 String 字段名数组。创建了 <code>TupleDesc</code> 后，我们初始化一个 <code>HeapFile</code> 对象，该对象表示存储在 <code>some_data_file.dat</code> 中的表。创建表后，我们将其添加到目录中。如果这是一个已经在运行的数据库服务器，那么目录信息已经被加载了。我们需要显式加载它，以使这段代码是自包含的。</p><p>初始化数据库系统后，我们创建一个查询计划。我们的计划仅包含扫描磁盘上的元组的 <code>SeqScan</code> 运算符。通常情况下，这些运算符被实例化为引用适当的表（对于 <code>SeqScan</code>）或子运算符（例如 <code>Filter</code> 的情况）。测试程序然后重复在 <code>SeqScan</code> 运算符上调用 <code>hasNext</code> 和 <code>next</code>。当元组从 <code>SeqScan</code> 输出时，它们将在命令行上打印出来。</p><p>我们强烈建议您尝试这个作为一个有趣的端到端测试，这将帮助您获得编写简单数据库的测试程序的经验。您应该在 src&#x2F;java&#x2F;simpledb 目录中创建名为 “test.java” 的文件，其中包含上述代码，您应该在代码上方添加一些 “import” 语句，并将 some_data_file.dat 文件放在顶级目录中。然后运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ant</span><br><span class="line">java -classpath dist/simpledb.jar simpledb.test</span><br></pre></td></tr></table></figure><p>请注意，<code>ant</code> 会编译 <code>test.java</code> 并生成一个包含它的新的 JAR 文件。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先需要知道每个类的作用和类之间的结构关系。</p><p><code>TupleDsec</code>：用来描述一张表的表结构。其由若干个<code>TdItem</code>构成，每个<code>TdItem</code>存储了表字段的名称和类型。比如对于学生表，可能有&lt;姓名，String&gt;,&lt;年龄，int&gt;。<br><code>Tuple</code>：用来表示数据库表的行数据，由若干个<code>Field</code>构成，每个<code>Field</code>存储了字段类型和值。本项目中只有<code>IntField</code>和<code>StringField</code>，分别表示整数和字符串。<br><code>Database</code>：数据库实例，存放了<code>Catalog</code>和<code>BufferPool</code>以及<code>LogFile</code>。<br><code>Catalog</code>：全局唯一，管理数据库中所有表的信息。<code>tableId</code>，<code>table Pk</code>，<code>TableName</code>，<code>HeapFile</code>。该类有添加新的数据库表，查询表的相关信息功能。<br><code>BufferPool</code>：全局唯一，缓冲池。此外提供了事物机制以及缓存了高频<code>Page</code>。<br><code>HeapFile</code>：实现<code>DbFile</code>，一张数据库表与一个<code>HeapFile</code>一一对应，是存储<code>Page</code>的载体，可以通过计算偏移量来读取某一<code>Page</code>。<br><code>HeapPage</code>：实现<code>Page</code>，一个数据库表由若干<code>Page</code>组成，存放了<code>header</code>和<code>tuples</code>信息。可以理解为在磁盘上，一张表被分成了若干页进行存储。<br><code>HeapPageId</code>：实现<code>PageId</code>，通过<code>tableId</code>以及<code>PageNo</code>，唯一的标识了一张表中的某一<code>Page</code>。<br><code>RecordId</code>：通过<code>tupleNo</code>和<code>PageId</code>，唯一标识了一个<code>Page</code>中的某一<code>Tuple</code>，可以理解为一张表中的某行。</p><p>下面的图展示了Lab1涉及到的所有类的关系。<br><img src="/../../../../img/Pasted%20image%2020240128205508.png"></p><p><img src="/../../../../img/Pasted%20image%2020240129093019.png"></p><p>simpleDB查询原理：一个<code>query</code>被组织成<code>operator</code>树，底层<code>operator</code>被传递给上层operator的构造器。最底层叶子结点代表access method，从disk中读取tuple；顶层的operator只需要不断调用<code>getNext()</code>，即可输出符合条件的查询结果。顶层的<code>getNext()</code>调用会不断向下传递，直到access method，然后读取tuple再向上传递。如果query中只包含简单的数据筛选，如<code>value &gt; 100</code>，那么整个query树是可以pipeline化的，数据自底向上源源不断的传递，输出；但是遇上join这种operator，就需要其中一个子节点输出所有tuple后才能继续向上传递。<br><img src="/../../../../img/Pasted%20image%2020240129094209.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/m0_53157173/article/details/131373104">MIT 6.830 数据库系统 – Lab One_mit数据库-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 数据库 </category>
          
          <category> MIT6.830 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SchemaN</title>
      <link href="/posts/906041f/"/>
      <url>/posts/906041f/</url>
      
        <content type="html"><![CDATA[<p><img src="/../../img/Pasted%20image%2020240119102220.png"></p><h1 id="Python实现用Java"><a href="#Python实现用Java" class="headerlink" title="Python实现用Java"></a>Python实现用Java</h1><h1 id="Service层和Dao层解耦"><a href="#Service层和Dao层解耦" class="headerlink" title="Service层和Dao层解耦"></a>Service层和Dao层解耦</h1><h1 id="改涉及的类"><a href="#改涉及的类" class="headerlink" title="改涉及的类"></a>改涉及的类</h1><h1 id="对接IGinx"><a href="#对接IGinx" class="headerlink" title="对接IGinx"></a>对接IGinx</h1><h1 id="取代FDW"><a href="#取代FDW" class="headerlink" title="取代FDW"></a>取代FDW</h1><p>探测是通过SchemaN实现的，一个预览效果</p><p>创建外部实体类，外部表</p><p>VPN连接不上<br>对外部数据源 读还是写操作？</p><p>外部数据源：url  port username password唯一确定</p><ol><li>获取外部数据源下所有数据表<ol><li>表名称和表结构（表的属性列）</li></ol></li><li>获取数据表的所有记录</li><li>生成DWF的外部实体类</li></ol><p>但感觉可以先转化为JAVA对象。屏蔽不同数据源的差异<br>不同核心数据库DDL语句的差异</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445</title>
      <link href="/posts/51e51a3e/"/>
      <url>/posts/51e51a3e/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UCB CS186</title>
      <link href="/posts/968190ef/"/>
      <url>/posts/968190ef/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.15组会</title>
      <link href="/posts/6598d196/"/>
      <url>/posts/6598d196/</url>
      
        <content type="html"><![CDATA[<p>围绕金融领域文本数据（上市公司财报），构建一个基于ChatGLM2-6B模型的金融问答机器人。（本地知识库问答）</p><p>技术路线：</p><ul><li>Embedding+提示工程：在提问时实时匹配之前的文档作为背景信息。</li><li>模型微调，永久改变模型参数</li></ul><p><img src="/../../img/Pasted%20image%2020240115142149.png"></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程硕士数学复习</title>
      <link href="/posts/3fe7f195/"/>
      <url>/posts/3fe7f195/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="Gauss消去法"><a href="#Gauss消去法" class="headerlink" title="Gauss消去法"></a>Gauss消去法</h2><p><img src="/../../img/Pasted%20image%2020240101143146.png"><br><img src="/../../img/Pasted%20image%2020240101143155.png"></p><h2 id="列主元法"><a href="#列主元法" class="headerlink" title="列主元法"></a>列主元法</h2><p><img src="/../../img/Pasted%20image%2020240101143821.png"></p><h2 id="Doolittle三角分解"><a href="#Doolittle三角分解" class="headerlink" title="Doolittle三角分解"></a>Doolittle三角分解</h2><p>适用条件：<strong>顺序主子式</strong>都不能为0<br><img src="/../../img/Pasted%20image%2020240101143857.png"><br><img src="/../../img/Pasted%20image%2020240101143912.png"><br><img src="/../../img/Pasted%20image%2020240101144021.png"><br><img src="/../../img/Pasted%20image%2020240101144030.png"></p><h2 id="Cholesky分解"><a href="#Cholesky分解" class="headerlink" title="Cholesky分解"></a>Cholesky分解</h2><p>适用条件：适用于<strong>对称正定矩阵</strong><br><img src="/../../img/Pasted%20image%2020240101150338.png"><br><img src="/../../img/Pasted%20image%2020240101150353.png"></p><h2 id="矩阵的条件数"><a href="#矩阵的条件数" class="headerlink" title="矩阵的条件数"></a>矩阵的条件数</h2><p><img src="/../../img/Pasted%20image%2020240101150434.png"><br><img src="/../../img/Pasted%20image%2020240101150442.png"><br><img src="/../../img/Pasted%20image%2020240101150530.png"><br><img src="/../../img/Pasted%20image%2020240101150722.png"><br><img src="/../../img/Pasted%20image%2020240101151221.png"><br><img src="/../../img/Pasted%20image%2020240101153011.png"><br><img src="/../../img/Pasted%20image%2020240101153023.png"><br><img src="/../../img/Pasted%20image%2020240101155029.png"></p><h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><p><img src="/../../img/Pasted%20image%2020240101183058.png"><br><img src="/../../img/Pasted%20image%2020240101183108.png"></p><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><p><img src="/../../img/Pasted%20image%2020240102104713.png"><img src="/../../img/Pasted%20image%2020240102104732.png"><br><img src="/../../img/Pasted%20image%2020240102104802.png"></p><h2 id="Jacobi迭代法"><a href="#Jacobi迭代法" class="headerlink" title="Jacobi迭代法"></a>Jacobi迭代法</h2><p><img src="/../../img/Pasted%20image%2020240102124911.png"></p><h2 id="Gauss-Seidel迭代法"><a href="#Gauss-Seidel迭代法" class="headerlink" title="Gauss-Seidel迭代法"></a>Gauss-Seidel迭代法</h2><p><img src="/../../img/Pasted%20image%2020240102124924.png"></p><h2 id="迭代收敛性（重要）"><a href="#迭代收敛性（重要）" class="headerlink" title="迭代收敛性（重要）"></a>迭代收敛性（重要）</h2><p><img src="/../../img/Pasted%20image%2020240102112639.png"><br><img src="/../../img/Pasted%20image%2020240102112651.png"><br>因为$ρ(B)\leq||B||$，所以判断$||B||_1或||B||_2或||B||_\infty是否\lt1$即可</p><p><img src="/../../img/Pasted%20image%2020240102113013.png"><br><img src="/../../img/Pasted%20image%2020240102113038.png"><br><img src="/../../img/Pasted%20image%2020240102113159.png"></p><p><img src="/../../img/Pasted%20image%2020240102131442.png"></p><h2 id="SOR迭代法"><a href="#SOR迭代法" class="headerlink" title="SOR迭代法"></a>SOR迭代法</h2><p><img src="/../../img/Pasted%20image%2020240102132824.png"><br><img src="/../../img/Pasted%20image%2020240102132951.png"><br><img src="/../../img/Pasted%20image%2020240102134249.png"></p><h2 id="课后习题-1"><a href="#课后习题-1" class="headerlink" title="课后习题"></a>课后习题</h2><p><img src="/../../img/Pasted%20image%2020240102140027.png"></p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h3 id="二分法和试位法"><a href="#二分法和试位法" class="headerlink" title="二分法和试位法"></a>二分法和试位法</h3><p><img src="/../../img/Pasted%20image%2020240103135945.png"></p><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p><img src="/../../img/Pasted%20image%2020240103140358.png"><br><img src="/../../img/Pasted%20image%2020240103140409.png"><br><img src="/../../img/Pasted%20image%2020240103140935.png"><br><img src="/../../img/Pasted%20image%2020240103141724.png"><br><img src="/../../img/Pasted%20image%2020240103141731.png"></p><h3 id="局部收敛性"><a href="#局部收敛性" class="headerlink" title="局部收敛性"></a>局部收敛性</h3><p><img src="/../../img/Pasted%20image%2020240103142257.png"><br><img src="/../../img/Pasted%20image%2020240103142521.png"><br>上述公式是判断迭代法几阶收敛的关键。如果一阶导数不为0，那么是线性收敛的。</p><h3 id="迭代加速Aitken和Steffensen"><a href="#迭代加速Aitken和Steffensen" class="headerlink" title="迭代加速Aitken和Steffensen"></a>迭代加速Aitken和Steffensen</h3><h3 id="Newton迭代法"><a href="#Newton迭代法" class="headerlink" title="Newton迭代法"></a>Newton迭代法</h3><p><img src="/../../img/Pasted%20image%2020240103144313.png"><br><img src="/../../img/Pasted%20image%2020240103144452.png"><br><img src="/../../img/Pasted%20image%2020240103144725.png"></p><p><strong>重根</strong><br>方法一：<br><img src="/../../img/Pasted%20image%2020240103145356.png"><br>方法二：<br><img src="/../../img/Pasted%20image%2020240103145419.png"><br><img src="/../../img/Pasted%20image%2020240103145829.png"></p><p>非线性方程组不动点迭代<br><img src="/../../img/Pasted%20image%2020240103151137.png"><br><img src="/../../img/Pasted%20image%2020240103151155.png"></p><p>非线性方程组Newton法<br><img src="/../../img/Pasted%20image%2020240103152053.png"><br><img src="/../../img/Pasted%20image%2020240103152036.png"><br><img src="/../../img/Pasted%20image%2020240103152020.png"></p><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><h2 id="Lagrange"><a href="#Lagrange" class="headerlink" title="Lagrange"></a>Lagrange</h2><p><img src="/../../img/Pasted%20image%2020240104143418.png"><br><img src="/../../img/Pasted%20image%2020240104143442.png"><br><img src="/../../img/Pasted%20image%2020240104143455.png"></p><p><img src="/../../img/Pasted%20image%2020240104143512.png"><br><img src="/../../img/Pasted%20image%2020240104143524.png"><br><img src="/../../img/Pasted%20image%2020240104143552.png"></p><h2 id="均差和重节点均差"><a href="#均差和重节点均差" class="headerlink" title="均差和重节点均差"></a>均差和重节点均差</h2><p><img src="/../../img/Pasted%20image%2020240104143605.png"><br><img src="/../../img/Pasted%20image%2020240104144422.png"></p><h2 id="Newton插值法"><a href="#Newton插值法" class="headerlink" title="Newton插值法"></a>Newton插值法</h2><p><img src="/../../img/Pasted%20image%2020240104160307.png"><br><img src="/../../img/Pasted%20image%2020240104160329.png"><br><img src="/../../img/Pasted%20image%2020240104160344.png"></p><h2 id="Newton-Hermite插值"><a href="#Newton-Hermite插值" class="headerlink" title="Newton-Hermite插值"></a>Newton-Hermite插值</h2><p><img src="/../../img/Pasted%20image%2020240104160228.png"><br><img src="/../../img/Pasted%20image%2020240104160237.png"></p><h2 id="分段线性插值"><a href="#分段线性插值" class="headerlink" title="分段线性插值"></a>分段线性插值</h2><p><img src="/../../img/Pasted%20image%2020240104160539.png"><br><img src="/../../img/Pasted%20image%2020240104160546.png"></p><h2 id="分段三次Hermite插值"><a href="#分段三次Hermite插值" class="headerlink" title="分段三次Hermite插值"></a>分段三次Hermite插值</h2><p><img src="/../../img/Pasted%20image%2020240104160840.png"></p><h2 id="三次样条插值"><a href="#三次样条插值" class="headerlink" title="三次样条插值"></a>三次样条插值</h2><p>不仅一阶导，二阶导也连续</p><p><img src="/../../img/Pasted%20image%2020240104162216.png"></p><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><h2 id="正交多项式"><a href="#正交多项式" class="headerlink" title="正交多项式"></a>正交多项式</h2><p><img src="/../../img/Pasted%20image%2020240105095953.png"><br><img src="/../../img/Pasted%20image%2020240105100246.png"><br><img src="/../../img/Pasted%20image%2020240105100255.png"></p><h2 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h2><h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><h2 id="梯形和Simpson"><a href="#梯形和Simpson" class="headerlink" title="梯形和Simpson"></a>梯形和Simpson</h2><p>用一次和二次Lagrange插值近似积分函数<br><img src="/../../img/Pasted%20image%2020240106104328.png"><br><img src="/../../img/Pasted%20image%2020240106104340.png"></p><p><img src="/../../img/Pasted%20image%2020240106104352.png"><br><img src="/../../img/Pasted%20image%2020240106104358.png"></p><p><img src="/../../img/Pasted%20image%2020240106104617.png"></p><h2 id="代数精度"><a href="#代数精度" class="headerlink" title="代数精度"></a>代数精度</h2><p><img src="/../../img/Pasted%20image%2020240106104634.png"></p><h2 id="Gauss求积和构造"><a href="#Gauss求积和构造" class="headerlink" title="Gauss求积和构造"></a>Gauss求积和构造</h2><p><img src="/../../img/Pasted%20image%2020240106144528.png"><br>记住一个特殊的权函数和节点<br><img src="/../../img/Pasted%20image%2020240106144554.png"><br>不在<code>[-1,1]</code>上的可以通过转换映射（去年题5）<br><img src="/../../img/Pasted%20image%2020240106144733.png"></p><h2 id="Gauss-Legendre求积"><a href="#Gauss-Legendre求积" class="headerlink" title="Gauss-Legendre求积"></a>Gauss-Legendre求积</h2><p><img src="/../../img/Pasted%20image%2020240106145119.png"><br><img src="/../../img/Pasted%20image%2020240106145129.png"><br><img src="/../../img/Pasted%20image%2020240106145213.png"><br><img src="/../../img/Pasted%20image%2020240106145456.png"></p><h2 id="Gauss-Chebyshev求积"><a href="#Gauss-Chebyshev求积" class="headerlink" title="Gauss-Chebyshev求积"></a>Gauss-Chebyshev求积</h2><p><img src="/../../img/Pasted%20image%2020240106145519.png"><br><img src="/../../img/Pasted%20image%2020240106145531.png"></p><p><img src="/../../img/Pasted%20image%2020240106145539.png"><br><img src="/../../img/Pasted%20image%2020240106145559.png"></p><h1 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h1><h2 id="显式Euler"><a href="#显式Euler" class="headerlink" title="显式Euler"></a>显式Euler</h2><p><img src="/../../img/Pasted%20image%2020240106163220.png"></p><h2 id="隐式Euler"><a href="#隐式Euler" class="headerlink" title="隐式Euler"></a>隐式Euler</h2><p><img src="/../../img/Pasted%20image%2020240106163229.png"></p><h2 id="梯形"><a href="#梯形" class="headerlink" title="梯形"></a>梯形</h2><p><img src="/../../img/Pasted%20image%2020240106163237.png"></p><h2 id="改进Euler"><a href="#改进Euler" class="headerlink" title="改进Euler"></a>改进Euler</h2><p><img src="/../../img/Pasted%20image%2020240106163248.png"></p><h2 id="泰勒公式"><a href="#泰勒公式" class="headerlink" title="泰勒公式"></a>泰勒公式</h2><p><img src="/../../img/Pasted%20image%2020240106162217.png"></p><h2 id="误差"><a href="#误差" class="headerlink" title="误差"></a>误差</h2><p><img src="/../../img/Pasted%20image%2020240106163311.png"><br><img src="/../../img/Pasted%20image%2020240106163318.png"></p><p><img src="/../../img/Pasted%20image%2020240106163341.png"></p><p><img src="/../../img/Pasted%20image%2020240106163404.png"></p><p><img src="/../../img/Pasted%20image%2020240106163413.png"><br><img src="/../../img/Pasted%20image%2020240106163515.png"></p><p><img src="/../../img/Pasted%20image%2020240106163523.png"></p><h2 id="Runge-Kutta方法"><a href="#Runge-Kutta方法" class="headerlink" title="Runge-Kutta方法"></a>Runge-Kutta方法</h2><p>记几个重要的<br><img src="/../../img/Pasted%20image%2020240106163042.png"><br><img src="/../../img/Pasted%20image%2020240106163048.png"><br><img src="/../../img/Pasted%20image%2020240106163056.png"></p><h2 id="相容性、收敛性、绝对稳定性"><a href="#相容性、收敛性、绝对稳定性" class="headerlink" title="相容性、收敛性、绝对稳定性"></a>相容性、收敛性、绝对稳定性</h2><p><img src="/../../img/Pasted%20image%2020240106163128.png"></p><h1 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h1><p>第一章</p><ul><li>误差</li><li>有效数字</li><li>数值方法的稳定性</li></ul><p>第二章</p><ul><li>Gauss消去法，列主元</li><li><strong>A&#x3D;LU分解</strong></li><li>Cholesky分解</li><li>矩阵范数计算</li><li>条件数计算</li><li>误差分析</li></ul><p>第三章</p><ul><li>迭代法</li><li>收敛条件和收敛速度</li><li><strong>Jacobi和Gauss-Seide迭代法</strong></li><li><strong>分量形式、迭代矩阵、收敛的充要条件、充分条件</strong></li><li>SOR迭代，求解最佳松弛因子</li><li><em>最速下降，共轭梯度不考</em></li></ul><p>第四章</p><ul><li>不动点迭代</li><li>局部收敛性、收敛阶计算</li><li>加速方法</li><li>Newton迭代，收敛性，单根、重根收敛阶</li><li><em>非线性方程组不考</em></li></ul><p>第五章（不是重点，很可能不考）</p><ul><li>Householder</li><li>Givens</li><li>幂法、反幂法</li><li>QR算法（不考）</li><li>带位移算法</li></ul><p>第六章（感觉出大题）</p><ul><li>Lagrange、Newton、Hermite</li><li>插值方法，余项</li><li>均差，重节点均差计算（填空）</li><li>分段低次插值以及三次样条插值函数计算（大题）</li></ul><p>第七章</p><ul><li>正交多项式</li><li>最小二乘法（填空）</li><li>线性以及特殊非线性化成线性问题（大题）</li></ul><p>第八章（感觉出大题）</p><ul><li>梯形公式，Simpson</li><li>代数精度</li><li>Romberg积分</li><li>Gauss型相关</li></ul><p>第九章（感觉出大题）</p><ul><li>单步法：Euler、隐式Euler、梯形、改进Euler</li><li>Runge-Kutta方法</li><li>局部截断误差，主项，方法阶，相容性，收敛性，绝对稳定性</li><li>线性多步法</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab 4.ShardKV</title>
      <link href="/posts/ed5ca22/"/>
      <url>/posts/ed5ca22/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-4-Sharded-Key-Value-Service"><a href="#Lab-4-Sharded-Key-Value-Service" class="headerlink" title="Lab 4 - Sharded Key&#x2F;Value Service"></a>Lab 4 - Sharded Key&#x2F;Value Service</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在本实验中，你将建立一个Key&#x2F;Value存储系统，将Key “分片 “或分区到一组副本组中。分片是键&#x2F;值对的一个子集；例如，所有以 “a “开头的键可能是一个分片，所有以 “b “开头的键可能是另一个分片，等等。分片的原因在于性能。每个副本组只处理几个分片的put和get，各组并行运行；因此，系统总吞吐量（单位时间内的put和get）与组的数量成正比增长。</p><p>你的Key&#x2F;Value存储将有两个主要组件。首先是一系列副本组。每个副本组负责一部分分片。一个副本由几个使用 Raft 来复制该组分片的服务器组成。第二个组件是“分片控制器”。分片控制器决定哪个副本组应该服务于哪个分片；这个信息被称为配置。配置会随着时间的推移而变化。客户端询问分片控制器以找到与某个键相关的副本组，而副本组则会咨询控制器以了解应该服务哪些分片。整个系统只有一个分片控制器，通过使用 Raft 实现为一个容错的服务。</p><p>一个分片式存储系统必须能够在副本组之间转移分片。一个原因是某些组可能会比其他组的负载更高，因此需要移动分片以平衡负载。另一个原因是副本组可能加入和离开系统：新的副本组可能会被添加以增加容量，或者现有的副本组可能会被下线进行修复或淘汰。</p><p>这个实验的主要挑战将是处理重新配置 —— 即分配给副本组的分片发生变化。在单个副本组内，所有组成员必须就何时发生重新配置与客户端 <code>Put/Append/Get</code> 请求达成一致。例如，一个 Put 请求可能与导致副本组不再负责保存 <code>Put</code> 涉及的键的分片的重新配置几乎同时到达。组内的所有副本必须就 Put 请求是在重新配置之前还是之后发生达成一致。如果在之前，<code>Put</code> 请求应该生效，并且分片的新所有者将看到其效果；如果在之后，<code>Put</code> 请求将不会生效，客户端必须在新的所有者处重试。推荐的方法是让每个副本组使用 Raft 记录不仅 Put、Append 和 Get 操作的顺序，还有重新配置的顺序。您需要确保每个分片在任何时候最多只有一个副本组为其服务。</p><p>重新配置还需要副本组之间的交互。例如，在配置 10 中，组 G1 可能负责分片 S1。在配置 11 中，组 G2 可能负责分片 S1。在从配置 10 到配置 11 的重新配置期间，G1 和 G2 必须使用 RPC 将分片 S1 的内容（键&#x2F;值对）从 G1 移动到 G2。</p><p>注意：</p><ul><li>客户端和服务器之间的交互只能使用 RPC。例如，不允许服务器的不同实例共享 Go 变量或文件。</li><li>本实验室使用 “配置 “来指代将碎片分配到副本组。这与 Raft 群集成员变更不同。您不必实施 Raft 群集成员资格变更。</li><li>Lab 4 分片服务器、Lab 4 分片控制器和 Lab 3 kvraft 都必须使用相同的 Raft 实现。</li></ul><p>本实验的总体架构（一个配置服务和一系列副本组）与 Flat Datacenter Storage、BigTable、Spanner、FAWN、Apache HBase、Rosebud、Spinnaker 等系统的总体模式相同。不过，这些系统在很多细节上都与本实验室不同，通常也更加复杂和强大。例如，该实验不会在每个 Raft 组中演化对等集，其数据和查询模型非常简单，分片的切换速度很慢，而且不允许客户端并发访问。</p><p>我们会在 <code>src/shardctrler</code> 和 <code>src/shardkv</code> 中为您提供骨架代码和测试。</p><h2 id="PartA：The-Shard-controller"><a href="#PartA：The-Shard-controller" class="headerlink" title="PartA：The Shard controller"></a>PartA：The Shard controller</h2><p>首先，你要在 <code>shardctrler/server.go</code> 和 <code>client.go</code> 中实现分块控制器。完成后，你应该能通过 shardctrler 目录中的所有测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span></span><br><span class="line">Test: Basic leave/join ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Historical queries ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Move ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Concurrent leave/join ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Minimal transfers after joins ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Minimal transfers after leaves ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Multi-group <span class="built_in">join</span>/leave ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Concurrent multi leave/join ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Minimal transfers after multijoins ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Minimal transfers after multileaves ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: Check Same config on servers ...</span><br><span class="line">  ... Passed</span><br><span class="line">PASS</span><br><span class="line">ok  6.5840/shardctrler5.863s</span><br><span class="line">$</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;0..10&#125;; <span class="keyword">do</span> go <span class="built_in">test</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><code>shardctrler</code> 管理着一系列编号的配置。每个配置描述了一组副本组以及分片到副本组的分配情况。每当这个分配需要改变时，分配控制器就会创建一个新的配置，其中包含了新的分片分配情况。Key&#x2F;Value客户端和服务器在想要获取当前（或过去）的配置信息时会联系 <code>shardctrler</code>。</p><p>你的实现必须支持<code>shardctrler/common.go</code>中描述的RPC接口，其中包括<code>Join</code>、<code>Leave</code>、<code>Move</code>和<code>Query</code> RPC。这些 RPC 的目的是允许管理员（和测试）控制 <code>shardctrler</code>：添加新的副本组、删除副本组，以及在副本组之间移动碎片。</p><ul><li><p><code>Join</code> RPC 被管理员用来添加新的副本组。其参数是从唯一、非零副本组标识符（GIDs）到服务器名称列表的映射集。<code>shardctrler</code> 应该通过创建一个新的配置来包含新的副本组来做出反应。新的配置应该尽可能均匀地将分片分配给完整的副本组集，并且应该尽可能少地移动分片以达到该目标。如果 GID 不是当前配置的一部分（即 GID 允许加入后离开再次加入），则 shardctrler 应该允许 GID 的重复使用。</p></li><li><p><code>Leave</code> RPC 的参数是先前加入的副本组的 GIDs 列表。<code>shardctrler</code> 应该创建一个不包含这些组的新配置，并且将这些组的分片分配给剩余的副本组。新的配置应该尽可能均匀地将分片分配给副本组，并且应该尽可能少地移动分片以达到该目标。</p></li><li><p><code>Move</code> RPC 的参数是一个分片编号和一个 GID。shardctrler 应该创建一个新的配置，在该配置中将分片分配给该组。Move 的目的是允许我们测试你的软件。在 Move 之后进行 Join 或 Leave 操作可能会撤销 Move 操作，因为 Join 和 Leave 会重新平衡。</p></li><li><p><code>Query</code> RPC 的参数是一个配置编号。shardctrler 将回复具有该编号的配置。如果编号为 -1 或大于已知的最大配置编号，则 <code>shardctrler</code> 应该回复最新的配置。<code>Query(-1)</code> 的结果应该反映 shardctrler 在收到 Query(-1) RPC 之前完成处理的每个 Join、Leave 或 Move RPC。</p></li></ul><p>第一个配置应该编号为零。它不包含任何组，所有分片都应分配给 GID 为0的组（无效的 GID）。下一个配置（响应于 <code>Join</code> RPC 创建的）应编号为 1，等等。通常情况下，分片的数量会远远<strong>多于</strong>组的数量（即每个组会服务多个分片），以便可以在相当精细的粒度上进行负载平衡调整。</p><p>你的任务是在 shardctrler&#x2F; 目录下的 client.go 和 server.go 中实现上面指定的接口。你的 shardctrler 必须是容错的，使用 Lab 2&#x2F;3 中的 Raft 库。当你通过了 shardctrler&#x2F; 目录中的所有测试后，你就完成了这项任务。</p><p>提示：</p><ul><li>请先从你的 kvraft 服务器的简化版本开始。</li><li>你应该对分块控制器的 RPC 实现客户端请求的重复检测。<code>shardctrler</code>测试并不测试这一点，但<code>shardkv</code>测试稍后会在不可靠的网络上使用你的<code>shardctrler</code>；如果你的<code>shardctrler</code>没有过滤掉重复的RPC，你可能很难通过shardkv测试。</li><li>执行分片重新平衡的状态机中的代码需要是确定性的。在 Go 语言中，map 的迭代顺序是不确定的。</li><li>Go 中的 map 是引用类型。如果你将一个 map 类型的变量赋值给另一个变量，那么两个变量都指向同一个 map。因此，如果你想要基于先前的配置创建一个新的 Config，你需要创建一个新的 map 对象（使用 make()），并逐个复制键和值。</li><li>Go 语言中的竞态检测器（go test -race）可以帮助你找出潜在的 bug。</li></ul><p>几个概念：</p><ul><li>replica group：副本组</li><li>shards：分片，只是一个说法，没有实体对象<br>分片和副本组的关系：一般来说根据Key来划分为不同的分片，参考MapReduce中的做法，可以是<code>Hash(Key)%Nshards</code>来划分，这样不同的Key-Value会被分配到不同的分片上，尽可能存储均匀。<br>一般副本组负责管理若干个分片，而且每个副本组负责的分片数量均匀（由分片控制器维护）。当收到请求时，Client会根据Key来计算它实际所处的分片号，然后查询Config，向负责该分片的副本组中所有的节点发送RPC<br><img src="/../../../../img/Pasted%20image%2020231208180816.png"></li></ul><p>shardctrler维护了当前以及历史的配置Config列表<br>Config结构：</p><ul><li>num:int 索引号，对应Config切片中的索引。可以通过<code>config[num]</code>获得指定位置的配置Config</li><li>shards:[Nshards]int，分片号-&gt;Gid的映射。表示某个分片是由Gid的Grounps那个组负责的。</li><li>groups:map[int]  []string，Gid到Servers的映射，记录了Replica group中各个节点是哪些。这样在shardkv发送对于某个分片的请求时，就知道要往哪些负责这个分片节点发送RPC了。</li></ul><p><img src="/../../../../img/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%9B%BE%20(2).png"></p><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>由于需要保证请求的幂等性，服务端可以通过<code>ClientId</code>和<code>CommandId</code>来唯一标识一次请求。那么就需要在客户端发送请求的时候带上这两个字段。、</p><p><code>ClientId</code>：客户端标识，可以用项目中自带的<code>nrand()</code>函数实现。<br><code>CommandId</code>：请求标识，来唯一的标识某个客户端发送的请求。可以每次递增。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeClerk</span><span class="params">(servers []*labrpc.ClientEnd)</span></span> *Clerk &#123;</span><br><span class="line">ck := <span class="built_in">new</span>(Clerk)</span><br><span class="line">ck.servers = servers</span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line">ck.clientId = nrand()</span><br><span class="line">ck.commandId = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> ck</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Move(shard <span class="type">int</span>, gid <span class="type">int</span>) &#123;</span><br><span class="line">args := &amp;MoveArgs&#123;&#125;</span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line">atomic.AddInt64(&amp;ck.commandId,<span class="number">1</span>)</span><br><span class="line">args.Shard = shard</span><br><span class="line">args.GID = gid</span><br><span class="line">args.ClientId = ck.clientId</span><br><span class="line">args.CommandId = ck.commandId</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// try each known server.</span></span><br><span class="line"><span class="keyword">for</span> _, srv := <span class="keyword">range</span> ck.servers &#123;</span><br><span class="line"><span class="keyword">var</span> reply MoveReply</span><br><span class="line">ok := srv.Call(<span class="string">&quot;ShardCtrler.Move&quot;</span>, args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> ok &amp;&amp; reply.WrongLeader == <span class="literal">false</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的<code>Query</code>,<code>Join</code>,<code>Leave</code>都类似</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>Server端需要做的就是针对不同的请求来操作分片配置。</p><h3 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShardCtrler)</span></span> Join(args *JoinArgs, reply *JoinReply) &#123;</span><br><span class="line">DPrintf(<span class="string">&quot;[Join Start]:Receive args:%v | %s\n&quot;</span>,args,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line">op := Op&#123;</span><br><span class="line">OpType: JOIN,</span><br><span class="line">Servers: args.Servers,</span><br><span class="line">ClientId: args.ClientId,</span><br><span class="line">CommandId: args.CommandId,</span><br><span class="line">&#125;</span><br><span class="line">commandReply := sc.Command(op)</span><br><span class="line">reply.Err = commandReply.Err</span><br><span class="line">reply.WrongLeader = commandReply.WrongLeader</span><br><span class="line">DPrintf(<span class="string">&quot;[Join Return]:Receive args:%v and Return reply:%v | %s\n&quot;</span>,args,reply,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Leave"><a href="#Leave" class="headerlink" title="Leave"></a>Leave</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShardCtrler)</span></span> Leave(args *LeaveArgs, reply *LeaveReply) &#123;</span><br><span class="line">DPrintf(<span class="string">&quot;[Leave Start]:Receive args:%v | %s\n&quot;</span>,args,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line">op := Op&#123;</span><br><span class="line">OpType: LEAVE,</span><br><span class="line">GIDs: args.GIDs,</span><br><span class="line">ClientId: args.ClientId,</span><br><span class="line">CommandId: args.CommandId,</span><br><span class="line">&#125;</span><br><span class="line">commandReply := sc.Command(op)</span><br><span class="line">reply.Err = commandReply.Err</span><br><span class="line">reply.WrongLeader = commandReply.WrongLeader</span><br><span class="line">DPrintf(<span class="string">&quot;[Leave Return]:Receive args:%v and Return reply:%v | %s\n&quot;</span>,args,reply,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Move"><a href="#Move" class="headerlink" title="Move"></a>Move</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShardCtrler)</span></span> Move(args *MoveArgs, reply *MoveReply) &#123;</span><br><span class="line">DPrintf(<span class="string">&quot;[Move Start]:Receive args:%v | %s\n&quot;</span>,args,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line">op := Op&#123;</span><br><span class="line">OpType: MOVE,</span><br><span class="line">Shard: args.Shard,</span><br><span class="line">GID: args.GID,</span><br><span class="line">ClientId: args.ClientId,</span><br><span class="line">CommandId: args.CommandId,</span><br><span class="line">&#125;</span><br><span class="line">commandReply := sc.Command(op)</span><br><span class="line">reply.Err = commandReply.Err</span><br><span class="line">reply.WrongLeader = commandReply.WrongLeader</span><br><span class="line">DPrintf(<span class="string">&quot;[Move Return]:Receive args:%v and Return reply:%v | %s\n&quot;</span>,args,reply,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShardCtrler)</span></span> Query(args *QueryArgs, reply *QueryReply) &#123;</span><br><span class="line">DPrintf(<span class="string">&quot;[Query Start]:Receive args:%v | %s\n&quot;</span>,args,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line">op := Op&#123;</span><br><span class="line">OpType: QUERY,</span><br><span class="line">Num: args.Num,</span><br><span class="line">ClientId: args.ClientId,</span><br><span class="line">CommandId: args.CommandId,</span><br><span class="line">&#125;</span><br><span class="line">commandReply := sc.Command(op)</span><br><span class="line">reply.Err = commandReply.Err</span><br><span class="line">reply.WrongLeader = commandReply.WrongLeader</span><br><span class="line">reply.Config = commandReply.Config</span><br><span class="line">DPrintf(<span class="string">&quot;[Query Return]:Receive args:%v and Return reply:%v | %s\n&quot;</span>,args,reply,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Load-Balance"><a href="#Load-Balance" class="headerlink" title="Load Balance"></a>Load Balance</h3><p>使得每个group管理的shard数量尽可能的接近。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">balance</span><span class="params">(groups *<span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">string</span>,shards *[NShards]<span class="type">int</span>)</span></span> [NShards]<span class="type">int</span>&#123;</span><br><span class="line"><span class="comment">// must be definite</span></span><br><span class="line">groupNum := <span class="built_in">len</span>(*groups)</span><br><span class="line"></span><br><span class="line">reShards := [NShards]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> groupNum == <span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">return</span> reShards</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// so every gid should be responsible for [balanceNum,balanceNum+1] shards</span></span><br><span class="line">balanceNum := NShards/groupNum</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(reShards[:],shards[:])</span><br><span class="line">newGids := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">gidToNShards := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line"><span class="keyword">for</span> gid,_ := <span class="keyword">range</span> *groups&#123;</span><br><span class="line">newGids = <span class="built_in">append</span>(newGids,gid)</span><br><span class="line">gidToNShards[gid] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort new gids</span></span><br><span class="line">sort.Slice(newGids, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> newGids[i] &lt; newGids[j]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// obtain the number of shards that GID is responsible for</span></span><br><span class="line"><span class="keyword">for</span> _,gid :=<span class="keyword">range</span> shards&#123;</span><br><span class="line"><span class="keyword">if</span> _,ok := gidToNShards[gid];ok&#123;</span><br><span class="line">gidToNShards[gid]+=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//move shard</span></span><br><span class="line"><span class="keyword">for</span> i,gid := <span class="keyword">range</span> shards&#123;</span><br><span class="line">n,ok := gidToNShards[gid]</span><br><span class="line"><span class="comment">// leave</span></span><br><span class="line"><span class="keyword">if</span> n&gt;balanceNum || !ok&#123;</span><br><span class="line"><span class="keyword">for</span> _,ngid := <span class="keyword">range</span> newGids&#123;</span><br><span class="line"><span class="keyword">if</span> gid==ngid&#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (gidToNShards[ngid] &lt; balanceNum &amp;&amp; (ok || NShards%groupNum==<span class="number">0</span>)) || (gidToNShards[ngid] &lt;= balanceNum &amp;&amp; !ok &amp;&amp; NShards%groupNum!=<span class="number">0</span>) &#123;</span><br><span class="line">reShards[i]=ngid</span><br><span class="line">gidToNShards[ngid]++</span><br><span class="line"><span class="keyword">if</span> ok&#123;</span><br><span class="line">gidToNShards[gid]--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reShards</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PartB：Sharded-Key-Value-Server"><a href="#PartB：Sharded-Key-Value-Server" class="headerlink" title="PartB：Sharded Key&#x2F;Value Server"></a>PartB：Sharded Key&#x2F;Value Server</h2><p>现在，你将构建一个分片容错的键&#x2F;值存储系统–shardkv。你将修改 <code>shardkv/client.go</code>、<code>shardkv/common.go</code> 和 <code>shardkv/server.go</code>。</p><p>每个 shardkv 服务器作为副本组的一部分运行。每个副本组为某些键空间分片提供 <code>Get</code>、<code>Put</code> 和 <code>Append</code> 操作。在 client.go 中使用 <code>key2shard()</code> 函数来找出一个键属于哪个分片。多个副本组协同工作以服务完整的分片集合。shardctrler 服务的单个实例负责将分片分配给副本组；当这个分配发生变化时，副本组必须彼此交接分片，同时确保客户端不会看到不一致的响应。</p><p>您的存储系统必须为使用其客户端接口的应用程序提供线性化接口。也就是说，在 shardkv&#x2F;client.go 中的 Clerk.Get()、Clerk.Put() 和 Clerk.Append() 方法完成的应用程序调用必须以相同顺序影响到所有副本。Clerk.Get() 应该能够看到由最近的 Put&#x2F;Append 写入的相同键的值。即使 Gets 和 Puts 几乎同时到达配置更改，这个要求也必须成立。</p><p>您的存储系统必须为使用其客户端接口的应用程序提供线性化接口。也就是说，在 <code>shardkv/client.go</code> 中的 <code>Clerk.Get()</code>、<code>Clerk.Put()</code> 和<code>Clerk.Append()</code> 方法完成的应用程序调用必须以相同顺序影响到所有副本。<code>Clerk.Get()</code> 应该能够看到由最近的 <code>Put/Append</code> 写入的相同键的值。即使 Gets 和 Puts 几乎同时和配置更改一起到达，这个要求也必须成立。</p><p>每个分片只需要在该分片的 Raft 副本组中的大多数服务器是活动的、能够相互通信，并且能够与 shardctrler 服务器的大多数通信时才能取得进展。即使某些副本组中的少数服务器已经停止、暂时不可用或速度较慢，您的实现也必须运行（处理请求并在需要时重新配置）。</p><p>shardkv服务器只是一个单独副本组的成员。给定副本组中的服务器集合将永远不会改变。</p><p>我们提供了 <code>client.go</code> 代码，它会将每个 RPC 发送到负责处理该 RPC 键的副本组。如果副本组表示不负责该键，则客户端代码将进行重试；在这种情况下，客户端代码会向 shard 控制器请求最新的配置，然后再次尝试。您需要修改 <code>client.go</code> 以支持处理重复客户端 RPC，类似 kvraft 实验中的处理方式。</p><p>完成后，你的代码应能通过除挑战测试外的所有 shardkv 测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/<span class="number">6.824</span>/src/shardkv</span><br><span class="line">$ <span class="keyword">go</span> test -race</span><br><span class="line">Test: static shards ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: join then leave ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: snapshots, join, and leave ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: servers miss configuration changes...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: concurrent puts and configuration changes...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: more concurrent puts and configuration changes...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: concurrent configuration change and restart...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: unreliable <span class="number">1.</span>..</span><br><span class="line">  ... Passed</span><br><span class="line">Test: unreliable <span class="number">2.</span>..</span><br><span class="line">  ... Passed</span><br><span class="line">Test: unreliable <span class="number">3.</span>..</span><br><span class="line">  ... Passed</span><br><span class="line">Test: shard deletion (challenge <span class="number">1</span>) ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: unaffected shard access (challenge <span class="number">2</span>) ...</span><br><span class="line">  ... Passed</span><br><span class="line">Test: partial migration shard access (challenge <span class="number">2</span>) ...</span><br><span class="line">  ... Passed</span><br><span class="line">PASS</span><br><span class="line">ok  <span class="number">6.824</span>/shardkv<span class="number">101.503</span>s</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>请注意：服务器不应调用分片控制器的 <code>Join()</code> 处理程序。测试器会在适当的时候调用 Join()。</p><p>任务一：<br>您的第一个任务是通过最初的 shardkv 测试。在这个测试中，只有一个分片的分配，因此您的代码应该与第三次实验（Lab 3）中的服务器代码非常相似。最大的修改将是让您的服务器检测配置变化，并开始接受那些与它现在拥有的分片匹配的键的请求。</p><p>现在您的解决方案已经适用于静态分片情况，现在是时候解决配置更改的问题了。您需要让服务器监视配置更改，一旦检测到变化，就开始分片迁移过程。如果一个副本组失去了一个分片，它必须立即停止为该分片中的键提供服务，并开始将该分片的数据迁移到接管所有权的副本组。如果一个副本组获得了一个分片，它需要等待前一所有者将旧分片数据发送过来，然后才能接受该分片的请求。</p><p>在配置更改期间实施分片迁移非常关键。确保副本组中的所有服务器在执行操作序列时同时进行迁移，这样它们就可以一致地接受或拒绝并发客户端的请求。在处理后续测试之前，着重通过第二个测试（”join then leave”）非常重要。只有通过 TestDelete 之前（不包括 TestDelete）的所有测试，您才能完成这项任务。</p><p>注意：</p><ul><li>你的服务器需要定期轮询分片服务器以了解新的配置。测试希望你的代码大约每 100 毫秒轮询一次；频率高一些没问题，但频率低一些可能会导致问题。</li><li>在配置更改期间，服务器需要相互发送RPC以在分片迁移过程中传输分片。shardctrler 的 Config 结构包含服务器名称，但您需要一个 labrpc.ClientEnd 来发送 RPC。您应该使用传递给 StartServer() 的 make_end() 函数，将服务器名称转换为 ClientEnd。shardkv&#x2F;client.go 包含执行此操作的代码。</li></ul><p>提示：</p><ul><li>在 <code>server.go</code> 中添加代码，以便定期从分片控制器那里获取最新配置，并添加代码，以便在接收组不负责客户端key的分片时拒绝客户端请求。你应该可以通过第一个测试。</li><li>服务器在处理客户端RPC时，如果收到的key不是服务器负责的（即键的分片未分配给服务器的组），应该用 <code>ErrWrongGroup</code> 错误来响应。确保在并发重新配置的情况下，您的 <code>Get</code>、<code>Put</code> 和 <code>Append</code> 处理程序能够正确做出这个决定。</li><li>按顺序逐个处理重新配置。</li><li>如果测试失败，请检查是否有 gob 错误（例如 “gob: type not registered for interface …”）。尽管对于 Go 来说，gob 错误不被视为致命错误，但在本实验中它们是致命的。</li><li>您需要为跨分片移动的客户端请求提供至多一次语义（重复检测）。</li><li>想一想 shardkv 客户端和服务器应该如何处理 <code>ErrWrongGroup</code>。如果客户端收到 <code>ErrWrongGroup</code>，是否应该更改序列号？如果服务器在执行<code> Get/Put</code> 请求时返回 <code>ErrWrongGroup</code>，是否应该更新客户端状态？</li><li>在服务器已经移动到新配置之后，它可以继续存储它不再拥有的分片（尽管在实际系统中这可能不是理想的）。这可能有助于简化服务器的实现。</li><li>当组 G1 在配置更改期间需要从 G2 获取分片时，G2 在处理日志条目时何时将分片发送给 G1 是否重要？</li><li>您可以在 RPC 请求或回复中发送整个 map，这可能有助于使分片传输的代码简单化。</li><li>如果您的某个 RPC 处理程序在回复中包含了服务器状态的某个 map（例如键&#x2F;值 map），可能会出现由于竞争而导致的 bug。RPC 系统需要读取 map 来将其发送给调用者，但它并没有持有该 map 的锁。然而，服务器可能在 RPC 系统读取 map 时继续修改同一个 map。解决方案是让 RPC 处理程序在回复中包含 map 的副本。</li><li>如果您将 map 或 slice 放入 Raft 日志条目中，并且您的键&#x2F;值服务器随后在 applyCh 上看到该条目并将 map&#x2F;slice 的引用保存在键&#x2F;值服务器的状态中，那么可能会出现竞争。请复制 map&#x2F;slice，并将副本存储在键&#x2F;值服务器的状态中。竞争发生在键&#x2F;值服务器修改 map&#x2F;slice 时以及 Raft 在持久化其日志时读取 map&#x2F;slice 之间。</li><li>在配置更改期间，两个组之间可能需要在彼此之间双向移动分片。如果出现死锁，请考虑这个可能是一个源头。</li></ul><h2 id="额外挑战"><a href="#额外挑战" class="headerlink" title="额外挑战"></a>额外挑战</h2><p>如果要建立这样一个用于生产的系统，这两个功能是必不可少的。</p><h3 id="状态的垃圾收集"><a href="#状态的垃圾收集" class="headerlink" title="状态的垃圾收集"></a>状态的垃圾收集</h3><p>当副本组失去对一个分片的所有权时，该副本组应该从其数据库中删除与该分片相关的键，因为它不再为该分片提供服务。然而，这对于迁移会带来一些问题。假设有两个组，G1和G2，并且有一个新的配置C，将分片S从G1移动到G2。如果G1在切换到C时从其数据库中清除了分片S中的所有键，那么当G2尝试切换到C时，它该如何获取分片S的数据呢？</p><p>导致每个副本组保留旧分片的时间不要超过绝对必要的时间。即使像上面的副本组G1中的所有服务器都崩溃然后重新启动，您的解决方案也必须能够正常工作。只要通过了<code>TestChallenge1Delete</code>测试，您就已经完成了这项任务。</p><h3 id="配置更改期间的客户请求"><a href="#配置更改期间的客户请求" class="headerlink" title="配置更改期间的客户请求"></a>配置更改期间的客户请求</h3><p>处理配置更改的最简单方法是在转换完成之前禁止所有客户端操作。虽然在概念上简单，但这种方法在生产级系统中并不可行；每当机器进入或退出时，它会导致所有客户端的长时间暂停。最好的做法是继续为未受正在进行的配置更改影响的分片提供服务。</p><p>修改您的解决方案，使对未受影响的分块中的键的客户端操作在配置更改期间继续执行。通过 <code>TestChallenge2Unaffected</code> 时，您就完成了这项挑战。</p><p>虽然上述优化很好，但我们仍然可以做得更好。假设某个副本组 G3 在转换到 C 时需要来自 G1 的分片 S1，以及来自 G2 的分片 S2。我们真正希望的是，一旦 G3 接收到必要的状态，即使它仍在等待其他分片，也能立即开始为该分片提供服务。例如，如果 G1 宕机，那么一旦 G3 从 G2 接收到了来自 S2 的适当数据，它应该立即开始为 S2 处理请求，尽管转换到 C 尚未完成。</p><p>修改您的解决方案，使复制组在能够为分片提供服务时立即开始服务，即使配置仍在进行中。通过 <code>TestChallenge2Partial</code> 时，您就完成了这项挑战。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>1.需要实现定期轮询分片服务器获取最新<code>config</code>。由Leader进行，然后通过提交日志更新到其他节点。<br>使用一个后台goroutine实现，每隔50ms查询一次。</p><p>2.添加函数实现判断当前的<code>key</code>是否是自己负责的。</p><p>3.添加服务器之间进行map交换的代码<br>这里可能需要进行注册gob</p><p>4.map或slice一定要使用<code>深拷贝</code>。</p><p>5.快照等其他实现，只需要保留服务器的一些额外状态即可。</p><p>6.添加检测config是否改变的代码。比对<code>configNum</code>即可。</p><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>可以完全按照LAB3的代码，并且实现定期轮询分片服务器更新Config和拒绝不属于当前gid的分片请求即可通过第一个测试。</p><h3 id="分片结构"><a href="#分片结构" class="headerlink" title="分片结构"></a>分片结构</h3><p>由于<code>TestChallenge2Unaffected</code>和<code>TestChallenge2Partial</code>任务，我们需要对分片进行单独的管理。也就是说某个<code>Group</code>负责的分片与分片之间互不影响。可能其负责的分片1正在从其他组拉取数据，分片2正常，那么它必须能够响应对应分片2的所有请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ShardData <span class="keyword">struct</span> &#123;</span><br><span class="line">StateShardState</span><br><span class="line">DB    <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ShardState <span class="type">string</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">READY ShardState =<span class="string">&quot;Ready&quot;</span>    <span class="comment">//就绪状态，默认。(可以提供服务)</span></span><br><span class="line">WAITING =<span class="string">&quot;Waiting&quot;</span>  <span class="comment">//等待从其他group拉取数据</span></span><br><span class="line">RECEIVED     =<span class="string">&quot;Received&quot;</span> <span class="comment">//已经从其他group拉取数据，但等待发送分片清除请求。(可以提供服务)</span></span><br><span class="line">GC  =<span class="string">&quot;GC&quot;</span>       <span class="comment">//等待被其他节点拉取，并等待接收清除请求以便被GC</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分片状态机<br><img src="/../../../../img/Pasted%20image%2020240123144020.png"><br><code>Ready-&gt;Waiting</code>：加载新分片配置后，当前group发现自己分配到了新的分片，意味着需要向原来管理该分片的group拉取分片数据。<br><code>Ready-&gt;GC</code>：加载新分片配置后，当前group发现自己不再负责该分片，等待其他group来拉取数据后，进行回收该分片数据。<br><code>Waiting-&gt;Received</code>：向原来管理该分片的group获取到了分片数据，等待向原来group发送GC请求，告诉它已经获取到了数据，可以GC了。<br><code>Received-&gt;Ready</code>：GC请求返回成功，原来group已经成功回收了GC，恢复Ready状态。<br><code>GC-&gt;Ready</code>：不再负责该分片的group，接收到了发来的GC请求，表示对方已获取到分片数据，你可以进行分片回收了，分片回收后，恢复到Ready状态（并情况分片数据）。</p><h3 id="配置检测"><a href="#配置检测" class="headerlink" title="配置检测"></a>配置检测</h3><p>服务器需要定时拉取最新配置，并更新自己的分片配置信息。同样可以使用后台线程进行监控。</p><p>所有服务器的配置只允许逐次更新，不可以跨级更新。比如从<code>config.num=1更新到config.num=3</code>，跳过某些配置。原因是如果在<code>config.num=1</code>时，group管理着该分片，但是在<code>config.num=2</code>时，该分片被其他group管理，假设分片数据在该配置下发送了修改。那么当<code>config.num=3</code>，该分片又恢复到原先的<code>config.num=1</code>时的group管理。如果直接从<code>config.num=1更新到config.num=3</code>，该group无法检测到变化，则就不会从<code>config.num=2</code>的group处拉取分片数据，那么就丢失了<code>config.num=2</code>时该分片的变化。</p><p>当所有分片状态都是<code>Ready</code>时，才可以更新配置。否则如果有分片状态如下：</p><ul><li><code>Waiting</code>：意味着该分片还未拉取数据，此时更新配置，会丢失修改。</li><li><code>GC</code>：分片数据还未清理，更新配置会产生额外分片垃圾。</li><li><code>Received</code>：还未向原来group发送GC请求，那么原先的group无法进行GC，同上。</li></ul><h3 id="分片移动"><a href="#分片移动" class="headerlink" title="分片移动"></a>分片移动</h3><p>务必清楚</p><ul><li>某个gid中的分片移动必须先提交日志，等待集群的raft达成一致后，以raft日志的形式去更新，这样才能保证同一集群的状态一致。</li><li>分片移动的操作由Leader进行还是Follower进行？统一由Leader</li><li>分片获取的操作是Push还是Pull？都可以，但我认为Pull效率高，仅在必要时拉取自己需要的部分</li></ul><p>Leader在更获取最新配置时，需要检测分片管理关系是否发生了变化<br>Case1：<code>newConfig.Shard[index] == gid &amp;&amp; oldConfig.Shard[index] != gid</code>：<br>那么说明需要从targetGid &#x3D; oldConfig.Shard[index]处获取shard为index的分片</p><p>实现1：group1如何从其他group2中拉取分片信息。这个group之间的RPC如何定义？为了方便起见，直接把整个分片信息传过去就好了，也就是整个map。即KVStateMachine中的KVData，注意深拷贝。</p><ul><li>定义一个ShardMigration RPC的args和reply</li><li>定义一个ShardMigrationHandler：来返回其他group需要的分片信息</li><li>定义一个ShardMigration：从其他Server拉取需要的分片信息</li></ul><p>实现2：上述分片移动的过程，是否要阻塞原来的进程。这边感觉是要的，只有拿到最新的分片后，才能继续提供服务。也就是让Leader负责去拿分片，然后通过日志，提交给集群中的其他节点。这样所有节点的分片信息才能保持一致。</p><p>更新配置过程：</p><ol><li>后台线程定期拉取最新配置</li><li>如果拉取配置的Num比当前的大，说明需要更新了<ol><li>需要拉取分片<ol><li>发送RPC拉取分片</li><li>提交分片数据到raft</li><li>更新config</li></ol></li><li>不需要拉取分片，提交config到raft即可。</li></ol></li></ol><p>实现3：定义两种command，用来提交给raft。一个是更新config。一个是更新分片KV数据<br>实现4：思考先更新Config还是等待Shard移动完毕后，再更新Config<br>先更新Config，再检查是否需要拉取分片数据，</p><p>重新定义状态机结构，这样就不必把整个分片数据都传过去。只传递对应<code>Shard</code>的<code>ShardData</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="type">int</span>] ShardData <span class="comment">// shard -&gt; ShardData</span></span><br><span class="line"></span><br><span class="line">ShardData&#123;</span><br><span class="line">State  ShardState  <span class="comment">//ready / updating / gc</span></span><br><span class="line">DB     <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>checkConfig后台线程:每50ms拉取最新配置</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1.如果当前配置已经是最新，直接返回</span><br><span class="line"></span><br><span class="line">// 2.拉取到最新配置</span><br><span class="line">2.1 通过Raft同步最新的Config。</span><br><span class="line">2.2 检查分片修改,同样通过Raft进行分片信息的修改。</span><br><span class="line">// 需要从targetGid拉取分片,提交给Raft</span><br><span class="line">// 需要进行GC,提交给Raft</span><br><span class="line">// Shard:分片号,newState:新状态</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>updateShardData后台线程:定期刷新分片数据</code>，这个感觉的用nodify机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 不断检查ShardData的状态</span><br><span class="line">1.updating:说明需要更新，向targetGid发送RPC拉取分片数据。</span><br><span class="line">2.GC:说明这个分片后续不再需要了,这个需要收到远程RPC后在进行，确保另外服务器已经更新了DB</span><br><span class="line">3.ready:正常状态，只有GC/ready的状态才可以响应客户端。</span><br></pre></td></tr></table></figure><p><code>applier后台线程:处理Raft应用到状态机命令</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 收到快照或其他消息，这边先不讨论</span><br><span class="line"></span><br><span class="line">// 1.updateConfig Msg:更新配置</span><br><span class="line">kv.cfg = newConfig</span><br><span class="line"></span><br><span class="line">// 2.updateShardState Msg:更新分片状态，由checkConfig线程触发</span><br><span class="line">kv.KVStateMachine.ShardData[shard].state = newState</span><br><span class="line"></span><br><span class="line">// 3.updateShardData Msg:更新分片数据，由updateShardData线程触发</span><br><span class="line">1.kv.KVStateMachine.ShardData[shard].DB : 需要对两个map进行合并</span><br><span class="line">2.更新cacheMap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Msg结构</span><br><span class="line">Type</span><br><span class="line">NewConfig</span><br><span class="line">Shard</span><br><span class="line">NewState</span><br><span class="line">DB</span><br><span class="line">CacheMap</span><br></pre></td></tr></table></figure><h3 id="分片回收"><a href="#分片回收" class="headerlink" title="分片回收"></a>分片回收</h3><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><ol><li><p>无法通过<code>TestConcurrent</code>以及<code>TestUnreliable</code>的所有子测试。似乎put操作有缺失<br>分片拉取的时候没有判断是否是leader,只有leader才能发送分片数据给其他节点。大部分是没有进行幂等性设计，导致重复执行了某个非幂等操作。</p></li><li><p>空指针异常&#x2F;无效地址</p></li><li><p>某个节点进行了Append操作，但是后来又收到了分片数据，覆盖了整个Append操作。导致修改丢失了。<br>接收分片的时候没有进行<strong>幂等性</strong>设计，导致如果第一次接收后，分片已经Ready了，此时进行了Append操作，然后又收到了一次接受分片的信息，那么这个Append操作就被覆盖了。</p></li><li><p><code>configNum</code>一定要逐次加1，这个思考一下为什么。</p></li><li><p><code>TestConcurrent3</code>无法推进<br>原因如out日志，27119行-27227行左右。各组之间不断相互Ask Shard Data导致互相等待。原因是不能仅通过<code>kv.rf.Start(Command)</code>进行修改，而是等确保<code>Command</code>一定被执行后再返回ok，因为<code>kv.rf.Start(Command)</code>不是一定执行成功的。可能此时Leader掉线了或不是Leader。如果要保证指令执行成功需要通过<code>ApplyCh</code>监听到该指令被应用于状态机才行。<br><strong>这个问题还是没解决</strong></p></li></ol><p>更新分片状态的时机</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> ShardGCHandler(args *ShardMigrationArgs, reply * ShardMigrationReply)&#123;</span><br><span class="line"><span class="keyword">if</span> _,isLeader := kv.rf.GetState();!isLeader&#123;</span><br><span class="line">reply.Err = ErrWrongLeader</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">kv.mu.RLock()</span><br><span class="line"><span class="keyword">if</span> args.ConfigNum &gt; kv.config.Num&#123;</span><br><span class="line">DPrintf(<span class="string">&quot;[Delete ShardData Fail][ShardGCHandler] Server[%d]-[%d] send shard[%d] with config[%d] : [%d] | %s\n&quot;</span>, kv.gid,kv.me,args.Shard,args.ConfigNum,kv.config.Num,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">reply.Err = OK</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">kv.mu.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bug</span></span><br><span class="line"><span class="comment">//kv.rf.Start(ShardOp&#123;</span></span><br><span class="line"><span class="comment">//Type: GC_SHARD,</span></span><br><span class="line"><span class="comment">//Shard: args.Shard,</span></span><br><span class="line"><span class="comment">//ConfigNum: args.ConfigNum,</span></span><br><span class="line"><span class="comment">//&#125;)</span></span><br><span class="line"><span class="keyword">var</span> commandReply CommandReply</span><br><span class="line">kv.ShardCommand(&amp;ShardOp&#123;</span><br><span class="line">Type: GC_SHARD,</span><br><span class="line">Shard: args.Shard,</span><br><span class="line">ConfigNum: args.ConfigNum,</span><br><span class="line">&#125;,&amp;commandReply)</span><br><span class="line">reply.Shard = args.Shard</span><br><span class="line">reply.ConfigNum = args.ConfigNum</span><br><span class="line">reply.Err = commandReply.Err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bug代码如上，考虑到如果<code>GC_SHARD</code>操作没有执行成功，此时RPC返回OK，那么发送请求的Server已经认为目标Server成功删除了分片（实际未成功），此时发送请求的Server修改分片状态。但目标Server的状态还是<code>GC</code>，导致它无法更新<code>Config</code></p><p>参考<br><a href="https://www.jianshu.com/p/f5c8ab9cd577">8.MIT 6.824 LAB 4B(分布式shard database) - 简书 (jianshu.com)</a><br><a href="https://blog.csdn.net/weixin_45938441/article/details/125566763">MIT-6.824-lab4B-2022(万字思路讲解-代码构建）_6.824 lab-CSDN博客</a><br><a href="https://github.com/OneSizeFitsQuorum/MIT6.824-2021/blob/master/docs/lab4.md">MIT6.824-2021&#x2F;docs&#x2F;lab4.md at master · OneSizeFitsQuorum&#x2F;MIT6.824-2021 (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 微服务和分布式 </category>
          
          <category> 6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab 3.KVRaft</title>
      <link href="/posts/82d7eaa9/"/>
      <url>/posts/82d7eaa9/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-3-KVRaft"><a href="#Lab-3-KVRaft" class="headerlink" title="Lab 3 - KVRaft"></a>Lab 3 - KVRaft</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在本实验中，您将使用lab 2 中的 Raft 库构建容错的键&#x2F;值存储服务。您的键&#x2F;值服务将是一个复制状态机，由多个使用 Raft 进行复制的键&#x2F;值服务器组成。只要大部分服务器还活着并能通信，那么即使出现其他故障或网络分区，您的键&#x2F;值服务也能继续处理客户端请求。lab 3 结束后，您将实现 Raft 交互图中所示的所有部分（服务器、服务和 Raft）。<br><img src="/../../../../img/Pasted%20image%2020231203164859.png"></p><p>客户端可以向键&#x2F;值服务发送<strong>三种</strong>不同的 RPC：<code>Put(key,value)</code>、<code>Append(key,arg)</code> 和 <code>Get(key)</code>。该服务维护一个简单的键&#x2F;值对数据库。键和值都是字符串。<code>Put(key,value)</code>会替换数据库中特定键的值，<code>Append(key,arg)</code>会将 <code>arg</code> 追加到键的值中，而 <code>Get(key)</code> 则会获取键的当前值。对于不存在的键，<code>Get</code> 应返回空字符串。对不存在的键进行<code>Append</code> 的操作应与 <code>Put</code> 类似。每个客户端都通过一个使用 <code>Put/Append/Get</code> 方法的<code>Clerk</code>与服务对话。<code>Clerk</code>负责管理与服务器之间的 RPC 交互。</p><p>您的服务必须确保对<code>Clerk</code> Get&#x2F;Put&#x2F;Append 方法的应用程序调用是可线性化的。如果逐次调用，Get&#x2F;Put&#x2F;Append 方法的作用应如同系统只有一份状态副本，每次调用都应遵守前一轮调用对状态的修改。对于并发调用，返回值和最终状态必须与按一定顺序逐次执行的操作相同。如果调用在时间上重叠，则属于并发调用：例如，客户机 X 调用 <code>Clerk.Put()</code>，客户机 Y 调用 <code>Clerk.Append()</code>，然后客户机 X 的调用返回。一个调用必须观察所有在该调用开始前已完成的调用的效果。</p><p>线性化对应用程序来说非常方便，因为它是一次处理一个请求的单个服务器的行为。例如，如果一个客户端从服务中成功响应了一个更新请求，那么其他客户端随后启动的读取就能保证看到该更新的效果。对于单个服务器来说，提供线性化相对容易。如果服务是复制的，就比较困难，因为所有服务器都必须为并发请求选择相同的执行顺序，必须避免使用不是最新的状态回复客户端，而且必须在故障后以保留所有已确认客户端更新的方式恢复状态。</p><p>本实验分为两部分。在 A 部分中，您将使用 Raft 实现来实现键&#x2F;值服务，但不使用快照。在 B 部分中，您将使用Lab 2D 中的快照实现，这将允许 Raft 丢弃旧的日志条目。请在各部分的截止日期前提交。</p><p>您应该阅读 Raft 的扩展论文，尤其是第 7 和第 8 节。如需更广阔的视角，请参阅 Chubby、Paxos Made Live、Spanner、Zookeeper、Harp、Viewstamped Replication 和 <a href="http://static.usenix.org/event/nsdi11/tech/full_papers/Bolosky.pdf">Bolosky et al.</a></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>我们在 <code>src/kvraft</code> 中为您提供了骨架代码和测试。您需要修改 <code>kvraft/client.go</code>、<code>kvraft/server.go</code> 和 <code>kvraft/common.go</code></p><h2 id="Part-A：不带快照的键-值服务"><a href="#Part-A：不带快照的键-值服务" class="headerlink" title="Part A：不带快照的键&#x2F;值服务"></a>Part A：不带快照的键&#x2F;值服务</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>每个你的键&#x2F;值服务器（”kvservers”）都有一个关联的 Raft peer。办事员向关联 Raft Leader 的 kvserver 发送 <code>Put()</code>、<code>Append()</code> 和 <code>Get()</code> RPCs。kvserver 代码将 Put&#x2F;Append&#x2F;Get 操作提交给 Raft，这样 Raft 日志中就保存了一系列 Put&#x2F;Append&#x2F;Get 操作。所有 kvserver 都会按顺序执行 Raft 日志中的操作，并将这些操作应用到它们的键&#x2F;值数据库中；这样做的目的是让服务器保持键&#x2F;值数据库的相同副本。</p><p><code>Clerk</code>有时不知道哪个 kvserver 是 Raft 的Leader。如果<code>Clerk</code>向错误的 kvserver 发送了 RPC，或者无法联系到该 kvserver，办事员就应该换一个 kvserver 重试。如果 key&#x2F;value 服务将操作提交到了它的 Raft 日志（并因此将操作应用到了 key&#x2F;value 状态机），那么Leader就会通过响应办事器的 RPC 来向<code>Clerk</code>报告结果。如果操作提交失败（例如，领导者被替换），服务器就会报错，<code>Clerk</code>就会换一个服务器重试。</p><p>您的 kvservers 不应直接通信；它们只应通过 Raft 进行交互。</p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>您的首要任务是实施一个解决方案，在没有丢弃报文和服务器故障的情况下生效。  </p><p>您需要在 <code>client.go</code> 中的 Clerk Put&#x2F;Append&#x2F;Get 方法中添加 RPC 发送代码，并在 <code>server.go</code> 中实现 <code>PutAppend()</code> 和 <code>Get()</code> RPC 处理程序。这些处理程序应使用 <code>Start()</code> 在 Raft 日志中输入 <code>Op</code>；您应在 <code>server.go</code> 中填写 <code>Op</code> 结构定义，以便描述 Put&#x2F;Append&#x2F;Get 操作。每个服务器都应在 Raft 提交 <code>Op</code> 命令（即出现在 applyCh 上的命令）时执行这些命令。RPC 处理程序应在 Raft 提交 Op 命令时注意到，然后回复 RPC。  </p><p>当您可靠地通过测试中的第一个测试时，您就完成了这项任务：”一个客户端”。</p><p>提示：</p><ul><li>调用 <code>Start()</code> 后，kvservers 需要等待 Raft 完成协议。已达成一致意见的命令会发送到<code>applyCh</code>。当 <code>PutAppend()</code> 和 <code>Get()</code> 处理程序使用 <code>Start()</code> 向 Raft 日志提交命令时，你的代码需要继续读取 <code>applyCh</code>。小心 kvserver 与其 Raft 库之间的死锁。</li><li>您可以在 Raft <code>ApplyMsg</code> 中添加字段，也可以在 Raft RPC（如 AppendEntries）中添加字段，但这对大多数实现来说并非必要。</li><li>如果<code>Get()</code> RPC 不属于多数数据，则 kvserver 不应完成该<code>Get()</code> RPC（这样它就不会提供过期数据）。一个简单的解决方案是在 Raft 日志中输入每一次 <code>Get()</code>（以及每一次 <code>Put()</code>和 <code>Append()</code>）。您不必执行第 8 节所述的只读操作优化。</li><li>最好从一开始就添加锁，因为避免死锁的需要有时会影响整个代码的设计。使用 go test -race 检查代码是否无竞赛。</li></ul><p>现在，您应该修改解决方案，以便在网络和服务器出现故障时继续运行。你将面临的一个问题是，<code>Clerk</code>可能不得不多次发送 RPC，直到找到一个作出积极回复的 kvserver。如果Leader在向 Raft 日志提交条目后发生故障，<code>Clerk</code>可能收不到回复，因此可能会重新向另一个领导者发送请求。每次调用 <code>Clerk.Put()</code> 或 <code>Clerk.Append()</code> 都只需执行一次，因此必须确保重新发送不会导致服务器执行两次请求。</p><p>添加代码以处理故障，并处理重复的<code>Clerk</code>请求，包括<code>Clerk</code>向某个任期的 kvserver 领导者发送请求，在等待回复时超时，然后向另一个学期的新Leader重新发送请求的情况。请求应该只执行一次。您的代码应通过 go test -run 3A -race 测试。</p><p>提示：</p><ul><li>您的解决方案需要处理这样一种情况：Leader为<code>Clerk</code>的 RPC 调用了 <code>Start()</code>，但在请求提交到日志之前失去了领导权。在这种情况下，你应该安排<code>Clerk</code>向其他服务器重新发送请求，直到找到新的领导者。一种方法是让服务器通过注意到 <code>Start()</code> 返回的索引中出现了不同的请求，或者 Raft 的任期发生了变化，来检测到自己失去了领导权。如果前领导者是自己分区的，它就不会知道新的领导者；但同一分区的任何客户端也无法与新的领导者对话，因此在这种情况下，服务器和客户端可以无限期地等待，直到分区愈合。</li><li>您可能需要修改您的 Clerk，以便记住哪台服务器是上一个 RPC 的领导者，并将下一个 RPC 首先发送到该服务器。这样可以避免浪费时间在每一次 RPC 中寻找领导者，从而帮助你快速通过某些测试。</li><li>您需要唯一标识客户操作，以确保键&#x2F;值服务对每个操作只执行一次。</li><li>您的重复检测方案应能迅速释放服务器内存，例如，每次 RPC 都意味着客户端已看到前一次 RPC 的回复。假设客户端一次只调用一个<code>Clerk</code>也没有问题。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ go test -run 3A</span><br><span class="line">Test: one client (3A) ...</span><br><span class="line">  ... Passed --  15.1  5 12882 2587</span><br><span class="line">Test: many clients (3A) ...</span><br><span class="line">  ... Passed --  15.3  5  9678 3666</span><br><span class="line">Test: unreliable net, many clients (3A) ...</span><br><span class="line">  ... Passed --  17.1  5  4306 1002</span><br><span class="line">Test: concurrent append to same key, unreliable (3A) ...</span><br><span class="line">  ... Passed --   0.8  3   128   52</span><br><span class="line">Test: progress in majority (3A) ...</span><br><span class="line">  ... Passed --   0.9  5    58    2</span><br><span class="line">Test: no progress in minority (3A) ...</span><br><span class="line">  ... Passed --   1.0  5    54    3</span><br><span class="line">Test: completion after heal (3A) ...</span><br><span class="line">  ... Passed --   1.0  5    59    3</span><br><span class="line">Test: partitions, one client (3A) ...</span><br><span class="line">  ... Passed --  22.6  5 10576 2548</span><br><span class="line">Test: partitions, many clients (3A) ...</span><br><span class="line">  ... Passed --  22.4  5  8404 3291</span><br><span class="line">Test: restarts, one client (3A) ...</span><br><span class="line">  ... Passed --  19.7  5 13978 2821</span><br><span class="line">Test: restarts, many clients (3A) ...</span><br><span class="line">  ... Passed --  19.2  5 10498 4027</span><br><span class="line">Test: unreliable net, restarts, many clients (3A) ...</span><br><span class="line">  ... Passed --  20.5  5  4618  997</span><br><span class="line">Test: restarts, partitions, many clients (3A) ...</span><br><span class="line">  ... Passed --  26.2  5  9816 3907</span><br><span class="line">Test: unreliable net, restarts, partitions, many clients (3A) ...</span><br><span class="line">  ... Passed --  29.0  5  3641  708</span><br><span class="line">Test: unreliable net, restarts, partitions, many clients, linearizability checks (3A) ...</span><br><span class="line">  ... Passed --  26.5  7 10199  997</span><br><span class="line">PASS</span><br><span class="line">ok      kvraft  237.352s</span><br></pre></td></tr></table></figure><p><img src="/../../../../img/Pasted%20image%2020231203213204.png"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>超时机制<br>client需要防止给过时的Leader发送请求，导致无限等待。可以尝试轮流给每个节点都发送请求直到返回<code>OK</code>，并记录当前节点ID，认为它是当前的Leader，下次优先向该节点发送请求，加以优化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> sendCommand(key <span class="type">string</span>,value <span class="type">string</span>,opType OpType) <span class="type">string</span> &#123;</span><br><span class="line"><span class="comment">// add commanId</span></span><br><span class="line">atomic.AddInt64(&amp;ck.commandId,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> args = CommandArgs&#123;</span><br><span class="line">Key: key,</span><br><span class="line">Value: value,</span><br><span class="line">Type: opType,</span><br><span class="line">ClientId: ck.clientId,</span><br><span class="line">CommandId: ck.commandId,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// keep send rpc to servers util success</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">var</span> reply = CommandReply&#123;&#125;</span><br><span class="line"><span class="comment">//DPrintf(&quot;[Client Request][sendCommand]: Client[%d] received a request:[%v] to Server[%d]| %s\n&quot;,ck.clientId,args,ck.leaderId,time.Now().Format(&quot;15:04:05.000&quot;))</span></span><br><span class="line">ok := ck.servers[ck.leaderId].Call(<span class="string">&quot;KVServer.Command&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> ok&#123;</span><br><span class="line"><span class="keyword">if</span> reply.Err == OK&#123;</span><br><span class="line"><span class="keyword">return</span> reply.Value</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> reply.Err == ErrNoKey&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// try another,leaderId = (leaderId+1)%nServers</span></span><br><span class="line">ck.leaderId = (ck.leaderId+<span class="number">1</span>)%ck.nServers</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">ck.leaderId = (ck.leaderId+<span class="number">1</span>)%ck.nServers</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求重复执行<br><code>server</code>需要确保同一个请求不会被重复执行。并且raft可以提交同一个操作日志多次，但只能执行一次。即使是幂等的。实现线性化语义，就需要保证日志仅被执行一次，即它可以被 commit 多次，但一定只能 apply 一次。否则就不满足线性一致性。</p><p>考虑如下操作：<br>A：put(x,1)<br>B：get(x) -&gt; put(x,2)<br>在线性一致性系统中（B读取到的值，x的最终值）可能为（1，2）、（0，2）、（0，1）<br>如果A的put(x,1)被apply了多次，即使它是幂等性操作，也会导致上述结果为（1，1）。也就是当执行了<br>A:put(x,1)-&gt;B:get(x)-&gt;B:put(x,2)-&gt;A:put(x,1)。这不符合线性一致性系统。</p><p>一个出乎意料的BUG</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> applier() &#123;</span><br><span class="line"><span class="keyword">for</span> !kv.killed()&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg:=&lt;-kv.applyCh:</span><br><span class="line"><span class="keyword">if</span> msg.SnapshotValid&#123;</span><br><span class="line"><span class="comment">// apply snapshot</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// todo</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> msg.CommandValid&#123;</span><br><span class="line"><span class="comment">// apply to state machine</span></span><br><span class="line">kv.mu.Lock()</span><br><span class="line"><span class="comment">// outdated command</span></span><br><span class="line"><span class="keyword">if</span> msg.CommandIndex&lt;=kv.lastApplied&#123;</span><br><span class="line">DPrintf(<span class="string">&quot;[Outdated Msg][applier()]: Server[%d] discards outdated message with index[%d],lastApplied[%d] | %s\n&quot;</span>,kv.me,msg.CommandIndex,kv.lastApplied,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kv.lastApplied = msg.CommandIndex</span><br><span class="line">command:=msg.Command.(Op)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> commandReply CommandReply</span><br><span class="line"><span class="keyword">if</span> command.Type!=GET &amp;&amp; kv.hasCache(command.ClientId,command.CommandId)&#123;</span><br><span class="line">DPrintf(<span class="string">&quot;[Duplicate Msg][applier()]: Server[%d] find a duplicated message clientId:[%d] commandId:[%d] | %s\n&quot;</span>,kv.me,command.ClientId,command.CommandId,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">commandReply.Err=OK</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">commandReply = kv.applyToStateMachine(command)</span><br><span class="line"><span class="keyword">if</span> command.Type!=GET&#123;</span><br><span class="line">kv.cacheMap[command.ClientId]=command.CommandId</span><br><span class="line">&#125;</span><br><span class="line">DPrintf(<span class="string">&quot;[Apply Msg][applier()]: Server[%d] apply a command to state machine command:[%v] | %s\n&quot;</span>,kv.me,command,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line"><span class="comment">//fmt.Printf(&quot;[Apply Msg][applier()]: Server[%d] apply a command to state machine command:[%d] | %s\n&quot;,kv.me,msg.CommandIndex,time.Now().Format(&quot;15:04:05.000&quot;))</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if leader</span></span><br><span class="line">currentTerm,isLeader:=kv.rf.GetState()</span><br><span class="line">DPrintf(<span class="string">&quot;[DEBUG][applier()]: Server[%d] in term[%d] and isLeader[%t] msg:[%d] | %s\n&quot;</span>,kv.me,currentTerm,isLeader,msg.CommandTerm,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> isLeader &amp;&amp; currentTerm == msg.CommandTerm &#123;</span><br><span class="line">ch,ok:= kv.waitChMap[msg.CommandIndex]</span><br><span class="line"><span class="keyword">if</span> ok&#123;</span><br><span class="line">ch&lt;-commandReply</span><br><span class="line">DPrintf(<span class="string">&quot;[Notify Msg][applier()]: Server[%d] notify waitCh with a reply:[%v] | %s\n&quot;</span>,kv.me,commandReply,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line"><span class="comment">//fmt.Printf(&quot;[Notify Msg][applier()]: Server[%d] notify waitCh with a reply:[%d] | %s\n&quot;,kv.me,msg.CommandIndex,time.Now().Format(&quot;15:04:05.000&quot;))</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加了<code>select - case - default</code>运行变得很慢<br>对于在for不断循环的select语句，不宜使用default语句，否则会一直循环的执行default语句，<strong>引起cpu占用过高的现象</strong>。如果不加default，select就会一直阻塞，直到其中一个通道准备就绪，并不会一直死循环。</p><h2 id="Part-B：具有日志压缩功能的键-值服务"><a href="#Part-B：具有日志压缩功能的键-值服务" class="headerlink" title="Part B：具有日志压缩功能的键&#x2F;值服务"></a>Part B：具有日志压缩功能的键&#x2F;值服务</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>目前的情况是，你的 key&#x2F;value 服务器并没有调用 Raft 库的 <code>Snapshot()</code> 方法，因此重启的服务器必须重放完整的持久化 Raft 日志才能恢复其状态。现在，你将修改 kvserver，以便与 Raft 合作，使用 Lab 2D 中的 <code>Raft Snapshot()</code> 来节省日志空间并缩短重启时间。</p><p>测试会将 <code>maxraftstate</code> 传递给 <code>StartKVServer()</code>。maxraftstate 表示持久化 Raft 状态允许的最大大小，单位为字节（包括日志，但不包括快照）。应将 maxraftstate 与 persister.RaftStateSize() 进行比较。每当键&#x2F;值服务器检测到 Raft 状态的大小接近这个阈值时，它就应该调用 Raft 的快照功能来保存快照。maxraftstate 适用于 Raft 传递给 persister.SaveRaftState() 的 GOB 编码字节。</p><p>修改 kvserver，使它能在持久化的 Raft 状态过大时检测到，然后将快照交给 Raft。当 kvserver 服务器重新启动时，它应从 <code>persister</code> 读取快照，并从快照中恢复其状态。</p><p>提示：</p><ul><li>思考 kvserver 应在何时对其状态进行快照，以及快照中应包含哪些内容。Raft 会使用 <code>SaveStateAndSnapshot()</code> 将每个快照连同相应的 Raft 状态一起存储到 <code>persister</code> 对象中。您可以使用 ReadSnapshot() 读取最新存储的快照。</li><li>kvserver 必须能检测到日志中跨检查点的重复操作，因此快照中必须包含用于检测重复操作的任何状态。</li><li>将快照中存储的结构的所有字段大写。</li><li>您的 Raft 库中可能存在本实验室暴露的错误。如果您修改了 Raft 实现，请确保它能继续通过Lab 2 的所有测试。</li><li>Lab 3 测试所需的合理时间为 400 秒实际时间和 700 秒 CPU 时间。此外，<code>go test -run TestSnapshotSize</code> 实际耗时应少于 20 秒。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ go test -run 3B -race</span><br><span class="line">Test: InstallSnapshot RPC (3B) ...</span><br><span class="line">  ... Passed --   4.0  3   289   63</span><br><span class="line">Test: snapshot size is reasonable (3B) ...</span><br><span class="line">  ... Passed --   2.6  3  2418  800</span><br><span class="line">Test: ops complete fast enough (3B) ...</span><br><span class="line">  ... Passed --   3.2  3  3025    0</span><br><span class="line">Test: restarts, snapshots, one client (3B) ...</span><br><span class="line">  ... Passed --  21.9  5 29266 5820</span><br><span class="line">Test: restarts, snapshots, many clients (3B) ...</span><br><span class="line">  ... Passed --  21.5  5 33115 6420</span><br><span class="line">Test: unreliable net, snapshots, many clients (3B) ...</span><br><span class="line">  ... Passed --  17.4  5  3233  482</span><br><span class="line">Test: unreliable net, restarts, snapshots, many clients (3B) ...</span><br><span class="line">  ... Passed --  22.7  5  3337  471</span><br><span class="line">Test: unreliable net, restarts, partitions, snapshots, many clients (3B) ...</span><br><span class="line">  ... Passed --  30.4  5  2725  274</span><br><span class="line">Test: unreliable net, restarts, partitions, snapshots, random keys, many clients (3B) ...</span><br><span class="line">  ... Passed --  37.7  7  8378  681</span><br><span class="line">PASS</span><br><span class="line">ok  6.824/kvraft161.538s</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>快照的目的：</p><ul><li>通过保存当前状态，压缩日志信息，将已经提交到状态机的日志废弃。</li><li>快速恢复，当Server崩溃后，可以快速通过快照中存储的“较新”状态来恢复，而不必对所有日志进行重放。只需要重放快照lastIncludedIndex之后的日志即可。</li></ul><p>首先需要考虑对于Raft协议之上的<strong>状态机</strong>哪些数据需要放到快照中。</p><ul><li>状态机的状态数据：这毫无疑问是肯定需要进行快照的，因为快照的目的就是通过状态取代日志信息。</li><li>状态机存储的客户端回复缓存：这使得状态机在崩溃恢复后，能够知道回复客户端的情况，避免出现重复执行指令，保证幂等性。考虑如下情况：客户端A发送了一个PUT&#x2F;APPEND请求，Server执行成功了（缓存中有该请求了），但还未来得及回复客户端前，就崩溃了。客户端超时未收到答复会进行重试，那么当Server重启后，如果没保存客户端回复缓存的话，会再次执行请求，破坏了幂等性原则。</li></ul><p>快照的流程：</p><ol><li>Servers认为需要对状态机进行一次快照（可能是日志数量&#x2F;大小达到了某个阈值）</li><li>生成快照，并通过调用Raft的<code>Snapshot()</code>方法通知Raft执行快照。</li><li>更新状态机必要的数据，lastSnapshot更新为lastApplied，表示快照中最后提交的日志索引</li></ol><p>服务器安装快照流程：</p><ol><li>某个服务器可能由于停机很久，导致状态落后很多。那么Leader会发送它最新的快照来让其快速恢复。</li><li>Raft层收到Leader发来的快照后，先更新Raft中的状态，然后向上层应用（即状态机或Server）发送一个<code>SnapshotValid = true</code>的AppleMsg，告诉Server需要更新自己的状态。</li><li>Server收到后，更新自己的状态数据以及lastApplied。</li></ol><p>注意的地方，调用快照的时机。本实验中raft的状态数据大小不可超过<code>8 * maxraftstate</code>,否则会无法通过测试。那么服务器可以在<strong>每次从ApplyCh收到Raft提交的msg</strong>后来检测RaftStateSize()，为保守起见，认为<code>RaftStateSize() &gt; maxraftstate</code>时就执行快照。并且这里需要使用<strong>同步阻塞</strong>的方式，否则可能不断有新的日志添加，导致超出大小限制。这里网上很多的参考答案通过另外启动一个全局线程，定期检查RaftState大小来实现，但这种方式可能会有问题，如果在某一个检测间隔内，服务器收到大量的请求，那么很容易就超了。</p><p>修复一个BUG：当server等待raft达成共识后，返回AppleMsg时，开启和关闭waitCh的方式<br>BUG</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// command()伪代码</span></span><br><span class="line"><span class="comment">//让raft接受命令</span></span><br><span class="line">Start(command)</span><br><span class="line"><span class="keyword">if</span> not leader&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// create a waitCh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个过程中可能raft已经完成同步且上层状态机也applier了指令</span></span><br><span class="line">kv.mu.Lock()</span><br><span class="line">ch:=kv.getWaitCh(index)</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> res:=&lt;-ch:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用超时机制，那么是不会有问题的，因为超时后，Client会重新发请求</span></span><br><span class="line"><span class="comment">//case &lt;-time.After(TIMEOUT*time.Millisecond):</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">// close a waitCh</span></span><br><span class="line"><span class="keyword">go</span> kv.clearWaitCh(index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// applier()伪代码 错误</span></span><br><span class="line"><span class="keyword">if</span> isLeader &amp;&amp; currentTerm == msg.CommandTerm &#123;</span><br><span class="line">ch,ok:=kv.waitChMap[msg.CommandIndex]</span><br><span class="line"><span class="keyword">if</span> ok&#123;</span><br><span class="line">ch&lt;-commandReply</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确写法</span></span><br><span class="line"><span class="keyword">if</span> isLeader &amp;&amp; currentTerm == msg.CommandTerm &#123;</span><br><span class="line">ch := kv.getWaitCh(msg.CommandIndex)</span><br><span class="line">ch&lt;-commandReply</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getWaitCh的逻辑是 没有则创建，有则返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> getWaitCh(index <span class="type">int</span>) <span class="keyword">chan</span> CommandReply &#123;</span><br><span class="line">ch,ok := kv.waitChMap[index]</span><br><span class="line"><span class="keyword">if</span> !ok&#123;</span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> CommandReply,<span class="number">1</span>)</span><br><span class="line">kv.waitChMap[index] = ch</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质是创建waitCh的时机。不知道谁先谁后</p><ul><li>如果command中已经创建了Ch，那么通过kv.waitChMap[msg.CommandIndex]获取是没问题的。</li><li>如果applier在command创建Ch之前就达成了一致，并发送了AppleMsg,那么就拿不到Ch,意味着select会一直阻塞。如果不设置超时，command会无限阻塞。解决办法是如果applier先，那么就applier创建Ch。</li></ul><p>总结：</p><ol><li>对于<code>Server</code>，所有修改<code>Server</code>状态的操作都需要提交给<code>Raft</code>层来完成，保持集群<strong>内部统一</strong>。上层应用通过调用<code>rf.Start(Command)</code>方法提交命令给<code>Raft层</code>，然后从<code>ApplyCh</code>中监听<code>Raft</code>提交的命令，并执行应用到状态机。</li><li><code>rf.Start(Command)</code>的命令未必一定会被Apply，考虑到Leader还没将Command广播出去就挂了的情况。</li><li>对状态机所有的修改必须在<code>Applier</code>方法中通过<code>ApplyCh</code>拿到的已经被<code>raft</code>提交的日志</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 微服务和分布式 </category>
          
          <category> 6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab 2.Raft</title>
      <link href="/posts/afaac1c/"/>
      <url>/posts/afaac1c/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-2-Raft"><a href="#Lab-2-Raft" class="headerlink" title="Lab 2 - Raft"></a>Lab 2 - Raft</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="/../../../../img/Pasted%20image%2020231101102828.png"></p><p>这是一系列实验室中的第一个，您将在其中建立一个<strong>容错键&#x2F;值存储</strong>系统。在本实验中，你将实现 <strong>Raft</strong>（一种复制状态机协议）。在下一个实验室中，你将在 Raft 的基础上构建一个键&#x2F;值服务。然后，您将在多个复制状态机上 “分片 “您的服务，以获得更高的性能。</p><p>复制服务通过在多个复制服务器上存储其状态（即数据）的完整副本来实现容错。即使部分服务器出现故障（崩溃或网络中断或不稳定），复制也能使服务继续运行。所面临的挑战是，故障可能会导致副本持有不同的数据副本。</p><p>Raft 将客户端请求整理成一个序列（称为日志），并确保所有副本服务器都能看到相同的日志。每个副本按日志顺序执行客户端请求，并将这些请求应用到服务状态的本地副本中。由于所有实时副本都能看到相同的日志内容，因此它们都会以相同的顺序执行相同的请求，从而继续保持相同的服务状态。如果服务器出现故障，但随后又恢复了，Raft 会负责更新其日志。只要至少有大多数服务器还活着并能相互通信，Raft 就会继续运行。如果没有过半数的服务器存活，Raft 将不会取得任何进展，但只要有过半数的服务器能再次通信，Raft 就会继续运行。</p><p>在本实验室中，您将把 Raft 作为 Go 对象类型来实现，并提供相关方法，以便在更大的服务中作为一个模块使用。一组 Raft 实例通过 RPC 相互通信，以维护复制的日志。您的 Raft 接口将支持一连串编号不确定的命令，也称为日志条目。条目用<strong>索引号</strong>编号。具有给定索引的日志条目最终将被提交。此时，您的 Raft 应将日志条目发送给更大的服务，以便其执行。</p><p>您应该遵循<a href="http://nil.csail.mit.edu/6.824/2020/papers/raft-extended.pdf">拓展Raft论文</a>中的设计，尤其要注意图 2。您将实现论文中的大部分内容，包括保存持久状态，以及在节点失效后重新启动时读取持久状态。您将不会实现集群成员变更（第 6 节）。您将在稍后的实验中实现日志压缩&#x2F;快照（第 7 节）。</p><p>您可能会发现本指南以及有关<a href="http://nil.csail.mit.edu/6.824/2020/labs/raft-locking.txt">锁</a>和并发<a href="http://nil.csail.mit.edu/6.824/2020/labs/raft-locking.txt">结构</a>的建议非常有用。如需更广阔的视角，请参阅 Paxos、Chubby、Paxos Made Live、Spanner、Zookeeper、Harp、Viewstamped Replication 和 Bolosky et al.</p><p>本实验应分三部分完成。您必须在相应的到期日提交每一部分。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>我们将为您提供骨架代码 src&#x2F;raft&#x2F;raft.go。我们还提供了一组测试，您应使用这些测试来推动您的实施工作，我们将使用这些测试对您提交的实验室进行评分。这些测试位于 src&#x2F;raft&#x2F;test_test.go。</p><p>要启动并运行，请执行以下命令。别忘了使用 git pull 获取最新软件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> src/raft</span><br><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">Test (2A): initial election ...</span><br><span class="line">--- FAIL: TestInitialElection2A (5.04s)</span><br><span class="line">        config.go:326: expected one leader, got none</span><br><span class="line">Test (2A): election after network failure ...</span><br><span class="line">--- FAIL: TestReElection2A (5.03s)</span><br><span class="line">        config.go:326: expected one leader, got none</span><br><span class="line">...</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>通过向 <code>raft/raft.go</code> 添加代码来实现 Raft。在该文件中，您将找到骨架代码，以及如何发送和接收 RPC 的示例。<br>您的实现必须支持以下接口，测试者和（最终）您的键&#x2F;值服务器都将使用该接口。您可以在 <code>raft.go</code>的注释中找到更多细节。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a new Raft server instance:</span></span><br><span class="line">rf := Make(peers, me, persister, applyCh)</span><br><span class="line"></span><br><span class="line"><span class="comment">// start agreement on a new log entry:</span></span><br><span class="line">rf.Start(command <span class="keyword">interface</span>&#123;&#125;) (index, term, isleader)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ask a Raft for its current term, and whether it thinks it is leader</span></span><br><span class="line">rf.GetState() (term, isLeader)</span><br><span class="line"></span><br><span class="line"><span class="comment">// each time a new entry is committed to the log, each Raft peer</span></span><br><span class="line"><span class="comment">// should send an ApplyMsg to the service (or tester).</span></span><br><span class="line"><span class="keyword">type</span> ApplyMsg</span><br></pre></td></tr></table></figure><p>服务调用<code>Make(peers,me,...)</code> 创建一个 Raft 对等节点。peers 参数是一个 Raft 对等节点（包括此节点）的网络标识符数组，用于 RPC。<code>me</code> 参数是此对等节点在对等节点数组中的索引。<code>Start(command)</code>要求 Raft 开始处理，将命令附加到复制的日志中。Start() 应立即返回，无需等待日志追加完成。服务希望您的实现能为每个新提交的日志条目向 <code>Make()</code>的 <code>applyCh 通道</code>参数发送 <code>ApplyMsg</code>。</p><p><code>raft.go</code> 包含发送 RPC（<code>sendRequestVote()</code>）和处理传入 RPC（<code>RequestVote()</code>）的示例代码。你的 Raft 对等体应该使用 labrpc Go 软件包（源码在 <code>src/labrpc</code>）交换 RPC。测试人员可以告诉 <code>labrpc</code> 延迟 RPC、重新排序 RPC 和丢弃 RPC，以模拟各种网络故障。虽然你可以临时修改 <code>labrpc</code>，但请确保你的 Raft 能在原始 <code>labrpc</code> 上运行，因为我们将用它来对你的实验室进行测试和评分。您的 Raft 实例必须只能与 RPC 进行交互；例如，它们不能使用共享的 Go 变量或文件进行通信。</p><p>后续的实验将建立在本实验的基础上，因此给自己足够的时间编写可靠的代码非常重要。</p><h3 id="Part-2A"><a href="#Part-2A" class="headerlink" title="Part 2A"></a>Part 2A</h3><h4 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h4><p>实现 Raft 领导者选举和心跳（无日志条目的 <code>AppendEntries</code> RPC）。第 2A 部分的目标是选出一个领导者，如果没有失败，领导者将继续担任领导者，如果旧的领导者失败，或者与旧的领导者之间的数据包丢失，新的领导者将接替领导者。运行 <code>go test -run 2A</code> 测试你的 2A 代码。</p><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><ul><li>要直接运行 Raft 实现并不容易，而应通过测试器运行，即 <code>go test -run 2A</code></li><li>请按照本论文的图 2 进行操作。此时你关心的是发送和接收 RequestVote RPC、与选举有关的服务器规则以及与领导人选举有关的状态</li><li>在 <code>raft.go</code> 中的 <code>Raft</code> 结构中添加图 2 中的领导者选举状态。您还需要定义一个结构来保存每个日志条目的信息。</li><li>填写 <code>RequestVoteArgs</code> 和 <code>RequestVoteReply</code> 结构。修改 <code>Make()</code>，创建一个后台程序，该程序会在一段时间内没有收到其他同行的请求时，通过发送 <code>RequestVote</code> RPCs 来定期启动领导者选举。这样，如果已经有了领导者，一个同行就会知道谁是领导者，或者自己成为领导者。实现 <code>RequestVote()</code> RPC 处理程序，使服务器可以互相投票。</li><li>要实现心跳，请定义一个 <code>AppendEntries</code> RPC 结构（虽然可能还不需要所有参数），并让领导者定期发送心跳。编写一个 <code>AppendEntries</code> RPC 处理器方法，重置选举超时，这样当一个服务器已经当选领导者时，其他服务器就不会站出来担任领导者。</li><li>确保不同对等节点的选举超时不会总是在同一时间触发，否则所有对等节点都只会为自己投票，没有人会成为领导者。</li><li>测试要求领导者每秒发送心跳 RPC 的次数不超过十次。</li><li>测试要求您的 Raft 在旧的领导者失效后五秒内选出新的领导者（如果大多数对等节点仍能通信）。但请记住，如果出现投票结果不一致的情况（如数据包丢失或候选人不走运地选择了相同的随机后退时间），则可能需要多轮领导者选举。你必须选择足够短的选举超时（以及心跳间隔），这样即使需要多轮选举，也很有可能在五秒内完成。</li><li>论文的第 5.2 节提到选举超时的范围是 150 到 300 毫秒。只有当领导者发送心跳的频率大大超过每 150 毫秒一次时，这样的范围才有意义。由于测试仪限制每秒只能发送 10 次心跳，因此你必须使用比论文中规定的 150 至 300 毫秒更大的选举超时，但也不能太大，因为这样你可能无法在五秒内选出领导者。</li><li>您可能会发现Go的<a href="https://pkg.go.dev/math/rand">rand package - math&#x2F;rand - Go Packages</a>很有用。</li><li>您需要编写代码，定期或延迟时间后执行操作。最简单的方法是创建一个带循环的 goroutine，调用 <code>time.Sleep()</code>。不要使用 Go 的 <code>time.Timer</code> 或 <code>time.Ticker</code>，它们很难正确使用。</li><li>阅读有关<a href="http://nil.csail.mit.edu/6.824/2020/labs/raft-locking.txt">锁</a>和并发<a href="http://nil.csail.mit.edu/6.824/2020/labs/raft-locking.txt">结构</a>的建议非常有用</li><li>如果你的代码无法通过测试，请再读一遍论文中的图 2；领导者选举的全部逻辑分布在图的多个部分。</li><li>不要忘记实现 <code>GetState()</code></li><li>测试器在永久关闭实例时会调用 Raft 的 <code>rf.Kill()</code>。您可以使用 <code>rf.killed()</code> 检查 Kill() 是否已被调用。您可能希望在所有循环中都这样做，以避免死亡的 Raft 实例打印出混乱的信息。</li><li>调试代码的一个好方法是在对等程序发送或接收消息时插入<strong>打印</strong>语句，然后用 <code>go test -run 2A &gt; out</code> 将输出收集到一个文件中。然后，通过研究 <code>out</code> 文件中的消息轨迹，你可以找出你的实现与所需协议的偏差。你可能会发现 <code>util.go</code> 中的 <code>DPrintf</code> 对调试不同问题时打开或关闭打印很有用。</li><li>Go RPC 只发送名称以<strong>大写</strong>字母开头的结构体字段。子结构的字段名也必须<strong>大写</strong>（例如数组中日志记录的字段）。<code>labgob</code> 软件包会对此发出警告，请不要忽视这些警告。</li><li>使用 go test -race 检查代码，并修复它报告的任何竞争问题。</li></ul><p>在提交第 2A 部分之前，请确保您通过了 2A 测试，这样您就会看到如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -run 2A</span><br><span class="line">Test (2A): initial election ...</span><br><span class="line">  ... Passed --   4.0  3   32    9170    0</span><br><span class="line">Test (2A): election after network failure ...</span><br><span class="line">  ... Passed --   6.1  3   70   13895    0</span><br><span class="line">PASS</span><br><span class="line">ok      raft    10.187s</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>每行 “Passed”（通过）包含五个数字；它们分别是以秒为单位的测试时间、Raft 对等体的数量（通常为 3 或 5）、测试期间发送的 RPC 数量、RPC 消息的总字节数，以及 Raft 报告已提交的日志条目数量。您的数据将与此处显示的数据不同。您可以忽略这些数字，但它们可以帮助您理智地检查您的实现所发送的 RPC 数量。对于所有实验 2、3 和 4，如果所有测试花费的时间超过 600 秒（<code>go test</code>），或者任何单个测试花费的时间超过 120 秒，评分脚本将使您的解决方案失败。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>2A整体任务只有两个，领导选举和发送心跳<br>其中每一个都可以细分为四个步骤，主要是需要明白每个步骤、不同角色、任期关系需要做什么。</p><p>经过调试，心跳间隔和选举超时设置为如下时间，比较合理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 心跳间隔</span></span><br><span class="line"><span class="keyword">const</span> heartBeat = <span class="number">50</span></span><br><span class="line"><span class="comment">// 选举超时 = 基本150ms + 随机0-200ms </span></span><br><span class="line"><span class="keyword">const</span> basicTimeout = <span class="number">150</span></span><br><span class="line"><span class="keyword">const</span> randomTimeout = <span class="number">200</span></span><br></pre></td></tr></table></figure><h5 id="领导选举"><a href="#领导选举" class="headerlink" title="领导选举"></a>领导选举</h5><p>Raft需要启动一个后台<code>ticker</code>线程用来实时监测超时（Follower）或触发心跳广播（Leader）。<br>因此选举的流程如下：</p><ol><li><code>ticker</code>线程发现当前<code>role</code>为<code>follower</code>，并且已经发生选举超时。</li><li>发起领导选举：任期加一，给自己投票，向其他节点发送投票请求并处理（另起线程）</li><li>处理投票结果：如果收到半数以上的选票，则选举成功；</li><li>选举成功：本实验中，只需要发送一次心跳即可。</li></ol><ul><li><code>startElection()</code>：触发领导选举，当Follower或Candidate选举<strong>超时</strong>时由ticker()触发触发</li><li><code>SendRequestVote()</code>：发送请求选票RPC，不需要我们实现</li><li><code>RequestVote()</code>：处理请求选票RPC的handler，也就是节点收到来自其他Candidate的选票请求时，如何处理</li><li><code>handleVoteResult()</code>：Candidate收到选票请求回复时，如何处理</li><li><code>becomeLeader()</code>：选举成功，成为<code>Leader</code>后的操作<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// start a new election</span></span><br><span class="line"><span class="comment">// 开启一轮选举</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> startElection() &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">DPrintf(<span class="string">&quot;[Election]:Peer[%d] start election for term[%d] | %s\n&quot;</span>,rf.me,rf.currentTerm+<span class="number">1</span>,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line"><span class="comment">//Add term,增加任期号</span></span><br><span class="line">rf.currentTerm++</span><br><span class="line"><span class="comment">//Vote for self,先给自己投票</span></span><br><span class="line">rf.votedFor = rf.me</span><br><span class="line">rf.voteCount = <span class="number">1</span></span><br><span class="line"><span class="comment">//Become a candidate,修改成为Candidate</span></span><br><span class="line">rf.role = CANDIDATE</span><br><span class="line"><span class="comment">//Refresh election timeout,刷新选举超时时间</span></span><br><span class="line">rf.refreshTimeout()</span><br><span class="line"><span class="comment">//Send RequestVote for all other peers,并行发送请求选票RPC</span></span><br><span class="line"><span class="comment">// a flag for becomeLeader</span></span><br><span class="line"><span class="keyword">var</span> becomeLeaderOnce sync.Once</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> args = RequestVoteArgs&#123;</span><br><span class="line">Term: rf.currentTerm,</span><br><span class="line">CandidateId: rf.me,</span><br><span class="line">LastLogTerm: rf.log[<span class="built_in">len</span>(rf.log)<span class="number">-1</span>].Term,</span><br><span class="line">LastLogIndex: <span class="built_in">len</span>(rf.log)<span class="number">-1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(rf.peers);i++&#123;</span><br><span class="line"><span class="keyword">if</span> i==rf.me&#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Open a separate goroutines to handle,开启一个单独的线程，发送RPC并等待回复回调</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(server <span class="type">int</span>,args *RequestVoteArgs)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> reply = RequestVoteReply&#123;&#125;</span><br><span class="line">DPrintf(<span class="string">&quot;[Send RequestVote]:Peer[%d] send RequestVote to Peer[%d] | %s\n&quot;</span>,rf.me,server,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">ok:= rf.sendRequestVote(server,args,&amp;reply)</span><br><span class="line"><span class="keyword">if</span> ok&#123;</span><br><span class="line">rf.handleVoteResult(&amp;reply)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i,&amp;args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestVote RPC hanler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line"><span class="comment">// Your code here (2A, 2B).</span></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">term := args.Term</span><br><span class="line">lastLogIndex := args.LastLogIndex</span><br><span class="line">lastLogTerm := args.LastLogTerm</span><br><span class="line">candidateId := args.CandidateId</span><br><span class="line"></span><br><span class="line">DPrintf(<span class="string">&quot;[Receive RequestVote]:Peer[%d] receive RequestVote RPC from Peer[%d] | %s\n&quot;</span>,rf.me,candidateId,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">    <span class="comment">// Receive an outdated request from old candidate,ignore</span></span><br><span class="line">    <span class="comment">// 接收到了来自往届Candidate的选票请求，忽略并返回新的任期号，以便其放弃选举</span></span><br><span class="line"><span class="keyword">if</span> term &lt; rf.currentTerm&#123;</span><br><span class="line">reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Whether have already voted in the current term,在当前任期是否已经给其他候选人投过票</span></span><br><span class="line"><span class="keyword">var</span> hasVoted = (term==rf.currentTerm&amp;&amp; rf.votedFor!=<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// Whether candidate&#x27;s log is updated.检查当前候选人的日志否是比自己的新</span></span><br><span class="line"><span class="keyword">var</span> checkCandidateLog = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> lastLogTerm &lt; rf.log[<span class="built_in">len</span>(rf.log)<span class="number">-1</span>].Term&#123;</span><br><span class="line">checkCandidateLog = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> lastLogTerm == rf.log[<span class="built_in">len</span>(rf.log)<span class="number">-1</span>].Term &amp;&amp; lastLogIndex &lt; <span class="built_in">len</span>(rf.log)<span class="number">-1</span>&#123;</span><br><span class="line">checkCandidateLog = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Received a same term candidate&#x27;s request,if hasn&#x27;t voted, then vote for </span></span><br><span class="line"><span class="comment">// 收到了同任期选举人的投票请求，如果没投票则投票给Candidate(但我认为这种情况不会发生)</span></span><br><span class="line"><span class="comment">// 除非A在Term=2时,发送了超时,开始选举后，增加了自己的Term=3后马上就挂了，这时它还没来得及把票投给自己</span></span><br><span class="line"><span class="comment">// 此时另一个Term=2节点也刚好超时了， 然后发送RequestVote请求给A，A此时可能会投票给他</span></span><br><span class="line"><span class="keyword">if</span> term == rf.currentTerm&#123;</span><br><span class="line"><span class="keyword">if</span> !hasVoted &amp;&amp; checkCandidateLog&#123;</span><br><span class="line">rf.votedFor = candidateId</span><br><span class="line">reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">DPrintf(<span class="string">&quot;[Vote]:Peer[%d] give vote to Peer[%d] for term[%d] | %s\n&quot;</span>,rf.me,candidateId,term,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">reply.Term=rf.currentTerm</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Received a updated term candidate&#x27;s request,follow him and vote for him if log check is ok</span></span><br><span class="line"><span class="comment">// 收到了更高Term的候选人的投票请求，如果其日志检查没问题，则投票给他，并修改自己的Term,不管自己是什么角色，都变为Follower，因为此时集群中出现了更高Term的人。</span></span><br><span class="line"><span class="keyword">if</span> term &gt; rf.currentTerm&#123;</span><br><span class="line">rf.currentTerm = term</span><br><span class="line">rf.role = FOLLOWER</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line"><span class="keyword">if</span> checkCandidateLog&#123;</span><br><span class="line">rf.votedFor = candidateId</span><br><span class="line">&#125;</span><br><span class="line">rf.refreshTimeout()</span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">reply.VoteGranted = (rf.votedFor==candidateId)</span><br><span class="line"><span class="keyword">if</span> (reply.VoteGranted)&#123;</span><br><span class="line">DPrintf(<span class="string">&quot;[Vote]:Peer[%d] give vote to Peer[%d] for term[%d] | %s\n&quot;</span>,rf.me,candidateId,term,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handle vote result</span></span><br><span class="line"><span class="comment">// Candidate处理投票回复</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> handleVoteResult(reply *RequestVoteReply)  &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">term := reply.Term</span><br><span class="line">voteGranted := reply.VoteGranted</span><br><span class="line"><span class="comment">// Give up candidate,and back to follower</span></span><br><span class="line"><span class="comment">// 如果收到了更高Term的回复，说明已经存在更高Term的Leader，则放弃选举，变为Follower</span></span><br><span class="line"><span class="keyword">if</span> term&gt;rf.currentTerm&#123;</span><br><span class="line">rf.role = FOLLOWER</span><br><span class="line">rf.currentTerm = term</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">rf.voteCount = <span class="number">0</span></span><br><span class="line">rf.refreshTimeout()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Received an old term reply,ignore</span></span><br><span class="line"><span class="comment">// 收到了过期Term节点的回复，忽略。这个其实也不太可能发生，因为在RequestVote中，总会将自己的Term更新到与Candidate一致，那么在回复的时候，回复者的Term&gt;=rf.currentTerm</span></span><br><span class="line"><span class="keyword">if</span> term &lt; rf.currentTerm&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Received a same term reply</span></span><br><span class="line"><span class="comment">// 收到了同一Term的回复，处理选票结果</span></span><br><span class="line"><span class="comment">// 当第一次达到半数后，就可以宣布成为Leader，然后广播一次心跳信息。</span></span><br><span class="line"><span class="keyword">if</span> term == rf.currentTerm&#123;</span><br><span class="line"><span class="keyword">if</span> voteGranted&#123;</span><br><span class="line">rf.voteCount++</span><br><span class="line"><span class="keyword">if</span> rf.voteCount&gt;rf.n/<span class="number">2</span> &amp;&amp; rf.role==CANDIDATE&#123;</span><br><span class="line"><span class="comment">// only execute once</span></span><br><span class="line">becomeLeaderOnce.Do(rf.becomeLeader)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// One peer electron success and become leader</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeLeader()&#123;</span><br><span class="line">DPrintf(<span class="string">&quot;[Leader][becomeLeader()]:Peer[%d] become leader for term[%d] | %s\n&quot;</span>, rf.me, rf.currentTerm, time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">rf.role = LEADER</span><br><span class="line">rf.refreshTimeout()</span><br><span class="line"><span class="comment">//2B</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rf.n; i++ &#123;</span><br><span class="line">rf.nextIndex[i] = rf.getLogLength()</span><br><span class="line">rf.matchIndex[i] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> rf.broadcastAppendEntries()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="广播心跳"><a href="#广播心跳" class="headerlink" title="广播心跳"></a>广播心跳</h5><blockquote><p>这里的心跳RPC复用了AppendEntries，将AppendEntriesArgs中的Entries赋nil，则代表这是一条心跳RPC，而不是附加日志的RPC（在后续实验会实现）</p></blockquote><ul><li>broadcastAppendEntries()：向其他节点广播RPC(心跳&#x2F;附加日志)</li><li>SendAppendEntries()：发送附加日志RPC，不需要我们实现</li><li>AppendEntries()：处理RPC的handler，也就是节点收到来自Leader的附加日志时，如何处理</li><li>handleAppendEntries：Leader收到回复时，如何处理<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Broadcast AppendEntries RPC to other peers</span></span><br><span class="line"><span class="comment">// 广播心跳实验2A，后续实验会进行拓展</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> broadcastAppendEntries() &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(rf.peers);i++&#123;</span><br><span class="line"><span class="keyword">if</span> i==rf.me&#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = AppendEntriesArgs&#123;</span><br><span class="line">Term: rf.currentTerm,</span><br><span class="line">LeaderId: rf.me,</span><br><span class="line">Entries: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> server = i</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(server <span class="type">int</span>, args *AppendEntriesArgs)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> reply = AppendEntriesReply&#123;&#125;</span><br><span class="line">ok:=rf.sendAppendEntries(server,args,&amp;reply)</span><br><span class="line"><span class="keyword">if</span> ok&#123;</span><br><span class="line">rf.handleAppendEntries(&amp;reply)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(server,&amp;args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppendEntries RPC hander</span></span><br><span class="line"><span class="comment">// AppendEntries RPC处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">term := args.Term</span><br><span class="line">entries := args.Entries</span><br><span class="line"></span><br><span class="line"><span class="comment">// Represent heartbeat RPC</span></span><br><span class="line"><span class="keyword">if</span> entries==<span class="literal">nil</span>&#123;</span><br><span class="line"><span class="comment">// 1.收到了来自过期Leader的心跳信息，回复它更新的Term以便更新</span></span><br><span class="line"><span class="comment">// 2.收到了相同任期的Leader,变为Follower(如果当前为Candidate话，因为当前任期已经有Leader了，不可能选举成功了)，刷新超时时间</span></span><br><span class="line"><span class="comment">// 3.收到了更高任期的Leader,变为Follower，更新任期，更新超时时间</span></span><br><span class="line"><span class="keyword">if</span> term &lt; rf.currentTerm&#123;</span><br><span class="line">reply.Term=rf.currentTerm</span><br><span class="line">reply.Success = <span class="literal">false</span></span><br><span class="line">DPrintf(<span class="string">&quot;[HeartBeat]:Peer[%d] in term[%d] receive pre HeartBeat from Leader[%d] | %s\n&quot;</span>,rf.me,rf.currentTerm,args.LeaderId,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> term == rf.currentTerm&#123;</span><br><span class="line">rf.role=FOLLOWER</span><br><span class="line">rf.refreshTimeout()</span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">reply.Success = <span class="literal">true</span></span><br><span class="line">DPrintf(<span class="string">&quot;[HeartBeat]:Peer[%d] in term[%d] receive HeartBeat from Leader[%d] | %s | nextTimeout[%s]\n&quot;</span>,rf.me,rf.currentTerm,args.LeaderId,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>),rf.nextTimeout.Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">rf.role=FOLLOWER</span><br><span class="line">rf.refreshTimeout()</span><br><span class="line">rf.currentTerm=term</span><br><span class="line">rf.votedFor=<span class="number">-1</span></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">reply.Success = <span class="literal">true</span></span><br><span class="line">DPrintf(<span class="string">&quot;[HeartBeat]:Peer[%d] in term[%d] receive HeartBeat from Leader[%d] | %s | nextTimeout[%s]\n&quot;</span>,rf.me,rf.currentTerm,args.LeaderId,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>),rf.nextTimeout.Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle other peers&#x27;s AppendEntries RPC reply</span></span><br><span class="line"><span class="comment">// Leader收到回复后的处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> handleAppendEntries(reply *AppendEntriesReply) &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">term := reply.Term</span><br><span class="line"></span><br><span class="line"><span class="comment">// Received a larger term peers, means that it has expired and there is a latest leader exists in the cluster.</span></span><br><span class="line"><span class="comment">// 收到了更高Term的回复，说明自己的领导位置已经过期了，变成Follower,修改Term</span></span><br><span class="line"><span class="keyword">if</span> term &gt; rf.currentTerm &#123;</span><br><span class="line">rf.role = FOLLOWER</span><br><span class="line">rf.currentTerm = term</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">rf.voteCount = <span class="number">0</span></span><br><span class="line">rf.refreshTimeout()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The ticker go routine starts a new election if this peer hasn&#x27;t received</span></span><br><span class="line"><span class="comment">// heartsbeats recently.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> ticker() &#123;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> rf.killed() == <span class="literal">false</span> &#123;</span><br><span class="line"><span class="comment">// Your code here to check if a leader election should</span></span><br><span class="line"><span class="comment">// be started and to randomize sleeping time using</span></span><br><span class="line"><span class="comment">// time.Sleep().</span></span><br><span class="line"><span class="comment">// 模拟定时，每10ms循环一次，检查超时或是否发送心跳</span></span><br><span class="line">time.Sleep(onceDuration*time.Millisecond)</span><br><span class="line">count++</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="comment">// 模拟定时，当每执行5次，也就是50ms时，Leader发送一次心跳信息</span></span><br><span class="line"><span class="keyword">if</span> count%(heartBeat/onceDuration)==<span class="number">0</span> &amp;&amp; rf.role == LEADER&#123;</span><br><span class="line">count=<span class="number">0</span></span><br><span class="line"><span class="comment">//Leader send heartbeat</span></span><br><span class="line">DPrintf(<span class="string">&quot;[Send HeartBeat]:Peer(Leader)[%d] send HeartBeat | %s\n&quot;</span>,rf.me,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">rf.broadcastAppendEntries()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查是否超时，由于每10ms检查一次，因此肯定会有10ms以内的误差</span></span><br><span class="line"><span class="keyword">if</span> rf.role != LEADER &amp;&amp; time.Now().After(rf.nextTimeout)&#123;</span><br><span class="line">DPrintf(<span class="string">&quot;[Timeout]:Peer[%d] timeout:%v | %s\n&quot;</span>,rf.me,rf.nextTimeout,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">rf.startElection()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他部分的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onceDuration = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> heartBeat = <span class="number">50</span></span><br><span class="line"><span class="keyword">const</span> basicTimeout = <span class="number">150</span></span><br><span class="line"><span class="keyword">const</span> randomTimeout = <span class="number">200</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// as each Raft peer becomes aware that successive log entries are</span></span><br><span class="line"><span class="comment">// committed, the peer should send an ApplyMsg to the service (or</span></span><br><span class="line"><span class="comment">// tester) on the same server, via the applyCh passed to Make(). set</span></span><br><span class="line"><span class="comment">// CommandValid to true to indicate that the ApplyMsg contains a newly</span></span><br><span class="line"><span class="comment">// committed log entry.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// in part 2D you&#x27;ll want to send other kinds of messages (e.g.,</span></span><br><span class="line"><span class="comment">// snapshots) on the applyCh, but set CommandValid to false for these</span></span><br><span class="line"><span class="comment">// other uses.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">type</span> ApplyMsg <span class="keyword">struct</span> &#123;</span><br><span class="line">CommandValid <span class="type">bool</span></span><br><span class="line">Command      <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">CommandIndex <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For 2D:</span></span><br><span class="line">SnapshotValid <span class="type">bool</span></span><br><span class="line">Snapshot      []<span class="type">byte</span></span><br><span class="line">SnapshotTerm  <span class="type">int</span></span><br><span class="line">SnapshotIndex <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Role <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">FOLLOWER Role = <span class="literal">iota</span></span><br><span class="line">LEADER</span><br><span class="line">CANDIDATE</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Go object implementing a single Raft peer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">mu        sync.Mutex          <span class="comment">// Lock to protect shared access to this peer&#x27;s state</span></span><br><span class="line">peers     []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">persister *Persister          <span class="comment">// Object to hold this peer&#x27;s persisted state</span></span><br><span class="line">me        <span class="type">int</span>                 <span class="comment">// this peer&#x27;s index into peers[]</span></span><br><span class="line">dead      <span class="type">int32</span>               <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your data here (2A, 2B, 2C).</span></span><br><span class="line"><span class="comment">// Look at the paper&#x27;s Figure 2 for a description of what</span></span><br><span class="line"><span class="comment">// state a Raft server must maintain.</span></span><br><span class="line">currentTerm <span class="type">int</span></span><br><span class="line">role Role</span><br><span class="line">votedFor <span class="type">int</span></span><br><span class="line">log[]LogEntry</span><br><span class="line">nextTimeouttime.Time</span><br><span class="line"></span><br><span class="line"><span class="comment">// vote info n is the number of peers, voteCount is the number of vote received</span></span><br><span class="line">n<span class="type">int</span></span><br><span class="line">voteCount<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//refresh or init the electron timeout</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> refreshTimeout()&#123;</span><br><span class="line">randomMillis := basicTimeout + rand.Intn(<span class="number">201</span>)</span><br><span class="line">randomDuration := time.Duration(randomMillis) * time.Millisecond</span><br><span class="line">rf.nextTimeout = time.Now().Add(randomDuration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return currentTerm and whether this server</span></span><br><span class="line"><span class="comment">// believes it is the leader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> GetState() (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> term <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> isleader <span class="type">bool</span></span><br><span class="line"><span class="comment">// Your code here (2A).</span></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">term = rf.currentTerm</span><br><span class="line">isleader = rf.role==LEADER</span><br><span class="line"><span class="keyword">return</span> term, isleader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><blockquote><p>Follower什么时候才会投票</p></blockquote><ul><li><code>term &lt; currentTerm</code>拒绝投票</li><li><code>votedFor</code>不为空，说明已经投过票了，拒绝</li><li>验证选举限制，简而言之就是只给日志信息更新更全的人投票<ul><li>lastLogTerm&lt;当前最后一条日志的term，拒绝</li><li>lastLogTerm&#x3D;当前最后一条日志的term，且lastLogIndex&lt;当前日志列表长度-1，拒绝</li></ul></li><li>同意投票</li></ul><blockquote><p>来自leader的心跳信息需不需要添加到log</p></blockquote><p>不需要</p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><blockquote><p>本实验未使用chan，time.Timer等实现，仅简单实用锁、time.Sleep进行实现<br>通过并行次数4，总次数20次的测试</p></blockquote><p><img src="/../../../../img/Pasted%20image%2020231106134445.png"><br><img src="/../../../../img/Pasted%20image%2020231106134417.png"></p><h3 id="Part-2B"><a href="#Part-2B" class="headerlink" title="Part 2B"></a>Part 2B</h3><h4 id="任务-2"><a href="#任务-2" class="headerlink" title="任务"></a>任务</h4><p>实现Leader和Follower的日志追加功能，通过2B测试</p><h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><ul><li>您的首要目标应该是通过 TestBasicAgree2B()。首先要实现 Start()，然后按照图 2 编写代码，通过 AppendEntries RPC 发送和接收新的日志条目。</li><li>你需要实现选举限制（论文章节5.4.1）</li><li>在早期 Lab 2B 测试中，一种无法达成一致的方法是反复举行选举，即使领导者还活着。查找选举计时器管理中的错误，或在赢得选举后不立即发送心跳的错误。</li><li>您的代码中可能有重复检查某些事件的循环。不要让这些循环不间断地执行而不暂停，因为这样会减慢实现速度，导致测试失败。请使用 Go 的条件变量，或在每个循环迭代中插入 time.Sleep(10 * time.Millisecond)。</li><li>帮自己一个忙，在今后的实验中编写（或重新编写）简洁明了的代码。您可以重新访问参考我们的<a href="http://nil.csail.mit.edu/6.824/2020/labs/raft-structure.txt">structure</a>, <a href="http://nil.csail.mit.edu/6.824/2020/labs/raft-locking.txt">locking</a>, 和 <a href="https://thesquareplanet.com/blog/students-guide-to-raft/">guide</a> 页面指导。</li></ul><p>如果您的代码运行太慢，即将进行的实验室测试可能会失败。您可以使用 time 命令检查解决方案占用了多少实时时间和 CPU 时间。以下是典型的输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ time go <span class="built_in">test</span> -run 2B</span><br><span class="line">Test (2B): basic agreement ...</span><br><span class="line">  ... Passed --   1.6  3   18    5158    3</span><br><span class="line">Test (2B): RPC byte count ...</span><br><span class="line">  ... Passed --   3.3  3   50  115122   11</span><br><span class="line">Test (2B): agreement despite follower disconnection ...</span><br><span class="line">  ... Passed --   6.3  3   64   17489    7</span><br><span class="line">Test (2B): no agreement <span class="keyword">if</span> too many followers disconnect ...</span><br><span class="line">  ... Passed --   4.9  5  116   27838    3</span><br><span class="line">Test (2B): concurrent Start()s ...</span><br><span class="line">  ... Passed --   2.1  3   16    4648    6</span><br><span class="line">Test (2B): rejoin of partitioned leader ...</span><br><span class="line">  ... Passed --   8.1  3  111   26996    4</span><br><span class="line">Test (2B): leader backs up quickly over incorrect follower logs ...</span><br><span class="line">  ... Passed --  28.6  5 1342  953354  102</span><br><span class="line">Test (2B): RPC counts aren<span class="string">&#x27;t too high ...</span></span><br><span class="line"><span class="string">  ... Passed --   3.4  3   30    9050   12</span></span><br><span class="line"><span class="string">PASS</span></span><br><span class="line"><span class="string">ok      raft    58.142s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">real    0m58.475s</span></span><br><span class="line"><span class="string">user    0m2.477s</span></span><br><span class="line"><span class="string">sys     0m1.406s</span></span><br><span class="line"><span class="string">$</span></span><br></pre></td></tr></table></figure><p><code>ok raft 58.142s</code> 表示 Go 测得的 2B 测试时间为 58.142 秒的实际（挂钟）时间。<code>user 0m2.477s </code>表示代码消耗了 2.477 秒的 CPU 时间，即实际执行指令（而不是等待或休眠）的时间。如果您的解决方案在 2B 测试中使用的实际时间远超过一分钟，或 CPU 时间远超过 5 秒，那么您以后可能会遇到麻烦。请注意睡眠或等待 RPC 超时所花费的时间、在不睡眠或等待条件或通道消息的情况下运行的循环，或发送的大量 RPC。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>按照论文中的实现，理解<code>nextIndex</code>和<code>matchIndex</code>的意思</p><h4 id="BUG排查"><a href="#BUG排查" class="headerlink" title="BUG排查"></a>BUG排查</h4><ol><li><p>Leader发送AppendEntries RPC后导致Follower超时。 - 已解决，broadcastAppendEntries死锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2023/11/07 23:18:27 [Send AppendEntries(Start)]:Peer(Leader)[0] send ppendEntries | 23:18:27.962</span><br><span class="line">Leader发送AppendEntries RPC后导致Follower超时。</span><br></pre></td></tr></table></figure></li><li><p>没有最新日志的节点超时后，请求选举，导致选举不上又不断超时发生选举</p><figure class="highlight plaintext"><figcaption><span>(2B): agreement after follower reconnects ...</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2023/11/10 14:20:24 [Send AppendEntries(Start)]:Peer(Leader)[2] send AppendEntries | 14:20:24.097</span><br><span class="line">2023/11/10 14:20:24 [Start Return (Start)]:Peer(Leader)[2] start return | 14:20:24.098</span><br><span class="line">2023/11/10 14:20:24 [AppendEntries Send] Leader[2] send an AppendEntries to Peer[1] | 14:20:24.098</span><br><span class="line">2023/11/10 14:20:24 [AppendEntries Send] Leader[2] send an AppendEntries to Peer[0] | 14:20:24.098</span><br><span class="line">2023/11/10 14:20:24 [AppendEntries Received]:Peer[1] in term[1] receive AppendEntries from Leader[2] | 14:20:24.101</span><br><span class="line">2023/11/10 14:20:24 [Add Entries]:Peer[1] in term[1] update AppendEntries from Leader[2] | 14:20:24.101</span><br><span class="line">2023/11/10 14:20:24 [Send HeartBeat]:Peer(Leader)[2] send HeartBeat | 14:20:24.111</span><br><span class="line">2023/11/10 14:20:24 [HeartBeat]:Peer[1] in term[1] receive HeartBeat from Leader[2] | 14:20:24.113 | nextTimeout[14:20:24.485]</span><br><span class="line">2023/11/10 14:20:24 [Send HeartBeat]:Peer(Leader)[2] send HeartBeat | 14:20:24.189</span><br><span class="line">2023/11/10 14:20:24 [HeartBeat]:Peer[1] in term[1] receive HeartBeat from Leader[2] | 14:20:24.192 | nextTimeout[14:20:24.515]</span><br><span class="line">2023/11/10 14:20:24 [Send HeartBeat]:Peer(Leader)[2] send HeartBeat | 14:20:24.267</span><br><span class="line">2023/11/10 14:20:24 [HeartBeat]:Peer[1] in term[1] receive HeartBeat from Leader[2] | 14:20:24.270 | nextTimeout[14:20:24.668]</span><br></pre></td></tr></table></figure></li><li><p>TestFailNoAgree2B偶尔失败</p></li><li><p>TestRejoin2B偶尔失败</p></li></ol><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Test (2B): basic agreement ...</span><br><span class="line">  ... Passed --   0.3  3   16    4362    3</span><br><span class="line">Test (2B): RPC byte count ...</span><br><span class="line">  ... Passed --   0.9  3   50  114502   11</span><br><span class="line">Test (2B): agreement after follower reconnects ...</span><br><span class="line">  ... Passed --   5.1  3  223   61055    8</span><br><span class="line">Test (2B): no agreement if too many followers disconnect ...</span><br><span class="line">  ... Passed --   3.3  5  372   77214    4</span><br><span class="line">Test (2B): concurrent Start()s ...</span><br><span class="line">  ... Passed --   0.6  3   34    9899    6</span><br><span class="line">Test (2B): rejoin of partitioned leader ...</span><br><span class="line">  ... Passed --   4.0  3  286   64853    4</span><br><span class="line">Test (2B): leader backs up quickly over incorrect follower logs ...</span><br><span class="line">  ... Passed --   9.9  5 3141 3316487  102</span><br><span class="line">Test (2B): RPC counts aren&#x27;t too high ...</span><br><span class="line">  ... Passed --   2.0  3   96   29954   12</span><br><span class="line">PASS</span><br><span class="line">ok      6.824/raft      26.180s</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Part-2C"><a href="#Part-2C" class="headerlink" title="Part 2C"></a>Part 2C</h3><p>如果基于 Raft 的服务器重启，它应该从原来的位置恢复服务。这就要求 Raft 保持持久的状态，以便在重启后继续运行。本文的图 2 提到了哪些状态应该是持久的。<br>真正的实现会在 Raft 的持久化状态发生变化时将其写入磁盘，并在重启后从磁盘读取状态。您的实现不会使用磁盘；相反，它将从 Persister 对象（参见 persister.go）中保存和恢复持久化状态。无论谁调用 Raft.Make()，都要提供一个 Persister，它最初保存着 Raft 最近的持久化状态（如果有的话）。Raft 应从该 Persister 初始化其状态，并在每次状态改变时使用该 Persister 保存其持久化状态。请使用 Persister 的 ReadRaftState() 和 SaveRaftState() 方法。</p><h4 id="任务-3"><a href="#任务-3" class="headerlink" title="任务"></a>任务</h4><p>通过添加保存和恢复持久化状态的代码，完成 raft.go 中的函数 persist() 和 readPersist()。您需要将状态编码（或 “序列化”）为字节数组，以便将其传递给 Persister。使用 labgob 编码器；请参阅 persistence() 和 readPersist() 中的注释。labgob 类似 Go 的 gob 编码器，但如果尝试对字段名为小写的结构进行编码，则会打印错误信息。<br>在实现更改持久化状态的位置插入对 persist() 的调用。完成这些工作后，其余的测试就可以通过了。</p><h4 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h4><ul><li>许多 2C 测试都涉及服务器故障和网络丢失 RPC 请求或回复。</li><li>你可能需要一次备份多个条目的 nextIndex 的优化。请阅读从第 7 页底部和第 8 页顶部开始的扩展 Raft 论文（用灰色线标出）。该论文对细节的描述比较含糊；您需要填补空白，或许可以借助 6.824 Raft 讲座。</li><li>实验 2 全套测试（2A+2B+2C）的合理耗时为 4 分钟实时时间和 1 分钟 CPU 时间。</li></ul><p>您的代码应通过所有 2C 测试（如下所示）以及 2A 和 2B 测试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ go test -run 2C</span><br><span class="line">Test (2C): basic persistence ...</span><br><span class="line">  ... Passed --   7.2  3  206   42208    6</span><br><span class="line">Test (2C): more persistence ...</span><br><span class="line">  ... Passed --  23.2  5 1194  198270   16</span><br><span class="line">Test (2C): partitioned leader and one follower crash, leader restarts ...</span><br><span class="line">  ... Passed --   3.2  3   46   10638    4</span><br><span class="line">Test (2C): Figure 8 ...</span><br><span class="line">  ... Passed --  35.1  5 9395 1939183   25</span><br><span class="line">Test (2C): unreliable agreement ...</span><br><span class="line">  ... Passed --   4.2  5  244   85259  246</span><br><span class="line">Test (2C): Figure 8 (unreliable) ...</span><br><span class="line">  ... Passed --  36.3  5 1948 4175577  216</span><br><span class="line">Test (2C): churn ...</span><br><span class="line">  ... Passed --  16.6  5 4402 2220926 1766</span><br><span class="line">Test (2C): unreliable churn ...</span><br><span class="line">  ... Passed --  16.5  5  781  539084  221</span><br><span class="line">PASS</span><br><span class="line">ok      raft    142.357s</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>这一部分实际不难，只要按照persist 和 readPersist中的注释实现即可。并在所有需要持久化的数据部分调用persist持久化到磁盘即可。readPersist不需要我们调用，会在ticker中调。但Lab2C的测试比较严格，大概率会发现前面Lab2B中的很多问题，如需要加速日志对比过程，否则Figure 8 (unreliable)大概率过不了，还有超时时间和心跳频率是否合理。具体见<a href="https://github.com/springfieldking/mit-6.824-golabs-2018/issues/1">lab2-one</a></p><h3 id="Part-2D"><a href="#Part-2D" class="headerlink" title="Part 2D"></a>Part 2D</h3><p>就目前情况而言，重启的服务器会重播完整的 Raft 日志以恢复其状态。然而，对于一个长期运行的服务来说，永远记住完整的 Raft 日志是不现实的。取而代之的是，你需要修改 Raft，以便与那些不时持续存储其状态 “快照 “的服务合作，此时 Raft 会丢弃快照之前的日志条目。这样做的结果是持久化数据量更小，重启速度更快。然而，现在追随者有可能落后太多，以至于领导者丢弃了追赶所需的日志条目；这时领导者必须发送快照和从快照时间开始的日志。Raft 扩展论文的第 7 节概述了这一方案，具体细节需要您自行设计。</p><p>请参考 Raft <a href="http://nil.csail.mit.edu/6.824/2022/notes/raft_diagram.pdf">交互示意图</a>，以了解复制服务和 Raft 的通信方式。</p><p>您的 Raft 必须提供以下函数，以便服务可以调用其状态的序列化快照：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Snapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>)</span><br></pre></td></tr></table></figure><p>在Lab 2D中，测试工具定期调用<code>Snapshot()</code>，在实验3中你会实现一个key&#x2F;value服务来调用<code>Snapshot()</code>，这个快照会包含整个key&#x2F;value对的表。服务层会在每个对等体（而不仅仅是领导者）上调用<code>Snapshot()</code>。</p><p><code>index</code>参数表示快照中反映的最高日志条目。Raft 应丢弃该点之前的日志条目。您需要修改 Raft 代码，以便在只存储日志尾部的情况下运行。</p><p>您需要实现论文中讨论的<code>InstallSnapshot RPC</code>，它允许 Raft 领导者告诉落后的 Raft 对等节点用快照替换其状态。您可能需要考虑 InstallSnapshot 应如何与图 2 中的状态和规则交互。</p><p>当追随者的 Raft 代码接收到 <code>InstallSnapshot RPC</code> 时，它可以使用 <code>applyCh</code> 将快照发送到 <code>ApplyMsg</code> 服务中。<code>ApplyMsg</code> 结构定义已经包含了您需要的字段（也是测试人员所期望的）。请注意，这些快照只会推进服务的状态，而不会导致服务后退。</p><p>如果服务器崩溃，它必须从持久化数据重新启动。您的 Raft 应同时持久化 Raft 状态和相应的快照。请使用 <code>persister.SaveStateAndSnapshot()</code>，它为 Raft 状态和相应的快照分别接收不同的参数。如果没有快照，则传递 <code>nil</code> 作为<code>snapshot</code>参数。</p><p>当服务器重新启动时，应用层会读取持久化快照并恢复其保存的状态。</p><p>以前，本实验室曾建议您实现一个名为 <code>CondInstallSnapshot</code> 的函数，以避免快照和应用重启时发送的日志条目相互协调的要求。这个残留的 API 接口仍然存在，但我们不建议您实现它：相反，我们建议您只需让它返回 true 即可。</p><h4 id="任务-4"><a href="#任务-4" class="headerlink" title="任务"></a>任务</h4><p>实现 Snapshot() 和 InstallSnapshot RPC，并对 Raft 进行修改以支持这些操作（例如，使用修剪过的日志进行操作）。当您的解决方案通过 2D 测试（以及之前的所有 Lab 2 测试）时，它就完成了。</p><h4 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h4><ul><li>一个好的开始是你可以修改你的代码以便于能够只存储从某个索引<code>X</code>开始的日志部分。初始你可以设置<code>X</code>为0然后运行2B&#x2F;2C测试，然后使得<code>Snapshot(index)</code>丢弃在<code>index</code>之前的日志，并设置<code>X</code>为index，如果这些一切顺利，那么就可以通过第一个2D测试。</li><li>您不能将日志存储在 Go slice 中，也不能将 Go slice 索引与 Raft 日志索引互换使用；您需要对 slice 进行索引，以便考虑到日志中被丢弃的部分。</li><li>下一步：如果Leader没有更新追随者所需的日志条目，就让领导者发送 InstallSnapshot RPC。</li><li>在单个 InstallSnapshot RPC 中发送整个快照。不要执行图 13 中用于分割快照的偏移机制。</li><li>Raft 必须以允许 Go 垃圾回收器释放并重新使用内存的方式丢弃旧日志条目；这就要求丢弃的日志条目不存在可触及的引用（指针）。</li><li>即使日志被修剪，您的实现仍需要在 AppendEntries RPC 中的新条目之前正确发送条目的Term和Index；这可能需要保存和引用最新快照的 lastIncludedTerm&#x2F;lastIncludedIndex （考虑是否应持久化）。</li><li>Lab 2 全套测试（2A+2B+2C+2D）在不使用 -race 时的合理耗时为 6 分钟实时时间和 1 分钟 CPU 时间。使用 -race 时，实际耗时约为 10 分钟，CPU 耗时约为 2 分钟。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test -run <span class="number">2</span>D</span><br><span class="line">Test (<span class="number">2</span>D): snapshots basic ...</span><br><span class="line">  ... Passed --  <span class="number">11.6</span>  <span class="number">3</span>  <span class="number">176</span>   <span class="number">61716</span>  <span class="number">192</span></span><br><span class="line">Test (<span class="number">2</span>D): install snapshots (disconnect) ...</span><br><span class="line">  ... Passed --  <span class="number">64.2</span>  <span class="number">3</span>  <span class="number">878</span>  <span class="number">320610</span>  <span class="number">336</span></span><br><span class="line">Test (<span class="number">2</span>D): install snapshots (disconnect+unreliable) ...</span><br><span class="line">  ... Passed --  <span class="number">81.1</span>  <span class="number">3</span> <span class="number">1059</span>  <span class="number">375850</span>  <span class="number">341</span></span><br><span class="line">Test (<span class="number">2</span>D): install snapshots (crash) ...</span><br><span class="line">  ... Passed --  <span class="number">53.5</span>  <span class="number">3</span>  <span class="number">601</span>  <span class="number">256638</span>  <span class="number">339</span></span><br><span class="line">Test (<span class="number">2</span>D): install snapshots (unreliable+crash) ...</span><br><span class="line">  ... Passed --  <span class="number">63.5</span>  <span class="number">3</span>  <span class="number">687</span>  <span class="number">288294</span>  <span class="number">336</span></span><br><span class="line">Test (<span class="number">2</span>D): crash and restart all servers ...</span><br><span class="line">  ... Passed --  <span class="number">19.5</span>  <span class="number">3</span>  <span class="number">268</span>   <span class="number">81352</span>   <span class="number">58</span></span><br><span class="line">PASS</span><br><span class="line">ok      <span class="number">6.824</span>/raft      <span class="number">293.456</span>s</span><br></pre></td></tr></table></figure><p><img src="/../../../../../img/Pasted%20image%2020231130175310.png"></p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>Follower多久进行一次快照</p><ul><li>论文中提到当日志达到固定大小时，进行快照</li></ul><p>Snapshot由谁触发</p><ul><li>由上层应用进行触发，当上层应用认为可以将已经提交的日志进行压缩，那么就会调用节点的<code>Snapshot()</code>的函数。</li><li>快照中包含了上层应用的最新状态，意味着raft中的日志已经成功地应用到了上层应用中，这些日志已经不再需要存储了。</li></ul><p>需要做一个index的转换</p><ul><li><code>storeIndex</code>：是日志存储在log中的实际索引，<code>storeIndex=logIndex-lastIncludedIndex</code></li><li><code>logIndex</code>：是日志的逻辑索引，<code>logIndex=storeIndex+lastIncludedIndex</code><br>对log切片操作使用<code>storeIndex</code>，其他情况使用<code>logIndex</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get log entry by logical index</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> getEntry(logIndex <span class="type">int</span>) LogEntry &#123;</span><br><span class="line"><span class="keyword">return</span> rf.log[rf.getStoreIndex(logIndex)]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get physical index by logical index</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> getStoreIndex(logIndex <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> logIndex - rf.lastIncludedIndex</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get logical index by physical index</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> getLogIndex(storeIndex <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> storeIndex + rf.lastIncludedIndex</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// return the logical index of the last log entry</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> lastEntryLogIndex() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> rf.getLogIndex(<span class="built_in">len</span>(rf.log) - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return the term of the last log entry</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> lastEntryTerm() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> rf.log[<span class="built_in">len</span>(rf.log) - <span class="number">1</span>].Term</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return the logical length of log</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> getLogLength() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(rf.log)+rf.lastIncludedIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Snapshot</strong>：接收上层应用发来的快照，<code>index</code>表示上层应用已经应用的条目<code>index</code>，<code>snapshot</code>表示在应用了该<code>index</code>为止的条目下上层应用的最新数据。</p><ul><li>判断<code>index</code>是否合法。</li><li>更新<code>lastIncludedTerm</code>、<code>lastIncludedIndex</code>、<code>snapshot</code></li><li>压缩日志，更新<code>commitIndex</code>和<code>lastApplied</code>。因为既然上层应用已经应用了所有<code>index</code>之前的日志。</li><li>持久化。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the service says it has created a snapshot that has</span></span><br><span class="line"><span class="comment">// all info up to and including index. this means the</span></span><br><span class="line"><span class="comment">// service no longer needs the log through (and including)</span></span><br><span class="line"><span class="comment">// that index. Raft should now trim its log as much as possible.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Snapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line"><span class="comment">// Your code here (2D).</span></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"><span class="comment">// replace log with snapshot</span></span><br><span class="line">DPrintf(<span class="string">&quot;[Snapshot start][Snapshot()]:Peer[%d] start save Snapshot with index:[%d] and lastIndex:[%d] log:[%d]| %s\n&quot;</span>,rf.me,index,rf.lastIncludedIndex,<span class="built_in">len</span>(rf.log),time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line"><span class="keyword">var</span> logIndex = rf.getStoreIndex(index)</span><br><span class="line"><span class="keyword">if</span> logIndex&lt;=<span class="number">0</span> || logIndex &gt;=<span class="built_in">len</span>(rf.log)&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">DPrintf(<span class="string">&quot;[Snapshot Doing][Snapshot()]:Peer[%d] is saving Snapshot with index:[%d]| %s\n&quot;</span>,rf.me,index,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">rf.lastIncludedTerm = rf.getEntry(index).Term</span><br><span class="line">rf.lastIncludedIndex = index</span><br><span class="line">rf.snapshot = snapshot</span><br><span class="line">rf.log = <span class="built_in">append</span>([]LogEntry&#123;&#123;Term: rf.lastIncludedTerm&#125;&#125;, rf.log[logIndex+<span class="number">1</span>:]...)</span><br><span class="line"><span class="comment">// todo: check the following code if necessary</span></span><br><span class="line"><span class="keyword">if</span> rf.commitIndex &lt; rf.lastIncludedIndex&#123;</span><br><span class="line">rf.commitIndex = rf.lastIncludedIndex</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> rf.lastApplied &lt; rf.lastIncludedIndex&#123;</span><br><span class="line">rf.lastApplied = rf.lastIncludedIndex</span><br><span class="line">&#125;</span><br><span class="line">w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">e := labgob.NewEncoder(w)</span><br><span class="line">e.Encode(rf.currentTerm)</span><br><span class="line">e.Encode(rf.votedFor)</span><br><span class="line">e.Encode(rf.log)</span><br><span class="line">e.Encode(rf.lastIncludedIndex)</span><br><span class="line">e.Encode(rf.lastIncludedTerm)</span><br><span class="line">data := w.Bytes()</span><br><span class="line">rf.persister.SaveStateAndSnapshot(data,rf.snapshot)</span><br><span class="line">DPrintf(<span class="string">&quot;[Snapshot success][Snapshot()]:Peer[%d] SaveStateAndSnapshot [index:%d | term:%d] log:%v| %s\n&quot;</span>,rf.me,rf.lastIncludedIndex,rf.lastIncludedTerm,rf.log,time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>InstallSnapshot</strong>：安装快照，落后太多的节点需要通过安装快照来快速跟进。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> InstallSnapshotArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Term              <span class="type">int</span></span><br><span class="line">LeaderId          <span class="type">int</span></span><br><span class="line">LastIncludedIndex <span class="type">int</span></span><br><span class="line">LastIncludedTerm  <span class="type">int</span></span><br><span class="line">Data              []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> InstallSnapshotReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Term <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// InstallSnapshot RPC hander</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line"><span class="comment">// from old Term</span></span><br><span class="line"><span class="keyword">if</span> args.Term &lt; rf.currentTerm&#123;</span><br><span class="line">DPrintf(<span class="string">&quot;[InstallSnapshot][InstallSnapshot()]:Peer[%d] in term[%d] receive pre Snapshot from Leader[%d] in term[%d]| %s\n&quot;</span>, rf.me, rf.currentTerm, args.LeaderId, args.Term, time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">DPrintf(<span class="string">&quot;[InstallSnapshot start][InstallSnapshot()]:Peer[%d] in term[%d] start install a Snapshot from Leader[%d] in term[%d] rf.lastIndex:[%d] args.lastIndex:[%d]| %s\n&quot;</span>, rf.me, rf.currentTerm, args.LeaderId, args.Term,rf.lastIncludedIndex,args.LastIncludedIndex, time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line"></span><br><span class="line">rf.role = FOLLOWER</span><br><span class="line">rf.refreshTimeout()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.LastIncludedIndex &lt;= rf.commitIndex&#123;</span><br><span class="line">DPrintf(<span class="string">&quot;[InstallSnapshot]:Peer[%d] in term[%d] receive old Snapshot with lastIndex[%d] but Peer&#x27;s commitIndex[%d] and | %s\n&quot;</span>, rf.me, rf.currentTerm, args.LastIncludedIndex,rf.commitIndex, time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.LastIncludedIndex&gt;rf.lastIncludedIndex&#123;</span><br><span class="line"><span class="comment">// update snapshot</span></span><br><span class="line"><span class="keyword">var</span> storeIndex = rf.getStoreIndex(args.LastIncludedIndex)</span><br><span class="line"><span class="keyword">var</span> lastIndex = rf.lastEntryLogIndex()</span><br><span class="line">rf.lastIncludedIndex = args.LastIncludedIndex</span><br><span class="line">rf.lastIncludedTerm = args.LastIncludedTerm</span><br><span class="line"><span class="keyword">if</span> args.LastIncludedIndex &gt;= lastIndex&#123;</span><br><span class="line"><span class="comment">// remove all local log</span></span><br><span class="line">rf.log=[]LogEntry&#123;&#123;Term: rf.lastIncludedTerm&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">rf.log=<span class="built_in">append</span>([]LogEntry&#123;&#123;Term: rf.lastIncludedTerm&#125;&#125;,rf.log[storeIndex+<span class="number">1</span>:]...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// update lastApplied and commitIndex</span></span><br><span class="line">rf.snapshot = args.Data</span><br><span class="line">rf.lastApplied = rf.lastIncludedIndex</span><br><span class="line">rf.commitIndex = rf.lastIncludedIndex</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply snapshot</span></span><br><span class="line">w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">e := labgob.NewEncoder(w)</span><br><span class="line">e.Encode(rf.currentTerm)</span><br><span class="line">e.Encode(rf.votedFor)</span><br><span class="line">e.Encode(rf.log)</span><br><span class="line">e.Encode(rf.lastIncludedIndex)</span><br><span class="line">e.Encode(rf.lastIncludedTerm)</span><br><span class="line">data := w.Bytes()</span><br><span class="line">rf.persister.SaveStateAndSnapshot(data,rf.snapshot)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> appMsg = ApplyMsg&#123;</span><br><span class="line">CommandValid: <span class="literal">false</span>,</span><br><span class="line">Snapshot: args.Data,</span><br><span class="line">SnapshotValid: <span class="literal">true</span>,</span><br><span class="line">SnapshotIndex: args.LastIncludedIndex,</span><br><span class="line">SnapshotTerm: args.LastIncludedTerm,</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">rf.applyCh&lt;-appMsg</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"></span><br><span class="line">DPrintf(<span class="string">&quot;[InstallSnapshot]:Peer[%d] in term[%d] receive and install a Snapshot[%d] from Leader[%d] in term[%d]| %s\n&quot;</span>, rf.me, rf.currentTerm, args.LastIncludedIndex,args.LeaderId, args.Term, time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">DPrintf(<span class="string">&quot;[InstallSnapshot]:Peer[%d] in term[%d] receive old Snapshot from Leader[%d] in term[%d]| %s\n&quot;</span>, rf.me, rf.currentTerm, args.LeaderId, args.Term, time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send a InstallSnapshot RPC to a server.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> sendInstallSnapshot(server <span class="type">int</span>, args *InstallSnapshotArgs, reply *InstallSnapshotReply) <span class="type">bool</span> &#123;</span><br><span class="line">ok := rf.peers[server].Call(<span class="string">&quot;Raft.InstallSnapshot&quot;</span>, args, reply)</span><br><span class="line"><span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Test (<span class="number">2</span>C): basic persistence ...</span><br><span class="line">  ... Passed --   <span class="number">2.8</span>  <span class="number">3</span>  <span class="number">112</span>   <span class="number">29817</span>    <span class="number">6</span></span><br><span class="line">Test (<span class="number">2</span>C): more persistence ...</span><br><span class="line">  ... Passed --  <span class="number">15.3</span>  <span class="number">5</span> <span class="number">1682</span>  <span class="number">352486</span>   <span class="number">16</span></span><br><span class="line">Test (<span class="number">2</span>C): partitioned leader and one follower crash, leader restarts ...</span><br><span class="line">  ... Passed --   <span class="number">2.2</span>  <span class="number">3</span>   <span class="number">55</span>   <span class="number">12935</span>    <span class="number">4</span></span><br><span class="line">Test (<span class="number">2</span>C): Figure <span class="number">8</span> ...</span><br><span class="line">  ... Passed --  <span class="number">31.9</span>  <span class="number">5</span> <span class="number">2558</span>  <span class="number">570007</span>   <span class="number">70</span></span><br><span class="line">Test (<span class="number">2</span>C): unreliable agreement ...</span><br><span class="line">  ... Passed --   <span class="number">1.3</span>  <span class="number">5</span> <span class="number">1327</span>  <span class="number">453328</span>  <span class="number">246</span></span><br><span class="line">Test (<span class="number">2</span>C): Figure <span class="number">8</span> (unreliable) ...</span><br><span class="line">  ... Passed --  <span class="number">41.3</span>  <span class="number">5</span> <span class="number">24456</span> <span class="number">102647293</span>  <span class="number">326</span></span><br><span class="line">Test (<span class="number">2</span>C): churn ...</span><br><span class="line">  ... Passed --  <span class="number">16.3</span>  <span class="number">5</span> <span class="number">16439</span> <span class="number">93039197</span> <span class="number">2731</span></span><br><span class="line">Test (<span class="number">2</span>C): unreliable churn ...</span><br><span class="line">  ... Passed --  <span class="number">16.1</span>  <span class="number">5</span> <span class="number">12240</span> <span class="number">36402164</span> <span class="number">1943</span></span><br><span class="line">PASS</span><br><span class="line">ok      <span class="number">6.824</span>/raft      <span class="number">127.230</span>s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>0   1   2   3   4<br>x   x   x    x   x    len&#x3D;5</p><p>0   1   2             len&#x3D;3 , lastIndex &#x3D; 2<br>x   x   x</p><p>bug有一个节点一直收不到心跳，死锁了？<br>out2D_12：为什么反复apply 10的信息<br>out2D_13：apply error: server 1 snapshot doesn’t match m.SnapshotIndex</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 微服务和分布式 </category>
          
          <category> 6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构设计</title>
      <link href="/posts/bc2465ef/"/>
      <url>/posts/bc2465ef/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>一些常用数据结构的实现：如队列和栈的转化，LRU&#x2F;LFU算法设计。</p><h1 id="LRU设计"><a href="#LRU设计" class="headerlink" title="LRU设计"></a>LRU设计</h1><p><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></p>]]></content>
      
      
      <categories>
          
          <category> 大模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab 1.MapReduce</title>
      <link href="/posts/ddf70eb0/"/>
      <url>/posts/ddf70eb0/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-1-MapReduce"><a href="#Lab-1-MapReduce" class="headerlink" title="Lab 1 - MapReduce"></a>Lab 1 - MapReduce</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在本实验中，您将构建一个 MapReduce 系统。您将实现一个调用应用程序 Map 和 Reduce 函数并处理文件读写的 Worker 进程，以及一个将任务分派给 Worker 并处理失败 Worker 的主进程。您将构建与 MapReduce 论文类似的内容。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>我们在 <code>src/main/mrsequential.go</code> 中为您提供了一个简单的顺序 mapreduce 实现。它在一个进程中一次运行一个映射和还原。我们还为您提供了几个 MapReduce 应用程序：<code>mrapps/wc.go</code> 中的 <code>word-count</code> 和<code>mrapps/indexer.go</code> 中的文本索引器。您可以按如下顺序运行 word count：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/6.824</span><br><span class="line">$ <span class="built_in">cd</span> src/main</span><br><span class="line">$ go build -buildmode=plugin ../mrapps/wc.go</span><br><span class="line">$ <span class="built_in">rm</span> mr-out*</span><br><span class="line">$ go run mrsequential.go wc.so pg*.txt</span><br><span class="line">$ more mr-out-0</span><br><span class="line">A 509</span><br><span class="line">ABOUT 2</span><br><span class="line">ACT 8</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>请随意借用 mrsequential.go 中的代码。你还应该看看 mrapps&#x2F;wc.go，看看 MapReduce 应用程序的代码是什么样的。</p><h2 id="你的任务"><a href="#你的任务" class="headerlink" title="你的任务"></a>你的任务</h2><p>你的任务是实现一个分布式 MapReduce，它由两个程序组成，即主进程和工作进程。其中只有一个主进程和一个或多个并行执行的工作进程。在真实系统中，工作进程会运行在多台不同的机器上，但在本实验室中，你将在一台机器上运行所有工作进程。工作进程将通过 RPC 与主进程对话。每个 Worker 进程都会向主进程请求任务，从一个或多个文件中读取任务输入，执行任务，并将任务输出写入一个或多个文件。如果某个 Worker 在合理的时间内（在本实验室中为 10 秒）没有完成任务，主进程就会注意到，并将相同的任务交给另一个 Worker。</p><p>我们已经给了你一些代码作为起步。Master和Worker的主要代码在<code>main/mrmaster.go</code> 和<code> main/mrworker.go</code>中，<strong>请不要改变这些文件</strong>。你应该将你的实现置于<code>mr/master.go</code>, <code>mr/worker.go</code>, 和<code>mr/rpc.go</code>中。</p><p>下面介绍如何在 word-count MapReduce 应用程序上运行代码。首先，确保 word-count 插件是全新构建的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build -buildmode=plugin ../mrapps/wc.go</span><br></pre></td></tr></table></figure><p>在main目录，运行master进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> mr-out*</span><br><span class="line">$ go run mrmaster.go pg-*.txt</span><br></pre></td></tr></table></figure><p>mrmaster.go 的 <code>pg-*.txt</code> 参数是输入文件；每个文件对应一个 “分割”，是一个 Map 任务的输入。</p><p>在一个或多个其他窗口中，运行一些workers进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run mrworker.go wc.so</span><br></pre></td></tr></table></figure><p>当master和workers完成后，查看 mr-out-* 中的输出。完成实验后，输出文件的排序联合应与顺序输出一致，就像这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> mr-out-* | <span class="built_in">sort</span> | more</span><br><span class="line">A 509</span><br><span class="line">ABOUT 2</span><br><span class="line">ACT</span><br></pre></td></tr></table></figure><p>我们为您提供了一个测试脚本（<code>main/test-mr.sh</code>）。这些测试将检查 <code>wc</code> 和<code>indexer</code> MapReduce 应用程序在输入 pg-xxx.txt 文件时是否产生正确的输出。测试还会检查你的实现是否并行运行 Map 和 Reduce 任务，以及你的实现是否能从运行任务时崩溃的 Worker 中恢复。<br>如果您现在运行测试脚本，它就会挂起，因为主程序永远不会结束：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/6.824/src/main</span><br><span class="line">$ sh test-mr.sh</span><br><span class="line">*** Starting <span class="built_in">wc</span> <span class="built_in">test</span>.</span><br></pre></td></tr></table></figure><p>您可以将 <code>mr/master.go</code> 中 Done 函数中的 ret :&#x3D; false 改为 true，这样主控程序就会立即退出。然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sh ./test-mr.sh</span><br><span class="line">*** Starting <span class="built_in">wc</span> <span class="built_in">test</span>.</span><br><span class="line"><span class="built_in">sort</span>: No such file or directory</span><br><span class="line">cmp: EOF on mr-wc-all</span><br><span class="line">--- <span class="built_in">wc</span> output is not the same as mr-correct-wc.txt</span><br><span class="line">--- <span class="built_in">wc</span> <span class="built_in">test</span>: FAIL</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>测试脚本希望看到名为<code>mr-out-X</code> 的文件输出，每个reduce任务一个文件。<code>mr/master.go</code> 和 <code>mr/worker.go</code> 的空实现不会生成这些文件（也不会做其他任何事情），因此测试失败。</p><p>完成后，测试脚本输出应该如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ sh ./test-mr.sh</span><br><span class="line">*** Starting <span class="built_in">wc</span> <span class="built_in">test</span>.</span><br><span class="line">--- <span class="built_in">wc</span> <span class="built_in">test</span>: PASS</span><br><span class="line">*** Starting indexer <span class="built_in">test</span>.</span><br><span class="line">--- indexer <span class="built_in">test</span>: PASS</span><br><span class="line">*** Starting map parallelism <span class="built_in">test</span>.</span><br><span class="line">--- map parallelism <span class="built_in">test</span>: PASS</span><br><span class="line">*** Starting reduce parallelism <span class="built_in">test</span>.</span><br><span class="line">--- reduce parallelism <span class="built_in">test</span>: PASS</span><br><span class="line">*** Starting crash <span class="built_in">test</span>.</span><br><span class="line">--- crash <span class="built_in">test</span>: PASS</span><br><span class="line">*** PASSED ALL TESTS</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>还会看到一些来自 Go RPC 软件包的错误，这些错误看起来像：忽略这些信息即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019/12/16 13:27:09 rpc.Register: method <span class="string">&quot;Done&quot;</span> has 1 input parameters; needs exactly three</span><br></pre></td></tr></table></figure><h2 id="几条规则"><a href="#几条规则" class="headerlink" title="几条规则"></a>几条规则</h2><ul><li>Map阶段应将中间键分成多个桶，用于执行 <code>nReduce</code> 缩减任务，其中 <code>nReduce</code> 是 <code>main/mrmaster.go</code> 传递给 MakeMaster() 的参数。</li><li>Worker的实现中应该将第X个Reduce任务的输出放在<code>mr-out-X</code>的文件中。</li><li>mr-out-X 文件应包含每个 Reduce 函数输出的一行。这一行应该以 Go 的”%v %v “格式生成，并以键和值调用。请查看 <code>main/mrsequential.go</code> 中注释为 “这是正确格式 “的一行。如果您的实现与此格式偏差过大，测试脚本就会失败。</li><li>您可以修改 <code>mr/worker.go</code>、<code>mr/master.go</code> 和 <code>mr/rpc.go</code>。您可以临时修改其他文件进行测试，但请确保您的代码能在原始版本下运行；我们将使用原始版本进行测试。</li><li>Worker 应将中间的 Map 输出放到当前目录下的文件中，这样 Worker 就能将其作为 Reduce 任务的输入进行读取。</li><li><code>main/mrmaster.go</code> 希望 <code>mr/master.go</code> 实现一个 Done() 方法，当 MapReduce 作业完全完成时返回 true；此时，<code>mrmaster.go</code> 将退出。</li><li>任务完全完成后，工作进程应退出。实现这一点的简单方法是使用 call() 的返回值：如果工作者无法联系到主进程，它可以认为主进程已经退出，因为工作已经完成，因此工作者也可以终止。根据您的设计，您可能还会发现，主控程序可以给工人一个 “请退出 “的伪任务，这也是很有帮助的。</li></ul><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>一种入门方法是修改 <code>mr/worker.go</code> 的 Worker() 向主程序发送 RPC，请求执行任务。然后修改 master，使其响应一个尚未启动的 Map 任务的文件名。然后修改 Worker，读取该文件并调用应用程序的 Map 函数，就像 <code>mrsequential.go</code> 中那样。</li><li>应用程序的 Map 和 Reduce 功能是在运行时使用 Go 插件包从名称以 .so 结尾的文件中加载的。</li><li>如果更改了 mr&#x2F;目录中的任何内容，很可能需要重新构建使用的 MapReduce 插件，方法如下：go build -buildmode&#x3D;plugin ..&#x2F;mrapps&#x2F;wc.go</li><li>本实验室依赖于workers共享一个文件系统。当所有workers都在同一台机器上运行时，共享文件系统很简单，但如果工作者运行在不同的机器上，就需要一个类似 GFS 的全局文件系统。</li><li>中间文件的合理命名约定是 mr-X-Y，其中 X 是映射任务编号，Y 是还原任务编号。</li><li>Worker 的 map 任务代码需要一种方法，将中间键&#x2F;值对存储在文件中，以便在 reduce 任务中正确读回。其中一种方法是使用 Go 的编码&#x2F;json 包。将键&#x2F;值对写入 JSON 文件：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enc := json.NewEncoder(file)</span><br><span class="line">  <span class="keyword">for</span> _, kv := ... &#123;</span><br><span class="line">    err := enc.Encode(&amp;kv)</span><br></pre></td></tr></table></figure>并读回这样的文件：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dec := json.NewDecoder(file)</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> kv KeyValue</span><br><span class="line">    <span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    kva = <span class="built_in">append</span>(kva, kv)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>Worker 的 map 部分可以使用 ihash(key) 函数（worker.go 中）为给定 key 挑选还原任务。</li><li>你可以从 <code>mrsequential.go</code> 中窃取一些代码，用于读取 Map 输入文件、在 Map 和 Reduce 之间对键值对进行排序，以及将 Reduce 输出存储到文件中。</li><li>Master作为 RPC 服务器，将是并发的；不要忘记锁定共享数据。</li><li>使用 go 的竞赛检测器，即 go build -race 和 go run -race。test-mr.sh 的注释说明了如何为测试启用竞赛检测器。<a href="https://blog.csdn.net/wan212000/article/details/128816444">go 的竞态检测机制 (race)_go race-CSDN博客</a></li><li>worker进程有时需要等待，例如，在上一个map任务完成之前，reduce任务无法启动。一种方法是让worker进程定期向master请求任务，在每次请求之间使用 time.Sleep() 休眠。另一种方法是让主程序中的相关 RPC 处理程序循环等待，可以使用 time.Sleep() 或 sync.Cond。Go 在自己的线程中运行每个 RPC 的处理程序，因此一个处理程序正在等待不会妨碍主程序处理其他 RPC。</li><li>master程序无法可靠地区分崩溃的worker、存活但因故停滞的worker，以及正在执行但速度太慢而无用的worker。你能做的最好办法就是让主程序等待一段时间，然后放弃，将任务重新分配给不同的worker。在本实验中，让主程序等待十秒钟；十秒钟后，主程序应假定 worker 已死亡（当然，也可能没有死亡）。</li><li>要测试崩溃恢复，可以使用 <code>mrapps/crash.go</code> 应用程序插件。它会在 Map 和 Reduce 功能中随机退出。</li><li>为了确保没有人会在崩溃时观察到部分写入的文件，MapReduce 论文提到了使用临时文件并在完全写入后原子重命名的技巧。您可以使用 ioutil.TempFile 创建临时文件，并使用 os.Rename 原子重命名临时文件。</li><li>test-mr.sh 运行子目录 mr-tmp 中的所有进程，因此如果出了问题，需要查看中间文件或输出文件，请到那里查看。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>一共M个map任务，对应M个输入文章；N个reduce任务，N是由输入程序的参数决定</li><li>Worker.go负责获取任务-执行map&#x2F;reduce任务</li><li>Coordinator.go可以理解为调度中心，负责存储任务-分发任务-响应worker</li><li>Rpc.go存储用于PRC的参数</li></ul><blockquote><p>Worker.go</p></blockquote><ul><li>Map函数过程：<ul><li>打开给定文件</li><li>调用map函数，生成如<code>[&#123;&quot;word1&quot;,&quot;1&quot;&#125;,&#123;&quot;word2&quot;,&quot;1&quot;&#125;,&#123;&#125;]</code>的kv列表</li><li>根据key排序，计算ihash(key)%N&#x3D;Y，记录到mr-X-Y中。（json形式）这边需要原子重命名</li><li>RPC通知完成</li></ul></li><li>Reduce函数过程：<ul><li>读入所有mr-i-Y的文件，获取键值对</li><li>排序</li><li>遍历相同的key，生成 <code>key到string[]</code>的形式</li><li>调用reduce函数</li><li>写入mr-out-Y文件。（json形式）需要原子重命名</li><li>RPC通知完成</li></ul></li></ul><blockquote><p>Coordinator.go</p></blockquote><ul><li>如何存储map和reduce任务的信息</li><li>如何分发任务：worker不断问coordinator要任务，coordinator根据当前阶段map&#x2F;reduce，发放对应未被完成的任务，worker完成后，通知coordinator标记任务状态。</li><li>当所有任务完成后，执行Done</li><li>当worker宕机后，如何重分配任务</li></ul><p>Coordinator结构（初步，后续根据测试结果进行修改）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TaskType <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> State <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MAP TaskType = <span class="literal">iota</span></span><br><span class="line">REDUCE</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">WAITING State = <span class="literal">iota</span></span><br><span class="line">DONE</span><br><span class="line">)</span><br><span class="line"><span class="comment">//计数器-用于产生全局唯一任务编号</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">lock sync.Mutex</span><br><span class="line">value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> addValue()&#123;</span><br><span class="line">c.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.lock.Unlock()</span><br><span class="line">c.value++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> getValue() <span class="type">int</span>&#123;</span><br><span class="line">c.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.lock.Unlock()</span><br><span class="line"><span class="keyword">return</span> c.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> resetValue()&#123;</span><br><span class="line">c.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.lock.Unlock()</span><br><span class="line">c.value=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your definitions here.</span></span><br><span class="line">mMap        <span class="type">int</span>        <span class="comment">//map任务数量</span></span><br><span class="line">nReduce     <span class="type">int</span>        <span class="comment">//reduce任务数量</span></span><br><span class="line">mDone       <span class="type">int</span>        <span class="comment">//map已完成数量</span></span><br><span class="line">nDone       <span class="type">int</span>        <span class="comment">//reduce已完成数量</span></span><br><span class="line">mapTasks    []Task     <span class="comment">//map任务列表</span></span><br><span class="line">reduceTasks []Task     <span class="comment">//reduce任务列表</span></span><br><span class="line">lock        sync.Mutex <span class="comment">//锁</span></span><br><span class="line">state       State      <span class="comment">//当前状态 map或reduce阶段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">id        <span class="type">int</span>       <span class="comment">//任务编号</span></span><br><span class="line">filename  <span class="type">string</span>    <span class="comment">//任务名，reduce任务没有这个</span></span><br><span class="line">isDone    <span class="type">bool</span>      <span class="comment">//是否完成</span></span><br><span class="line">taskType  TaskType  <span class="comment">//任务类型 map or reduce</span></span><br><span class="line">startTime time.Time <span class="comment">//开始时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rpc分配任务</span></span><br><span class="line"><span class="comment">//AskTask()</span></span><br><span class="line"><span class="comment">//1.加锁</span></span><br><span class="line"><span class="comment">//2.判断当前State MAPPING/REDUCING</span></span><br><span class="line"><span class="comment">//3.选出未被分配的任务 设置任务开始时间</span></span><br><span class="line"><span class="comment">//3.1没有任务了，返回nil,worker接到nil后退出</span></span><br><span class="line"><span class="comment">//4.返回给worker</span></span><br><span class="line"><span class="comment">//5.解锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//rpc设置任务状态</span></span><br><span class="line"><span class="comment">//TaskDone()</span></span><br><span class="line"><span class="comment">//1.加锁</span></span><br><span class="line"><span class="comment">//2.设置任务已完成 设置mDone / nDone</span></span><br><span class="line"><span class="comment">//3.检查一下是否全部mDone已完成，是-改变State</span></span><br><span class="line"><span class="comment">//4.返回给worker</span></span><br><span class="line"><span class="comment">//5.解锁</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>RPC.go</p></blockquote><ul><li>定义RPC的数据结构</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义rpc的结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//AskTask</span></span><br><span class="line"><span class="keyword">type</span> AskTaskArgs <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="comment">//似乎不用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AskTaskReply <span class="keyword">struct</span>&#123;</span><br><span class="line">task Task</span><br><span class="line">mMap <span class="type">int</span></span><br><span class="line">nReduce <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AskTask</span></span><br><span class="line"><span class="keyword">type</span> TaskDoneArgs <span class="keyword">struct</span>&#123;</span><br><span class="line">task Task</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TaskDoneReply <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="comment">//似乎不用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p>worker.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mr</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;path/filepath&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/rpc&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;hash/fnv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Map functions return a slice of KeyValue.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">type</span> KeyValue <span class="keyword">struct</span> &#123;</span><br><span class="line">Key   <span class="type">string</span></span><br><span class="line">Value <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ByKey []KeyValue</span><br><span class="line"></span><br><span class="line"><span class="comment">// for sorting by key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span></span> Swap(i, j <span class="type">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> a[i].Key &lt; a[j].Key &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// use ihash(key) % NReduce to choose the reduce</span></span><br><span class="line"><span class="comment">// task number for each KeyValue emitted by Map.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ihash</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">h := fnv.New32a()</span><br><span class="line">h.Write([]<span class="type">byte</span>(key))</span><br><span class="line"><span class="keyword">return</span> <span class="type">int</span>(h.Sum32() &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main/mrworker.go calls this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue,</span><br><span class="line">reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your worker implementation here.</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">//下述代码应该循环执行</span></span><br><span class="line"><span class="comment">//1.rpc请求任务-获取到任务Task信息</span></span><br><span class="line">askTaskArgs := AskTaskArgs&#123;&#125;</span><br><span class="line">askTaskReply := AskTaskReply&#123;&#125;</span><br><span class="line"><span class="comment">//CallAskTask()</span></span><br><span class="line">askTaskRPC := call(<span class="string">&quot;Coordinator.AskTask&quot;</span>, &amp;askTaskArgs, &amp;askTaskReply)</span><br><span class="line"><span class="keyword">if</span> askTaskRPC &#123;</span><br><span class="line"><span class="comment">//fmt.Printf(&quot;call AskTask success!\n&quot;)</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//fmt.Printf(&quot;call AskTask failed!\n&quot;)</span></span><br><span class="line"><span class="comment">//这里其实可以进行休眠一段时间后，重试</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> taskType = askTaskReply.TaskType</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.map/reduce</span></span><br><span class="line"></span><br><span class="line">taskDoneArgs := TaskDoneArgs&#123;&#125;</span><br><span class="line">taskDoneReply := TaskDoneReply&#123;&#125;</span><br><span class="line">taskDoneArgs.TaskID = taskId</span><br><span class="line">taskDoneArgs.TaskType = taskType</span><br><span class="line"><span class="keyword">if</span> taskType == MAP &#123;</span><br><span class="line">taskId := askTaskReply.TaskID</span><br><span class="line">taskFilename := askTaskReply.Filename</span><br><span class="line">nReduce := askTaskReply.NReduce</span><br><span class="line"><span class="comment">//执行map任务</span></span><br><span class="line">ok := doMapTask(taskId, taskFilename, nReduce, mapf)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doneTaskRPC = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">doneTaskRPC = call(<span class="string">&quot;Coordinator.TaskDone&quot;</span>, &amp;taskDoneArgs, &amp;taskDoneReply)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// todo:如果服务器未收到任务完成的RPC,worker应该进行有限次重试</span></span><br><span class="line"><span class="keyword">if</span> doneTaskRPC &#123;</span><br><span class="line"><span class="comment">//fmt.Println(&quot;Task Done, coordinator has received!&quot;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> taskType == REDUCE &#123;</span><br><span class="line">taskId := askTaskReply.TaskID</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doneTaskRPC = <span class="literal">false</span></span><br><span class="line">ok := doReduceTask(taskId, reducef)</span><br><span class="line"><span class="comment">//ok := true</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">doneTaskRPC = call(<span class="string">&quot;Coordinator.TaskDone&quot;</span>, &amp;taskDoneArgs, &amp;taskDoneReply)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> doneTaskRPC &#123;</span><br><span class="line"><span class="comment">//fmt.Println(&quot;Task Done, coordinator has received!&quot;)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> taskType == KEEPWAITING &#123;</span><br><span class="line"><span class="comment">//Coordinator请求等待,当有map/reduce任务在执行中,但没有多余任务待分配的时候</span></span><br><span class="line">time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> taskType == NONE &#123;</span><br><span class="line"><span class="comment">//Coordinator请求Worker退出，当所有任务都被完成</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// uncomment to send the Example RPC to the coordinator.</span></span><br><span class="line"><span class="comment">// CallExample()</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do map task,if no err: return true else: return false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doMapTask</span><span class="params">(taskID <span class="type">int</span>, filename <span class="type">string</span>, nReduce <span class="type">int</span>, mapf <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">//1.打开文件(任务编号-X)</span></span><br><span class="line">fmt.Println(filename)</span><br><span class="line">file, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;cannot open %v&quot;</span>, filename)</span><br><span class="line">&#125;</span><br><span class="line">content, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;cannot read %v&quot;</span>, filename)</span><br><span class="line">&#125;</span><br><span class="line">file.Close()</span><br><span class="line"><span class="comment">//2.调用mapf</span></span><br><span class="line">kva := mapf(filename, <span class="type">string</span>(content))</span><br><span class="line"><span class="comment">//3.哈希 Y-Slice映射 调用ihash(k)%nReduce=Y</span></span><br><span class="line">kvmap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>][]KeyValue)</span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kva &#123;</span><br><span class="line"><span class="keyword">var</span> key = kv.Key</span><br><span class="line"><span class="keyword">var</span> hashY = ihash(key) % nReduce</span><br><span class="line"><span class="keyword">if</span> _, exists := kvmap[hashY]; !exists &#123;</span><br><span class="line">kvmap[hashY] = <span class="built_in">make</span>([]KeyValue, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">kvmap[hashY] = <span class="built_in">append</span>(kvmap[hashY], kv)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.存储至中间文件mr-X-Y</span></span><br><span class="line"><span class="keyword">for</span> hashY, kvs := <span class="keyword">range</span> kvmap &#123;</span><br><span class="line"><span class="comment">//fmt.Println(kvs)</span></span><br><span class="line"><span class="comment">//临时文件命名为: mr-tmp-X-Y</span></span><br><span class="line">newFileName := fmt.Sprintf(<span class="string">&quot;mr-tmp-%d-%d&quot;</span>, taskID, hashY)</span><br><span class="line"><span class="comment">// create temp file</span></span><br><span class="line">tempFile, err := ioutil.TempFile(<span class="string">&quot;./&quot;</span>, <span class="string">&quot;temp-&quot;</span>+newFileName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;cannot create %v&quot;</span>, newFileName)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建JSON编码器</span></span><br><span class="line">encoder := json.NewEncoder(tempFile)</span><br><span class="line"><span class="comment">// 使用编码器将数据写入文件</span></span><br><span class="line">err = encoder.Encode(kvs)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;error：%v  when writing %v&quot;</span>, err, newFileName)</span><br><span class="line">tempFile.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.原子重命名</span></span><br><span class="line">err = os.Rename(tempFile.Name(), newFileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;error：%v when rename tempfile: %v&quot;</span>, err, newFileName)</span><br><span class="line">tempFile.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">tempFile.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do reduce task,if no err: return true else: return false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doReduceTask</span><span class="params">(taskID <span class="type">int</span>, reducef <span class="keyword">func</span>(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">//1.读取文件(任务编号-Y)</span></span><br><span class="line">fmt.Println(taskID)</span><br><span class="line"><span class="keyword">var</span> hashY = taskID</span><br><span class="line">intermediate := []KeyValue&#123;&#125;</span><br><span class="line">directory := <span class="string">&quot;./&quot;</span></span><br><span class="line"><span class="comment">// 使用 filepath.Glob 查找匹配的文件,匹配所有mr-tmp-*-Y的文件</span></span><br><span class="line">filenameReg := fmt.Sprintf(<span class="string">&quot;mr-tmp-*-%d&quot;</span>, hashY)</span><br><span class="line">files, err := filepath.Glob(filepath.Join(directory, filenameReg))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;error：%v when find files with Y: %v&quot;</span>, err, hashY)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.存储kv</span></span><br><span class="line"><span class="keyword">for</span> _, filename := <span class="keyword">range</span> files &#123;</span><br><span class="line">file, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">file.Close()</span><br><span class="line">log.Fatalf(<span class="string">&quot;cannot open %v&quot;</span>, filename)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">decoder := json.NewDecoder(file)</span><br><span class="line"><span class="keyword">var</span> kvs []KeyValue</span><br><span class="line"><span class="keyword">if</span> err := decoder.Decode(&amp;kvs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">file.Close()</span><br><span class="line">log.Fatalf(<span class="string">&quot;error：%v when read mr files with Y: %v&quot;</span>, err, hashY)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">intermediate = <span class="built_in">append</span>(intermediate, kvs...)</span><br><span class="line">file.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.排序kv,目的是让相同的word &#123;&quot;word&quot;,&quot;1&quot;&#125;排到一起</span></span><br><span class="line">sort.Sort(ByKey(intermediate))</span><br><span class="line"></span><br><span class="line">oname := fmt.Sprintf(<span class="string">&quot;mr-out-%d&quot;</span>, hashY)</span><br><span class="line">tempFile, err := ioutil.TempFile(<span class="string">&quot;./&quot;</span>, <span class="string">&quot;temp-&quot;</span>+oname)</span><br><span class="line"><span class="comment">//4.调用reducef</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// call Reduce on each distinct key in intermediate[],</span></span><br><span class="line"><span class="comment">// and print the result to mr-out-0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(intermediate) &#123;</span><br><span class="line">j := i + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j &lt; <span class="built_in">len</span>(intermediate) &amp;&amp; intermediate[j].Key == intermediate[i].Key &#123;</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">values := []<span class="type">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k := i; k &lt; j; k++ &#123;</span><br><span class="line">values = <span class="built_in">append</span>(values, intermediate[k].Value)</span><br><span class="line">&#125;</span><br><span class="line">output := reducef(intermediate[i].Key, values)</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is the correct format for each line of Reduce output.</span></span><br><span class="line">_, err := fmt.Fprintf(tempFile, <span class="string">&quot;%v %v\n&quot;</span>, intermediate[i].Key, output)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">tempFile.Close()</span><br><span class="line">log.Fatalf(<span class="string">&quot;error :%v when writing to %v&quot;</span>, oname)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">i = j</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.写入mr-out-Y文件，原子重命名</span></span><br><span class="line">err = os.Rename(tempFile.Name(), oname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;error：%v when rename tempfile: %v&quot;</span>, err, oname)</span><br><span class="line">tempFile.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">tempFile.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// example function to show how to make an RPC call to the coordinator.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// the RPC argument and reply types are defined in rpc.go.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallExample</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// declare an argument structure.</span></span><br><span class="line">args := ExampleArgs&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill in the argument(s).</span></span><br><span class="line">args.X = <span class="number">99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// declare a reply structure.</span></span><br><span class="line">reply := ExampleReply&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// send the RPC request, wait for the reply.</span></span><br><span class="line"><span class="comment">// the &quot;Coordinator.Example&quot; tells the</span></span><br><span class="line"><span class="comment">// receiving server that we&#x27;d like to call</span></span><br><span class="line"><span class="comment">// the Example() method of struct Coordinator.</span></span><br><span class="line">ok := call(<span class="string">&quot;Coordinator.Example&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="comment">// reply.Y should be 100.</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;reply.Y %v\n&quot;</span>, reply.Y)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;call failed!\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// send an RPC request to the coordinator, wait for the response.</span></span><br><span class="line"><span class="comment">// usually returns true.</span></span><br><span class="line"><span class="comment">// returns false if something goes wrong.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">call</span><span class="params">(rpcname <span class="type">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// c, err := rpc.DialHTTP(&quot;tcp&quot;, &quot;127.0.0.1&quot;+&quot;:1234&quot;)</span></span><br><span class="line">sockname := coordinatorSock()</span><br><span class="line">c, err := rpc.DialHTTP(<span class="string">&quot;unix&quot;</span>, sockname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">err = c.Call(rpcname, args, reply)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>coordinator.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mr</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/rpc&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TaskType <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> State <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> TaskState <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义任务类型枚举</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MAP TaskType = <span class="literal">iota</span> <span class="comment">//Map任务</span></span><br><span class="line">REDUCE              <span class="comment">//REDUCE任务</span></span><br><span class="line">KEEPWAITING         <span class="comment">//待命任务(虚拟的)</span></span><br><span class="line">NONE                <span class="comment">//空任务(虚拟的)</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//定义Coordinator当前阶段</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MAPPING State = <span class="literal">iota</span> <span class="comment">//执行Map任务阶段</span></span><br><span class="line">REDUCING             <span class="comment">//执行Reduce任务阶段</span></span><br><span class="line">FINISHED             <span class="comment">//所有任务都完成阶段</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//定义任务状态</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">WAITING TaskState = <span class="literal">iota</span> <span class="comment">//待分配</span></span><br><span class="line">DOING                    <span class="comment">//进行中</span></span><br><span class="line">DONE                     <span class="comment">//已完成</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//定义任务Task结构体</span></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">Id        <span class="type">int</span>       <span class="comment">//任务编号</span></span><br><span class="line">Filename  <span class="type">string</span>    <span class="comment">//任务名，用于map任务</span></span><br><span class="line">State     TaskState <span class="comment">//是否完成</span></span><br><span class="line">TaskType  TaskType  <span class="comment">//任务类型 map or reduce or keepwaiting or none</span></span><br><span class="line">StartTime time.Time <span class="comment">//开始时间 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Coordinator结构体</span></span><br><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your definitions here.</span></span><br><span class="line">mMap        <span class="type">int</span>        <span class="comment">//map任务数量</span></span><br><span class="line">nReduce     <span class="type">int</span>        <span class="comment">//reduce任务数量</span></span><br><span class="line">mDone       <span class="type">int</span>        <span class="comment">//map已完成数量</span></span><br><span class="line">nDone       <span class="type">int</span>        <span class="comment">//reduce已完成数量</span></span><br><span class="line">mapTasks    []*Task    <span class="comment">//map任务列表</span></span><br><span class="line">reduceTasks []*Task    <span class="comment">//reduce任务列表</span></span><br><span class="line">lock        sync.Mutex <span class="comment">//锁</span></span><br><span class="line">state       State      <span class="comment">//当前状态 MAP或REDUCE或FINISHED</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your code here -- RPC handlers for the worker to call.</span></span><br><span class="line"><span class="comment">//分发worker任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> AskTask(args *AskTaskArgs, reply *AskTaskReply) <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">//1.加锁</span></span><br><span class="line">c.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.lock.Unlock()</span><br><span class="line"><span class="comment">//2.判断当前State MAPPING/REDUCING/FINISHED</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> task *Task</span><br><span class="line"><span class="keyword">if</span> c.state == MAPPING &#123;</span><br><span class="line"><span class="comment">//3.选出未被分配的任务 设置任务开始时间</span></span><br><span class="line"><span class="keyword">for</span> _, mapTask := <span class="keyword">range</span> c.mapTasks &#123;</span><br><span class="line"><span class="keyword">if</span> mapTask.State == WAITING &#123;</span><br><span class="line">mapTask.StartTime = time.Now()</span><br><span class="line">mapTask.State = DOING</span><br><span class="line">task = mapTask</span><br><span class="line"><span class="comment">//fmt.Println(&quot;coordinator has assigned a map task!&quot;)</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.1有待分配map任务，返回</span></span><br><span class="line"><span class="comment">//3.2没有任务了，返回KEEPWAITING任务，让worker等待</span></span><br><span class="line"><span class="keyword">if</span> task != <span class="literal">nil</span> &#123;</span><br><span class="line">reply.TaskID = task.Id</span><br><span class="line">reply.TaskType = task.TaskType</span><br><span class="line">reply.Filename = task.Filename</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reply.TaskType = KEEPWAITING</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> c.state == REDUCING &#123;</span><br><span class="line"><span class="comment">//3.选出未被分配的任务 设置任务开始时间</span></span><br><span class="line"><span class="keyword">for</span> _, reduceTask := <span class="keyword">range</span> c.reduceTasks &#123;</span><br><span class="line"><span class="keyword">if</span> reduceTask.State == WAITING &#123;</span><br><span class="line">reduceTask.StartTime = time.Now()</span><br><span class="line">reduceTask.State = DOING</span><br><span class="line">task = reduceTask</span><br><span class="line"><span class="comment">//fmt.Println(&quot;coordinator has assigned a reduce task!&quot;)</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.1有待分配reduce任务，返回</span></span><br><span class="line"><span class="comment">//3.2没有任务了，返回KEEPWAITING任务，让worker等待</span></span><br><span class="line"><span class="keyword">if</span> task != <span class="literal">nil</span> &#123;</span><br><span class="line">reply.TaskID = task.Id</span><br><span class="line">reply.TaskType = task.TaskType</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reply.TaskType = KEEPWAITING</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> c.state == FINISHED &#123;</span><br><span class="line"><span class="comment">// 所有任务已完成，返回虚拟的空任务，用于worker退出</span></span><br><span class="line">reply.TaskType = NONE</span><br><span class="line">&#125;</span><br><span class="line">reply.MMap = c.mMap</span><br><span class="line">reply.NReduce = c.nReduce</span><br><span class="line"><span class="comment">//no use</span></span><br><span class="line"><span class="keyword">if</span> task == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//fmt.Println(&quot;There are no tasks to be assigned!&quot;)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Printf(&quot;send task:%p\n&quot;, task)</span></span><br><span class="line"><span class="comment">//4.返回给worker</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">//5.解锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//任务确认完成</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> TaskDone(args *TaskDoneArgs, reply *TaskDoneReply) <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">//1.加锁</span></span><br><span class="line">c.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.lock.Unlock()</span><br><span class="line"><span class="comment">//2.设置任务已完成 设置mDone / nDone</span></span><br><span class="line"></span><br><span class="line">taskID := args.TaskID</span><br><span class="line">taskType := args.TaskType</span><br><span class="line"><span class="comment">//fmt.Printf(&quot;receive &amp;task:%p\n&quot;, task)</span></span><br><span class="line"><span class="comment">//fmt.Println(&quot;receive task:&quot;, task)</span></span><br><span class="line"><span class="comment">//3.检查一下是否全部mDone已完成，是-改变State</span></span><br><span class="line"><span class="comment">//这边c.state == MAPPING条件是避免有被认为宕机的worker重启后，重复发送taskDone，导致异常</span></span><br><span class="line"><span class="keyword">if</span> taskType == MAP &amp;&amp; c.state == MAPPING &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;mapTask(taskid:%d) has done\n&quot;</span>, taskID)</span><br><span class="line">c.mapTasks[taskID].State = DONE</span><br><span class="line">c.mDone++</span><br><span class="line"><span class="keyword">if</span> c.mDone == c.mMap &#123;</span><br><span class="line">c.state = REDUCING</span><br><span class="line">fmt.Println(<span class="string">&quot;------------Reduce------------&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> taskType == REDUCE &amp;&amp; c.state == REDUCING &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;reduceTask(taskid:%d) has done\n&quot;</span>, taskID)</span><br><span class="line">c.reduceTasks[taskID].State = DONE</span><br><span class="line">c.nDone++</span><br><span class="line"><span class="keyword">if</span> c.nDone == c.nReduce &#123;</span><br><span class="line">c.state = FINISHED</span><br><span class="line">fmt.Println(<span class="string">&quot;------------Finished------------&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">//4.返回给worker</span></span><br><span class="line"><span class="comment">//5.解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定期检查是否有任务超时未完成（10s）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> checkTasks() &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">c.lock.Lock()</span><br><span class="line">currentTime := time.Now()</span><br><span class="line">tenSecondsAgo := currentTime.Add(<span class="number">-10</span> * time.Second)</span><br><span class="line"><span class="keyword">if</span> c.state == FINISHED &#123;</span><br><span class="line">c.lock.Unlock()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> c.state == MAPPING &#123;</span><br><span class="line"><span class="keyword">for</span> _, mapTask := <span class="keyword">range</span> c.mapTasks &#123;</span><br><span class="line"><span class="keyword">if</span> mapTask.State == DOING &amp;&amp; mapTask.StartTime.Before(tenSecondsAgo) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;mapTask(taskid:%d) has restarted\n&quot;</span>, mapTask.Id)</span><br><span class="line">mapTask.State = WAITING</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> c.state == REDUCING &#123;</span><br><span class="line"><span class="keyword">for</span> _, reduceTask := <span class="keyword">range</span> c.reduceTasks &#123;</span><br><span class="line"><span class="keyword">if</span> reduceTask.State == DOING &amp;&amp; reduceTask.StartTime.Before(tenSecondsAgo) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;reduceTask(taskid:%d) has restarted\n&quot;</span>, reduceTask.Id)</span><br><span class="line">reduceTask.State = WAITING</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c.lock.Unlock()</span><br><span class="line"><span class="comment">// 每2s执行一次，避免一直占用锁，导致死锁</span></span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// an example RPC handler.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// the RPC argument and reply types are defined in rpc.go.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> Example(args *ExampleArgs, reply *ExampleReply) <span class="type">error</span> &#123;</span><br><span class="line">reply.Y = args.X + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// start a thread that listens for RPCs from worker.go</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> server() &#123;</span><br><span class="line">rpc.Register(c)</span><br><span class="line">rpc.HandleHTTP()</span><br><span class="line"><span class="comment">//l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)</span></span><br><span class="line">sockname := coordinatorSock()</span><br><span class="line">os.Remove(sockname)</span><br><span class="line">l, e := net.Listen(<span class="string">&quot;unix&quot;</span>, sockname)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;listen error:&quot;</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> http.Serve(l, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否所有任务已完成</span></span><br><span class="line"><span class="comment">// main/mrcoordinator.go calls Done() periodically to find out</span></span><br><span class="line"><span class="comment">// if the entire job has finished.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> Done() <span class="type">bool</span> &#123;</span><br><span class="line">ret := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line">c.lock.Lock()</span><br><span class="line"><span class="keyword">if</span> c.state != FINISHED &#123;</span><br><span class="line">c.lock.Unlock()</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;All tasks have done, coordinator return true!&quot;</span>)</span><br><span class="line">ret = <span class="literal">true</span></span><br><span class="line">c.lock.Unlock()</span><br><span class="line"><span class="comment">// 这边等待一秒，以便于让所有keepwaiting的worker收到NONE任务后可以退出</span></span><br><span class="line"><span class="comment">// 不然Coordinator先退出了，worker会调用rpc失败</span></span><br><span class="line"><span class="comment">// 不过也可以调用rpc失败时，worker自动退出</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;All worker has exited!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// create a Coordinator.</span></span><br><span class="line"><span class="comment">// main/mrcoordinator.go calls this function.</span></span><br><span class="line"><span class="comment">// nReduce is the number of reduce tasks to use.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeCoordinator</span><span class="params">(files []<span class="type">string</span>, nReduce <span class="type">int</span>)</span></span> *Coordinator &#123;</span><br><span class="line">c := Coordinator&#123;&#125;</span><br><span class="line">c.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.lock.Unlock()</span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line"><span class="comment">//Init coordinator and tasks.</span></span><br><span class="line">c.mMap = <span class="built_in">len</span>(files)</span><br><span class="line">c.nReduce = nReduce</span><br><span class="line">c.state = MAPPING</span><br><span class="line">c.mapTasks = <span class="built_in">make</span>([]*Task, c.mMap)</span><br><span class="line">c.reduceTasks = <span class="built_in">make</span>([]*Task, c.nReduce)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; c.mMap; i++ &#123;</span><br><span class="line">newTask := Task&#123;Id: i, Filename: files[i], State: WAITING, TaskType: MAP&#125;</span><br><span class="line">c.mapTasks[i] = &amp;newTask</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; c.nReduce; i++ &#123;</span><br><span class="line">newTask := Task&#123;Id: i, State: WAITING, TaskType: REDUCE&#125;</span><br><span class="line">c.reduceTasks[i] = &amp;newTask</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Printf(&quot;start .task:%p\n&quot;, c.mapTasks[0])</span></span><br><span class="line"><span class="comment">// 开启任务检查协程</span></span><br><span class="line"><span class="keyword">go</span> c.checkTasks()</span><br><span class="line">c.server()</span><br><span class="line"><span class="keyword">return</span> &amp;c</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>rpc.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mr</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// RPC definitions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// remember to capitalize all names.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// example to show how to declare the arguments</span></span><br><span class="line"><span class="comment">// and reply for an RPC.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ExampleArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ExampleReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add your RPC definitions here.</span></span><br><span class="line"><span class="comment">//AskTask</span></span><br><span class="line"><span class="keyword">type</span> AskTaskArgs <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//似乎不用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这边我不认为可以用*Task取代，虽然本实验是在同一台主机上进行的，共享内存地址</span></span><br><span class="line"><span class="comment">//但考虑实际分布式系统，如果返回任务指针的话，另一台主机应该不能通过*Task拿到Task</span></span><br><span class="line"><span class="keyword">type</span> AskTaskReply <span class="keyword">struct</span> &#123;</span><br><span class="line">TaskID   <span class="type">int</span>       <span class="comment">//任务ID</span></span><br><span class="line">TaskType TaskType  <span class="comment">//任务类型</span></span><br><span class="line">Filename <span class="type">string</span>    <span class="comment">//文件名(Map任务)</span></span><br><span class="line">MMap     <span class="type">int</span>       <span class="comment">//map任务数量</span></span><br><span class="line">NReduce  <span class="type">int</span>       <span class="comment">//reduce任务数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AskTask</span></span><br><span class="line"><span class="keyword">type</span> TaskDoneArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">TaskID   <span class="type">int</span>      <span class="comment">//任务ID</span></span><br><span class="line">TaskType TaskType <span class="comment">//任务类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TaskDoneReply <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//似乎不用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cook up a unique-ish UNIX-domain socket name</span></span><br><span class="line"><span class="comment">// in /var/tmp, for the coordinator.</span></span><br><span class="line"><span class="comment">// Can&#x27;t use the current directory since</span></span><br><span class="line"><span class="comment">// Athena AFS doesn&#x27;t support UNIX-domain sockets.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coordinatorSock</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">s := <span class="string">&quot;/var/tmp/824-mr-&quot;</span></span><br><span class="line">s += strconv.Itoa(os.Getuid())</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>技巧：可以单独写一个testx-mr.sh进行独立测试，如仅测试crash：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># map-reduce tests</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># comment this out to run the tests without the Go race detector.</span></span><br><span class="line">RACE=-race</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$OSTYPE</span>&quot;</span> = <span class="string">&quot;darwin&quot;</span>* ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> go version | grep <span class="string">&#x27;go1.17.[012345]&#x27;</span></span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># -race with plug-ins on x86 MacOS 12 with</span></span><br><span class="line">    <span class="comment"># go1.17 before 1.17.6 sometimes crash.</span></span><br><span class="line">    RACE=</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;*** Turning off -race since it may not work on a Mac&#x27;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;    with &#x27;</span> `go version`</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">TIMEOUT=<span class="built_in">timeout</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">timeout</span> 2s <span class="built_in">sleep</span> 1 &gt; /dev/null 2&gt;&amp;1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  :</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> gtimeout 2s <span class="built_in">sleep</span> 1 &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    TIMEOUT=gtimeout</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment"># no timeout command</span></span><br><span class="line">    TIMEOUT=</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;*** Cannot find timeout command; proceeding without timeouts.&#x27;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$TIMEOUT</span>&quot;</span> != <span class="string">&quot;&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  TIMEOUT+=<span class="string">&quot; -k 2s 180s &quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># run the test in a fresh sub-directory.</span></span><br><span class="line"><span class="built_in">rm</span> -rf mr-tmp</span><br><span class="line"><span class="built_in">mkdir</span> mr-tmp || <span class="built_in">exit</span> 1</span><br><span class="line"><span class="built_in">cd</span> mr-tmp || <span class="built_in">exit</span> 1</span><br><span class="line"><span class="built_in">rm</span> -f mr-*</span><br><span class="line"></span><br><span class="line"><span class="comment"># make sure software is freshly built.</span></span><br><span class="line">(<span class="built_in">cd</span> ../../mrapps &amp;&amp; go clean)</span><br><span class="line">(<span class="built_in">cd</span> .. &amp;&amp; go clean)</span><br><span class="line">(<span class="built_in">cd</span> ../../mrapps &amp;&amp; go build <span class="variable">$RACE</span> -buildmode=plugin wc.go) || <span class="built_in">exit</span> 1</span><br><span class="line">(<span class="built_in">cd</span> ../../mrapps &amp;&amp; go build <span class="variable">$RACE</span> -buildmode=plugin indexer.go) || <span class="built_in">exit</span> 1</span><br><span class="line">(<span class="built_in">cd</span> ../../mrapps &amp;&amp; go build <span class="variable">$RACE</span> -buildmode=plugin mtiming.go) || <span class="built_in">exit</span> 1</span><br><span class="line">(<span class="built_in">cd</span> ../../mrapps &amp;&amp; go build <span class="variable">$RACE</span> -buildmode=plugin rtiming.go) || <span class="built_in">exit</span> 1</span><br><span class="line">(<span class="built_in">cd</span> ../../mrapps &amp;&amp; go build <span class="variable">$RACE</span> -buildmode=plugin jobcount.go) || <span class="built_in">exit</span> 1</span><br><span class="line">(<span class="built_in">cd</span> ../../mrapps &amp;&amp; go build <span class="variable">$RACE</span> -buildmode=plugin early_exit.go) || <span class="built_in">exit</span> 1</span><br><span class="line">(<span class="built_in">cd</span> ../../mrapps &amp;&amp; go build <span class="variable">$RACE</span> -buildmode=plugin crash.go) || <span class="built_in">exit</span> 1</span><br><span class="line">(<span class="built_in">cd</span> ../../mrapps &amp;&amp; go build <span class="variable">$RACE</span> -buildmode=plugin nocrash.go) || <span class="built_in">exit</span> 1</span><br><span class="line">(<span class="built_in">cd</span> .. &amp;&amp; go build <span class="variable">$RACE</span> mrcoordinator.go) || <span class="built_in">exit</span> 1</span><br><span class="line">(<span class="built_in">cd</span> .. &amp;&amp; go build <span class="variable">$RACE</span> mrworker.go) || <span class="built_in">exit</span> 1</span><br><span class="line">(<span class="built_in">cd</span> .. &amp;&amp; go build <span class="variable">$RACE</span> mrsequential.go) || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line">failed_any=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#########################################################</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;***&#x27;</span> Starting crash <span class="built_in">test</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate the correct output</span></span><br><span class="line">../mrsequential ../../mrapps/nocrash.so ../pg*txt || <span class="built_in">exit</span> 1</span><br><span class="line"><span class="built_in">sort</span> mr-out-0 &gt; mr-correct-crash.txt</span><br><span class="line"><span class="built_in">rm</span> -f mr-out*</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -f mr-done</span><br><span class="line">(<span class="variable">$TIMEOUT</span> ../mrcoordinator ../pg*txt ; <span class="built_in">touch</span> mr-done ) &amp;</span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># start multiple workers</span></span><br><span class="line"><span class="variable">$TIMEOUT</span> ../mrworker ../../mrapps/crash.so &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># mimic rpc.go&#x27;s coordinatorSock()</span></span><br><span class="line">SOCKNAME=/var/tmp/824-mr-`<span class="built_in">id</span> -u`</span><br><span class="line"></span><br><span class="line">( <span class="keyword">while</span> [ -e <span class="variable">$SOCKNAME</span> -a ! -f mr-done ]</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="variable">$TIMEOUT</span> ../mrworker ../../mrapps/crash.so</span><br><span class="line">    <span class="built_in">sleep</span> 1</span><br><span class="line">  <span class="keyword">done</span> ) &amp;</span><br><span class="line"></span><br><span class="line">( <span class="keyword">while</span> [ -e <span class="variable">$SOCKNAME</span> -a ! -f mr-done ]</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="variable">$TIMEOUT</span> ../mrworker ../../mrapps/crash.so</span><br><span class="line">    <span class="built_in">sleep</span> 1</span><br><span class="line">  <span class="keyword">done</span> ) &amp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ -e <span class="variable">$SOCKNAME</span> -a ! -f mr-done ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="variable">$TIMEOUT</span> ../mrworker ../../mrapps/crash.so</span><br><span class="line">  <span class="built_in">sleep</span> 1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> <span class="variable">$SOCKNAME</span></span><br><span class="line"><span class="built_in">sort</span> mr-out* | grep . &gt; mr-crash-all</span><br><span class="line"><span class="keyword">if</span> cmp mr-crash-all mr-correct-crash.txt</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;---&#x27;</span> crash <span class="built_in">test</span>: PASS</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;---&#x27;</span> crash output is not the same as mr-correct-crash.txt</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;---&#x27;</span> crash <span class="built_in">test</span>: FAIL</span><br><span class="line">  failed_any=1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行<code>bash ./test-mr.sh</code>,发现early_exit和crash测试是失败的</p><blockquote><p>early_exit测试：其实是测试有没有worker&#x2F;coordinator提前退出了，一般coordinator不会提前退出，我原本的实现中，并未设置KEEPWAITING任务，导致在<code>所有任务已被分配，但还有任务在执行中</code>这种情况下，worker没有收到任务，直接退出了，导致测试失败。实验要求当所有任务完成后，worker&#x2F;coordinator才能退出。</p></blockquote><blockquote><p>crash测试：随机让部分worker在执行<code>map/reduce</code>的时候宕机(os.Exit或超时(time.Sleep)来测试你的程序是否有恢复机制。我后来是使用了<code>checkTasks</code>函数，定期检查任务状态，通过对比当前时间和任务开始时间，如果发现状态为<code>DOING</code>的任务的开始时间&lt;当前时间-10s，则认为负责这个任务的workder超时了，于是重新将任务的状态改为<code>WAITING</code>,等待其他worker请求任务时，再重新分配。（这么做感觉是有点naive，如果那个宕机的worker又活过来了，则又执行了一遍map&#x2F;reduce过程，这其实是没必要的）</p></blockquote><p>断断续续写了一个月，加起来差不多4天理解论文和整理思路，code+debug三天，其他时间都在摸鱼☺。（GoLand一个月试用期刚好到期乐）<br><img src="/../../../../img/Pasted%20image%2020231028131811.png"><br><img src="/../../../../img/Pasted%20image%2020231028203508.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>踩坑记录：Ubuntu指令$ cat mr-out-* | sort | more会忽略大小写进行排序，导致程序输出结果和正确的结果不一致，测试失败。(不过后来发现这个不会导致测试失败，因为测试程序会再次对mr-out-x文件调用sort，使得期望结果和你程序的输出结果都按同一规则排序)</li><li>踩坑记录：在执行中的任务不能被再次分配给其他worker，不然会导致并发访问。后来多加了一个<code>DOING</code>状态表示任务正在执行中</li><li>本实验并没有用天生并发安全的<code>chan</code>实现，而是通过锁机制控制并发访问，一定要避免死锁和数据竞争。使用<code>go run -race</code>检测</li><li>由于初学go，部分锁使用的时机可能不正确，导致性能低。（为了省事，从函数开始锁到函数结束）</li><li>本实现代码只保证能通过所有测试，但可能并不完善且由于刚学<code>go</code>代码写的不够简洁，部分异常没有处理（如RPC调用失败等）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 微服务和分布式 </category>
          
          <category> 6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java八股文</title>
      <link href="/posts/7b3d68/"/>
      <url>/posts/7b3d68/</url>
      
        <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>主要分为三种：List、Set、Map</p><p>Map：数组+链表+红黑树<br>链表转红黑树：64 和 8<br>红黑树转链表：6</p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h1 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h1><h1 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a>JVM虚拟机</h1><p>Java内存管理管理的是<strong>堆</strong>内存中对象的分配和回收。GC堆。</p><p>死亡对象判断方法</p><ul><li>引用计数法：难以解决循环引用的问题。</li><li>可达性分析：从GC Roots搜索</li></ul><h2 id="垃圾收集算法："><a href="#垃圾收集算法：" class="headerlink" title="垃圾收集算法："></a>垃圾收集算法：</h2><ul><li>标记-清除算法</li><li>标记-复制算法</li><li>标记-整理算法</li><li>分代收集算法：（目前使用）新生代老年代，为各个年代选择合适的垃圾收集算法</li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息可视化大作业</title>
      <link href="/posts/e6e43c56/"/>
      <url>/posts/e6e43c56/</url>
      
        <content type="html"><![CDATA[<h2 id="hierarchy-data-children"><a href="#hierarchy-data-children" class="headerlink" title="hierarchy(data, children)"></a>hierarchy(<em>data</em>, <em>children</em>)</h2><p><a href="https://d3js.org/d3-hierarchy/hierarchy">Hierarchies | D3 by Observable (d3js.org)</a></p><p>分层数据</p><p>属性：<br>node.data - 传递给层次结构的相关数据<br>node.depth（节点深度）- 根节点的深度为 0，每一代子节点的深度增加 1<br>node.height（节点高度）- 与任何后代叶子的最大距离，叶子为 0<br>node.parent - 父节点，根节点为空<br>node.children–子节点数组（如果有），对于叶子则未定义<br>node.value - 节点及其子节点的可选加和值</p><p>方法：<br>node.ancestors()：返回祖节点数组，从本节点开始，依次返回父节点直至根节点。</p><p>node.descendants()：返回子节点数组，从本节点开始，然后按拓扑顺序依次返回每个子节点。</p><p>node.find(<em>filter</em>)：返回从该节点开始的层次结构中，指定的过滤器返回真值的第一个节点。如果没有找到这样的节点，则返回未定义的值。</p><p>node.path(target)：返回从该节点到指定目标节点的层次结构中的最短路径。路径从本节点开始，上升到本节点和目标节点的最小共同祖先，然后下降到目标节点。这对分层边缘捆绑非常有用。</p><p>node.links()：返回此节点及其子节点的链接数组，其中每个链接都是一个定义了源和目标属性的对象。每个链接的源是父节点，目标是子节点。</p><p>node.values()：在后序遍历中对该节点和每个子节点的指定值函数进行评估，并返回该节点。每个节点的 node.value 属性将被设置为指定函数返回的数值加上所有子节点的合并值。函数传递节点的数据，必须返回一个非负数。值访问器将对节点和每个子节点（包括内部节点）进行评估；如果只想让叶节点具有内部值，那么任何有子节点的值都将返回零。例如，作为 node.count：</p><p>node.count()：计算该节点下的叶子数，并将其赋值给 node.value，并对节点的每个子节点进行类似计算。如果此节点是叶子，则其计数为 1。返回此节点。另请参阅 node.sum。</p><p>node.sort(compare)：使用指定的比较函数，以预序遍历的方式对该节点的子节点（如果有）和该节点的每个子节点进行排序，并返回该节点。</p><h2 id="模块：环形树状结构"><a href="#模块：环形树状结构" class="headerlink" title="模块：环形树状结构"></a>模块：环形树状结构</h2><h3 id="可视化背景"><a href="#可视化背景" class="headerlink" title="可视化背景"></a>可视化背景</h3><p>圆环图（或称为环形图）是一种可视化方法，用于展示层次结构或组成关系。在圆环图中，数据或信息通过圆环的分区来呈现，每个分区代表一个层次或一个部分。通常，内部圆环代表整体，外部圆环则显示组成部分或层次。</p><p>然而，为了将<code>圆环图</code>和<code>边聚合图</code>结合，并且考虑到本项目中需要展示的依赖关系是<strong>叶子节点</strong>和<strong>叶子节点</strong>之间的，因此需要对圆环图进行一定的改造。更具体地：1）需要将叶子节点排列在圆环内部，从内向外，分别是子节点-父节点。2）考虑到叶节点的深度各不相同，需要齐次化层次结构，实现对齐设计。</p><h3 id="实现的功能"><a href="#实现的功能" class="headerlink" title="实现的功能"></a>实现的功能</h3><h4 id="扇形嵌套-树状结构"><a href="#扇形嵌套-树状结构" class="headerlink" title="扇形嵌套-树状结构"></a>扇形嵌套-树状结构</h4><p><img src="/../../img/Pasted%20image%2020231221122549.png"><br>整个圆环图采用<code>扇形嵌套树状结构</code>，将树状结构以扇形的方式呈现，其中树的各个层次通过扇形的半径表示，并且子节点相对于父节点呈现在更内层。这种结构有几个优点：</p><ol><li><strong>层次性展示：</strong> 扇形嵌套树状结构非常适合呈现层次性数据，因为它清晰地显示了树的各个层次。每个节点的深度可以通过在扇形中的位置和半径来表示，使得观察者能够直观地了解数据的层次结构。  </li><li><strong>节省空间：</strong> 相较于传统的直线式树状结构，扇形嵌套可以更有效地利用空间。节点内部相对较小，使得在较小的可视化区域内展示更多的信息，这对于较大的树状结构尤其有用。</li><li><strong>凸显层次关系：</strong> 通过节点的位置和大小差异，扇形嵌套树状结构突出了不同层次之间的关系。父节点在扇形的外侧，子节点则朝向内部排列，强调了层次间的分离和连接。</li></ol><h4 id="倒序布局"><a href="#倒序布局" class="headerlink" title="倒序布局"></a>倒序布局</h4><p>由于需要呈现叶子节点和叶子节点之间的相互依赖关系，则不同于传统的圆环图布局（图），根节点在最内侧，向外依次排列子节点的形式。</p><p><img src="/../../img/Pasted%20image%2020231221123335.png"><br>本项目需要让子节点放置在最内侧，并以<code>边聚合图</code>的形式在中心呈现叶子节点的依赖关系。因此采用倒序布局，圆环的自内向外分别是子节点-父节点。<br><img src="/../../img/Pasted%20image%2020231221124528.png"></p><h4 id="虚拟节点设计"><a href="#虚拟节点设计" class="headerlink" title="虚拟节点设计"></a>虚拟节点设计</h4><p>为了解决<code>倒序布局</code>下，叶子节点的深度不一致导致层次关系错乱无法对齐的问题（如图）。对于叶子节点<code>关联类</code>它的深度为2，而对于叶子节点<code>功能模型</code>它的深度为1，而其余叶子节点的深度都为3，那么如果让所有叶子节点都显示在内圈，则他们外层的父节点无法对齐。因为对于叶子节点<code>功能模型</code>它的父节点是树的根节点，与其他叶子节点的父节点都不在同一层次上。<br><img src="/../../img/Pasted%20image%2020231221125422.png"><br>会导致如下的显示异常&#x2F;错乱的情况，特别是当对圆弧进行<code>Zoom in/out</code>变换时<br><img src="/../../img/Pasted%20image%2020231221125309.png"><br><img src="/../../img/Pasted%20image%2020231221125649.png"></p><p>为解决上述问题，我们引入了“虚拟节点”的概念以及节点“厚度”的概念。<br>虚拟节点：对于所有$depth&lt;maxDepth$的叶子节点我们为其添加$maxDepth-depth$个虚拟节点，如上图中红色节点所示。如此引入虚拟节点后，将所有节点的层次进行了对齐。</p><p>厚度：对于所有$depth&lt;maxDepth$的叶子节点我们设置其厚度为$maxDepth-depth+1$，那么在渲染圆弧的时候，他们所对应的圆弧高度和其厚度成正比。例如对于上述叶子节点<code>功能模型</code>，它的$depth&#x3D;1,而maxDepth&#x3D;3,因此它的厚度为3$。其对应的圆弧应占据三层的宽度（即涵盖了它的虚拟节点所占圆弧的宽度）。</p><p>通过引入“厚度”的设计，实际上避免了引入“虚拟节点”的物理实体。在原来的数据结构中，所有的虚拟节点都用厚度来代替了，避免引入冗余的节点。同时简化了<code>Zoom in/out</code>的实现。<br>更具体的<code>Zoom in/out</code>仅修改节点的<code>height</code>和<code>thickness</code>属性。</p><ul><li>Zoom in：指着聚焦于图表的局部，使该局部更大并填满整个视图，以便更详细地查看该部分的内容。</li><li>Zoom out：意味着减小局部区域的尺寸，使整个图表在视图中呈现更广阔的范围。</li></ul><h4 id="显示效果优化"><a href="#显示效果优化" class="headerlink" title="显示效果优化"></a>显示效果优化</h4><p>为了更好呈现可视化效果，做了如下优化：</p><ul><li>自适应横向&#x2F;纵向标签：计算节点所在圆弧的宽度和高度，对标签进行自适应的横向或纵向显示。如宽度足够，则进行横向显示；如高度足够，则进行纵向显示；如都不够，则隐藏标签。</li><li>添加鼠标移入事件：当鼠标移入节点时，显示节点的层次信息和其子节点数量。</li><li>当节点数量过多则隐藏节点名称</li><li>鼠标移入高亮效果</li></ul><p><img src="/../../img/Pasted%20image%2020231221125056.png"></p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="数据处理部分"><a href="#数据处理部分" class="headerlink" title="数据处理部分"></a>数据处理部分</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层次化数据</span></span><br><span class="line">data = d3.<span class="title function_">hierarchy</span>(data)  </span><br><span class="line">    .<span class="title function_">sum</span>(<span class="function"><span class="params">d</span> =&gt;</span> d.<span class="property">children</span> ? <span class="number">0</span> : <span class="number">1</span>)  </span><br><span class="line">    .<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="number">1</span>);  </span><br><span class="line"><span class="comment">// 定义svg的宽度</span></span><br><span class="line"><span class="keyword">const</span> width = <span class="number">1200</span>;  </span><br><span class="line"><span class="keyword">const</span> level = <span class="number">6</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义单位半径 = 半径/level</span></span><br><span class="line"><span class="keyword">const</span> radius = width / (<span class="number">2</span> * level);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义颜色生成器</span></span><br><span class="line"><span class="keyword">const</span> color = d3.<span class="title function_">scaleOrdinal</span>(d3.<span class="title function_">quantize</span>(d3.<span class="property">interpolateRainbow</span>, data.<span class="property">children</span>.<span class="property">length</span> + <span class="number">1</span>));  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理节点数据</span></span><br><span class="line"><span class="keyword">const</span> tree = d3.<span class="title function_">cluster</span>()  </span><br><span class="line">    .<span class="title function_">size</span>([<span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, radius * <span class="number">2</span> * level / <span class="number">3</span>]);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> root = <span class="title function_">tree</span>(<span class="title function_">bilink</span>(data  </span><br><span class="line">    .<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> d3.<span class="title function_">ascending</span>(a.<span class="property">height</span>, b.<span class="property">height</span>) || d3.<span class="title function_">ascending</span>(a.<span class="property">data</span>.<span class="property">className</span>, b.<span class="property">data</span>.<span class="property">className</span>))));  </span><br><span class="line"></span><br><span class="line">root = d3.<span class="title function_">partition</span>()  </span><br><span class="line">    .<span class="title function_">size</span>([<span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, root.<span class="property">height</span> + <span class="number">1</span>])  </span><br><span class="line">    (root);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 为节点添加并初始化属性</span></span><br><span class="line"><span class="keyword">const</span> maxDepth = root.<span class="property">height</span>;  </span><br><span class="line">root.<span class="title function_">each</span>(<span class="function"><span class="params">d</span> =&gt;</span> d.<span class="property">thickness</span> = d.<span class="property">children</span> ? <span class="number">1</span> : maxDepth - d.<span class="property">depth</span> + <span class="number">1</span>);  </span><br><span class="line">root.<span class="title function_">each</span>(<span class="function"><span class="params">d</span> =&gt;</span> d.<span class="property">current</span> = d);  </span><br><span class="line">root.<span class="title function_">each</span>(<span class="function"><span class="params">d</span> =&gt;</span> d.<span class="property">index</span> = <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="创建圆弧"><a href="#创建圆弧" class="headerlink" title="创建圆弧"></a>创建圆弧</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义圆弧生成器  </span></span><br><span class="line"><span class="keyword">const</span> arc = d3.<span class="title function_">arc</span>()  </span><br><span class="line">    .<span class="title function_">startAngle</span>(<span class="function"><span class="params">d</span> =&gt;</span> d.<span class="property">x0</span>)  </span><br><span class="line">    .<span class="title function_">endAngle</span>(<span class="function"><span class="params">d</span> =&gt;</span> d.<span class="property">x1</span>)  </span><br><span class="line">    .<span class="title function_">padAngle</span>(<span class="function"><span class="params">d</span> =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">min</span>((d.<span class="property">x1</span> - d.<span class="property">x0</span>) / <span class="number">2</span>, <span class="number">0.005</span>))  </span><br><span class="line">    .<span class="title function_">padRadius</span>(radius * <span class="number">1.5</span>)  </span><br><span class="line">    .<span class="title function_">innerRadius</span>(<span class="function"><span class="params">d</span> =&gt;</span> &#123;  </span><br><span class="line">      <span class="keyword">var</span> innerRadius = (d.<span class="property">height</span> + <span class="number">2</span> * level / <span class="number">3</span>) * radius - <span class="number">1</span>;  </span><br><span class="line">      <span class="keyword">return</span> innerRadius - <span class="number">1</span>;  </span><br><span class="line">    &#125;)  </span><br><span class="line">    .<span class="title function_">outerRadius</span>(<span class="function"><span class="params">d</span> =&gt;</span> &#123;  </span><br><span class="line">      <span class="keyword">var</span> outerRadius = (d.<span class="property">height</span> + <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">2</span>, d.<span class="property">thickness</span>) + <span class="number">2</span> * level / <span class="number">3</span>) * radius;  </span><br><span class="line">      <span class="keyword">return</span> outerRadius;  </span><br><span class="line">    &#125;);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 定义图层svg,并绑定在id=&quot;d3ChartRight&quot;的元素容器上</span></span><br><span class="line"><span class="keyword">const</span> svg = d3.<span class="title function_">select</span>(<span class="string">&quot;#d3ChartRight&quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;svg&quot;</span>)  </span><br><span class="line">    .<span class="title function_">attr</span>(<span class="string">&quot;width&quot;</span>, width)  </span><br><span class="line">    .<span class="title function_">attr</span>(<span class="string">&quot;height&quot;</span>, width)  </span><br><span class="line">    .<span class="title function_">attr</span>(<span class="string">&quot;viewBox&quot;</span>, [-width / <span class="number">2</span>, -width / <span class="number">2</span>, width, width])  </span><br><span class="line">    .<span class="title function_">attr</span>(<span class="string">&quot;style&quot;</span>, <span class="string">&quot;max-width: 100%; height: auto; font: 10px sans-serif; margin: 0 auto; display: block;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制圆弧</span></span><br><span class="line"><span class="keyword">const</span> path = svg.<span class="title function_">append</span>(<span class="string">&quot;g&quot;</span>)  </span><br><span class="line">    .<span class="title function_">selectAll</span>(<span class="string">&quot;path&quot;</span>)  </span><br><span class="line">    .<span class="title function_">data</span>(root.<span class="title function_">descendants</span>().<span class="title function_">slice</span>(<span class="number">0</span>))  </span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">&quot;path&quot;</span>)  </span><br><span class="line">    .<span class="title function_">attr</span>(<span class="string">&quot;fill&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> &#123;  </span><br><span class="line">      <span class="keyword">while</span> (d.<span class="property">depth</span> &gt; <span class="number">1</span>) d = d.<span class="property">parent</span>;  </span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">color</span>(d.<span class="property">data</span>.<span class="property">displayName</span>||d.<span class="property">data</span>.<span class="property">name</span>);  </span><br><span class="line">    &#125;)  </span><br><span class="line">    .<span class="title function_">attr</span>(<span class="string">&quot;fill-opacity&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> <span class="title function_">arcVisible</span>(d.<span class="property">current</span>) ? (d.<span class="property">children</span> ? <span class="number">0.6</span> : <span class="number">0.4</span>) : <span class="number">0</span>)  </span><br><span class="line">    .<span class="title function_">attr</span>(<span class="string">&quot;pointer-events&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> <span class="title function_">arcVisible</span>(d.<span class="property">current</span>) ? <span class="string">&quot;auto&quot;</span> : <span class="string">&quot;none&quot;</span>)  </span><br><span class="line">    .<span class="title function_">attr</span>(<span class="string">&quot;d&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> <span class="title function_">arc</span>(d.<span class="property">current</span>));</span><br></pre></td></tr></table></figure><p>仅显示最内两层圆弧</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arcVisible</span>(<span class="params">d</span>) &#123;  </span><br><span class="line">  <span class="keyword">return</span> d.<span class="property">height</span> &lt;= <span class="number">1</span> &amp;&amp; d.<span class="property">height</span> &gt;= <span class="number">0</span> &amp;&amp; d.<span class="property">x1</span> &gt; d.<span class="property">x0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义标签格式  </span></span><br><span class="line"><span class="keyword">const</span> format = d3.<span class="title function_">format</span>(<span class="string">&quot;,d&quot;</span>);  </span><br><span class="line">path.<span class="title function_">append</span>(<span class="string">&quot;title&quot;</span>)  </span><br><span class="line">    .<span class="title function_">text</span>(<span class="function"><span class="params">d</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;d.ancestors().map(d =&gt; d.data.displayName||d.data.name).reverse().join(<span class="string">&quot;/&quot;</span>)&#125;</span>\n<span class="subst">$&#123;format(d.descendants().length)&#125;</span>`</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line"><span class="keyword">const</span> label = svg.<span class="title function_">append</span>(<span class="string">&quot;g&quot;</span>)  </span><br><span class="line">    .<span class="title function_">attr</span>(<span class="string">&quot;pointer-events&quot;</span>, <span class="string">&quot;none&quot;</span>)  </span><br><span class="line">    .<span class="title function_">attr</span>(<span class="string">&quot;text-anchor&quot;</span>, <span class="string">&quot;middle&quot;</span>)  </span><br><span class="line">    .<span class="title function_">style</span>(<span class="string">&quot;user-select&quot;</span>, <span class="string">&quot;none&quot;</span>)  </span><br><span class="line">    .<span class="title function_">selectAll</span>(<span class="string">&quot;text&quot;</span>)  </span><br><span class="line">    .<span class="title function_">data</span>(root.<span class="title function_">descendants</span>().<span class="title function_">slice</span>(<span class="number">0</span>))  </span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">&quot;text&quot;</span>)  </span><br><span class="line">    .<span class="title function_">attr</span>(<span class="string">&quot;dy&quot;</span>, <span class="string">&quot;0.35em&quot;</span>)  </span><br><span class="line">    .<span class="title function_">attr</span>(<span class="string">&quot;fill-opacity&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> +<span class="title function_">labelVisible</span>(d.<span class="property">current</span>))  </span><br><span class="line">    .<span class="title function_">attr</span>(<span class="string">&quot;transform&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> <span class="title function_">labelTransform</span>(d.<span class="property">current</span>))  </span><br><span class="line">    .<span class="title function_">text</span>(<span class="function"><span class="params">d</span> =&gt;</span> d.<span class="property">data</span>.<span class="property">displayName</span>||d.<span class="property">data</span>.<span class="property">name</span>)  </span><br><span class="line">    .<span class="title function_">style</span>(<span class="string">&quot;font-size&quot;</span>, <span class="string">&quot;12px&quot;</span>); <span class="comment">// 设置字体大小为 12 像素（根据需要调整大小）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当圆弧狭小时，隐藏标签</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">labelVisible</span>(<span class="params">d</span>) &#123;  </span><br><span class="line">  <span class="keyword">return</span> d.<span class="property">height</span> &lt;= <span class="number">1</span> &amp;&amp; d.<span class="property">height</span> &gt;= <span class="number">0</span> &amp;&amp; (d.<span class="property">y1</span> - d.<span class="property">y0</span>) * (d.<span class="property">x1</span> - d.<span class="property">x0</span>) &gt; <span class="number">0.03</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 定义标签显示方式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">labelTransform</span>(<span class="params">d</span>) &#123;  </span><br><span class="line">  <span class="keyword">const</span> x = (d.<span class="property">x0</span> + d.<span class="property">x1</span>) / <span class="number">2</span> * <span class="number">180</span> / <span class="title class_">Math</span>.<span class="property">PI</span>;  </span><br><span class="line">  <span class="keyword">const</span> y = ((d.<span class="property">height</span> + <span class="number">0.5</span> + <span class="number">2</span> * level / <span class="number">3</span>) * radius);  </span><br><span class="line">  <span class="keyword">return</span> <span class="string">`rotate(<span class="subst">$&#123;x - <span class="number">90</span>&#125;</span>) translate(<span class="subst">$&#123;y&#125;</span>,0) rotate(<span class="subst">$&#123;<span class="number">90</span>&#125;</span>)`</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现Zoom-in-out"><a href="#实现Zoom-in-out" class="headerlink" title="实现Zoom in&#x2F;out"></a>实现Zoom in&#x2F;out</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle zoom on click.  </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clicked</span>(<span class="params">event, p</span>) &#123;  </span><br><span class="line">  <span class="keyword">if</span>(transforming) <span class="keyword">return</span>;  </span><br><span class="line">  transforming = <span class="literal">true</span>;  </span><br><span class="line">  root.<span class="title function_">each</span>(<span class="function"><span class="params">d</span> =&gt;</span> &#123;  </span><br><span class="line">    <span class="keyword">let</span> height = d.<span class="property">current</span>.<span class="property">height</span>;  </span><br><span class="line">    <span class="keyword">let</span> thickness = d.<span class="property">current</span>.<span class="property">thickness</span>;  </span><br><span class="line">    <span class="comment">// Zoom out  </span></span><br><span class="line">    <span class="keyword">if</span> (p.<span class="property">parent</span> == <span class="literal">null</span>) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (d.<span class="property">index</span> &lt;= <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">      height = d.<span class="property">originalHeight</span>[d.<span class="property">index</span> - <span class="number">1</span>]  </span><br><span class="line">      thickness = d.<span class="property">originalThickness</span>[d.<span class="property">index</span> - <span class="number">1</span>]  </span><br><span class="line">      d.<span class="property">index</span> -= <span class="number">1</span>  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">      <span class="comment">// Zoom in </span></span><br><span class="line">      <span class="keyword">if</span> (!(<span class="string">&quot;originalHeight&quot;</span> <span class="keyword">in</span> d)) d.<span class="property">originalHeight</span> = [];  </span><br><span class="line">      <span class="keyword">if</span> (!(<span class="string">&quot;originalThickness&quot;</span> <span class="keyword">in</span> d)) d.<span class="property">originalThickness</span> = [];  </span><br><span class="line">      <span class="keyword">if</span> (d.<span class="property">index</span> &gt;= d.<span class="property">originalHeight</span>.<span class="property">length</span>) &#123;  </span><br><span class="line">        d.<span class="property">originalHeight</span>.<span class="title function_">push</span>(d.<span class="property">current</span>.<span class="property">height</span>);  </span><br><span class="line">        d.<span class="property">originalThickness</span>.<span class="title function_">push</span>(d.<span class="property">current</span>.<span class="property">thickness</span>);  </span><br><span class="line">      &#125;  </span><br><span class="line">      d.<span class="property">index</span> += <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">      <span class="keyword">let</span> diff = p.<span class="property">current</span>.<span class="property">height</span>;  </span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span>;  </span><br><span class="line">      <span class="comment">// 如果当前数据仍有子节点  </span></span><br><span class="line">      <span class="keyword">if</span> (d.<span class="property">children</span>) &#123;  </span><br><span class="line">        <span class="comment">// 遍历该节点的所有后代  </span></span><br><span class="line">        d.<span class="title function_">descendants</span>().<span class="title function_">forEach</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;  </span><br><span class="line">          <span class="keyword">if</span> (c.<span class="property">current</span>.<span class="property">thickness</span> &gt; <span class="number">1</span>) &#123;  </span><br><span class="line">            count += <span class="number">1</span>  </span><br><span class="line">          &#125;  </span><br><span class="line">        &#125;)  </span><br><span class="line">        <span class="keyword">if</span> (count != d.<span class="title function_">leaves</span>().<span class="property">length</span>) &#123;  </span><br><span class="line">          <span class="keyword">while</span> (diff &gt; <span class="number">0</span> &amp;&amp; thickness &gt; <span class="number">1</span>) &#123;  </span><br><span class="line">            thickness -= <span class="number">1</span>  </span><br><span class="line">            diff -= <span class="number">1</span>  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">while</span> (diff &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            height -= <span class="number">1</span>  </span><br><span class="line">            diff -= <span class="number">1</span>  </span><br><span class="line">          &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">while</span> (diff &gt; <span class="number">0</span> &amp;&amp; thickness &gt; <span class="number">1</span>) &#123;  </span><br><span class="line">          thickness -= <span class="number">1</span>  </span><br><span class="line">          diff -= <span class="number">1</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">while</span> (diff &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">          height -= <span class="number">1</span>  </span><br><span class="line">          diff -= <span class="number">1</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> d.<span class="property">target</span> = &#123;   </span><br><span class="line">      <span class="attr">x1</span>: d.<span class="property">x1</span>,  </span><br><span class="line">      <span class="attr">y0</span>: d.<span class="property">y0</span>,  </span><br><span class="line">      <span class="attr">y1</span>: d.<span class="property">y1</span>,  </span><br><span class="line">      <span class="attr">height</span>: height,  </span><br><span class="line">      <span class="attr">thickness</span>: thickness,  </span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125;)  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> t = svg.<span class="title function_">transition</span>().<span class="title function_">duration</span>(<span class="number">750</span>);  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Transition the data on all arcs, even the ones that aren’t visible,  </span></span><br><span class="line">  <span class="comment">// so that if this transition is interrupted, entering arcs will start  // the next transition from the desired position.  path.transition(t)  </span></span><br><span class="line">      .<span class="title function_">tween</span>(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> &#123;  </span><br><span class="line">        <span class="keyword">const</span> i = d3.<span class="title function_">interpolate</span>(d.<span class="property">current</span>, d.<span class="property">target</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">t</span> =&gt;</span> d.<span class="property">current</span> = <span class="title function_">i</span>(t);  </span><br><span class="line">      &#125;)  </span><br><span class="line">      .<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">d</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> +<span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&quot;fill-opacity&quot;</span>) || <span class="title function_">arcVisible</span>(d.<span class="property">target</span>);  </span><br><span class="line">      &#125;)  </span><br><span class="line">      .<span class="title function_">attr</span>(<span class="string">&quot;fill-opacity&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> <span class="title function_">arcVisible</span>(d.<span class="property">target</span>) ? (d.<span class="property">children</span> ? <span class="number">0.6</span> : <span class="number">0.4</span>) : <span class="number">0</span>)  </span><br><span class="line">      .<span class="title function_">attr</span>(<span class="string">&quot;pointer-events&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> <span class="title function_">arcVisible</span>(d.<span class="property">target</span>) ? <span class="string">&quot;auto&quot;</span> : <span class="string">&quot;none&quot;</span>)  </span><br><span class="line">      .<span class="title function_">attrTween</span>(<span class="string">&quot;d&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> <span class="function">() =&gt;</span> <span class="title function_">arc</span>(d.<span class="property">current</span>));  </span><br><span class="line">  </span><br><span class="line">  label.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">d</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> +<span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&quot;fill-opacity&quot;</span>) || <span class="title function_">labelVisible</span>(d.<span class="property">target</span>);  </span><br><span class="line">  &#125;).<span class="title function_">transition</span>(t)  </span><br><span class="line">      .<span class="title function_">attr</span>(<span class="string">&quot;fill-opacity&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> +<span class="title function_">labelVisible</span>(d.<span class="property">target</span>))  </span><br><span class="line">      .<span class="title function_">attrTween</span>(<span class="string">&quot;transform&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> <span class="function">() =&gt;</span> <span class="title function_">labelTransform</span>(d.<span class="property">current</span>))  </span><br><span class="line">      .<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">()=&gt;</span> transforming = <span class="literal">false</span>);  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// regenerate line link  </span></span><br><span class="line">  <span class="keyword">let</span> leaves = []  </span><br><span class="line">  root.<span class="title function_">each</span>(<span class="keyword">function</span> (<span class="params">node</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">target</span>.<span class="property">height</span> === <span class="number">0</span>) &#123;  </span><br><span class="line">      leaves.<span class="title function_">push</span>(node);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;);  </span><br><span class="line">  <span class="title function_">updateLink</span>(leaves);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程 </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Triangulating Python Performance Issues with SCALENE</title>
      <link href="/posts/d28c2f4/"/>
      <url>/posts/d28c2f4/</url>
      
        <content type="html"><![CDATA[<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><ul><li>SCALENE精确且同时地分析CPU、内存和GPU的使用情况，所有这些都具有较低的开销。</li><li>指导编程人员优化代码</li></ul><h1 id="Introduce"><a href="#Introduce" class="headerlink" title="Introduce"></a>Introduce</h1>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端国际化改造</title>
      <link href="/posts/dad1aa62/"/>
      <url>/posts/dad1aa62/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h1 id="Template部分"><a href="#Template部分" class="headerlink" title="Template部分"></a>Template部分</h1><h1 id="JavaScript部分"><a href="#JavaScript部分" class="headerlink" title="JavaScript部分"></a>JavaScript部分</h1><p>data结构<br>node.key.name &#x3D;&#x3D; ‘data’<br>node.value是对其data节点的描述</p><p>继续递归node.value<br>发现他是一个FunctionExpression<br>有一个body属性，里面的blockStatement存放了对函数的描述<br>里面继续body属性，存放了VariableDeclaration、ReturnStatement<br>需要对这里面出现的所有中文字符国际化，并保留其路径</p><p>for 循环body.body<br><img src="/../../img/Pasted%20image%2020231207155028.png"></p><p>data的properties可能是<br>遇到‘ObjectExpression’说明是对象，那么先将它的key.name存到路径上，继续遍历它的properties属性<br>遇到‘ArrayExpression’说明是列表，遍历它的value.elements元素，加上索引存到路径上。<br>遇到‘Property’说明是属性，遍历它的value，<br>遇到‘Literal’说明是字面量，停止迭代，判断value是否包含中文，包含则修改为$t(‘path’)</p><p>遇到‘FunctionExpression’，遍历它的body</p><p>遇到‘VariableDeclaration’，访问它的declarations<br>    ‘遇到VariablDeclarator’,访问id和init,id存放了变量名，init.value存放了</p><p>traverse(node,path)</p><p>抽象语法树工具网站<br><a href="https://astexplorer.net/">AST explorer</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>领域特定语言论文汇报</title>
      <link href="/posts/29833d3b/"/>
      <url>/posts/29833d3b/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>现代软件系统正变得越来越复杂，依赖于大量的第三方库支持。因此，库行为是软件行为不可分割的一部分。分析它们和分析软件本身一样重要。<strong>然而，由于缺乏源代码、不同语言的实现以及复杂的优化，分析库具有很大的挑战性。</strong> 我们注意到，许多Java库函数都提供了出色的文档，这些文档简要地描述了函数的功能。我们开发了一种新的技术，可以通过分析文档来构建Java API函数的模型。与原始模型相比，这些模型在Java中的实现更简单，因此更易于分析。更重要的是，它们提供了与原始功能相同的功能。我们的技术成功地对14个广泛使用的Java类中的326个函数进行了建模。我们还将这些模型用于Android应用程序的静态污染分析和Java程序的动态切片，展示了我们模型的有效性和效率。</p><p>难点</p><ul><li>库源代码的隐蔽性&#x2F;多样性，导致难以对软件行为进行分析</li><li>源代码庞大，复杂，包含大量多层次的调用关系，导致分析困难</li><li>源代码包含大量优化和工程技巧，不利于对其行为分析（难以理解）</li><li>库具有跨平台支持</li></ul><p>本文提出了一种在自然语言中从Javadoc生成模型的新方法。这些模型是代码片段，具有与原始实现相同的功能，但复杂性要简单得多。它们可以在软件分析过程中替换原始库函数。<br>就是<strong>在软件分析中，使用通过JavaDoc生成的方法代替库函数，来简化分析</strong></p><p><img src="/../../img/Pasted%20image%2020231119150852.png"><br>一个很简单的ArrayList的add方法包括了三个函数调用，其中一个是使用JNI在本机代码中实现，无法直接访问。</p><p><img src="/../../img/Pasted%20image%2020231119154353.png"></p><p>总结<br>基于将自然语言处理技术和程序分析技术应用于模型库的思想，我们识别并克服了将NLP技术应用于真实代码生成的挑战，并构建了一个建模工具的原型，该工具可以从Javadocs中自动生成Java容器类库的简化代码。平均而言，生成的模型的大小只有原始代码库的三分之一。我们还应用我们的技术来帮助其他需要推理软件运行时环境的程序分析。结果表明，我们的模型可以帮助静态和动态分析。</p><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>构件</p><ul><li>Pre-processor：预处理器接受Javadoc解析器提取的描述，并执行三种分析。<ul><li>等价性分析：预处理器根据领域词典将单词分类到预定义的语义类中。减少IR的映射量。</li><li>冗余信息消除：删除描述中的同义句&#x2F;解释句。如“换言之，即”后面的句子。</li><li>句子增强：为javadoc中的句子做增强或填充。如填充return&#x2F;throw等关键词。</li></ul></li><li>文本分析引擎：文本分析引擎通过自然语言处理为每个预处理的句子生成语法树结构。<ul><li>添加POS词性限制组件，解决Stanford parser中的词性分类错误，强制它对一些编程特定的单词使用我们预定义的标签。</li><li>名词true&#x2F;false&#x2F;null</li><li>动词returns&#x2F;sets&#x2F;maps&#x2F;copies</li><li>形容词reverse&#x2F;next&#x2F;more&#x2F;empty</li></ul></li><li>树状转换器：树转换器转换Standford parser生成的原始树结构，以生成不同的变体。每个变体对应句子的不同解释。这些多个变体最终会被模型验证器验证，来过滤掉不正确的模型。<ul><li>不幸的是，即使k很大，解析器也无法保证为句子生成具有预期含义的树。为了避免这种情况（浪费大量的计算）提出了算法1，通过仅重新定位连接节点来转换来自斯坦福解析器的解析树，以产生一组变体。</li><li>算法1：lift up and push down产生不同的变体，直至没有新的变体产生。</li></ul></li><li>中间表示生成器（IR generator）：中间表示生成器根据编程领域知识，通过替换子树、识别参数和添加标签，操纵树转换器生成的树来构造IR。主要执行如下两个任务：<ul><li>参数识别：识别定义在方法描述中的参数，算法2</li><li>结构识别：识别方法描述中指示的程序结构。<ul><li>循环：添加<code>loop</code>标签</li><li>条件：if、when、otherwise</li></ul></li></ul></li><li>模型生成器（Model Generator）：基于IRs生成模型。基元</li><li>模型验证器（Model Validator）：由于自然语言的模糊性和当前NLP工具的限制，我们的方法可以生成多个候选模型。模型验证器用来过滤那些与原来库行为不一致的那些模型。使用<code>Randoop</code>方法生成测试。</li></ul><h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><p>评估的方面：</p><ul><li>模型生成技术的有效性。</li><li>在其他分析中使用生成的模型。</li></ul><h2 id="模型生成的有效性"><a href="#模型生成的有效性" class="headerlink" title="模型生成的有效性"></a>模型生成的有效性</h2><p><img src="/../../img/Pasted%20image%2020231120154943.png"></p><ul><li><code>#T</code>：原始JDK类的方法总数</li><li><code>#M</code>：工具可以成功建模的数量</li><li><code>%</code>：<code>#T</code>&#x2F;<code>#M</code></li><li><code>#C</code>：每个类候选模型的数量</li><li><code>GT</code>：生成类候选模型的总时间</li><li><code>VT</code>：使用Randoop验证类模型所用的时间</li><li><code>#CN</code>：使用Randoop生成测试用例的平均数量</li></ul><ol><li>代码行对比原始JDK减少1-13倍</li></ol><h2 id="静态污染分析"><a href="#静态污染分析" class="headerlink" title="静态污染分析"></a>静态污染分析</h2><p>我们首先使用原始JDK源代码运行分析，然后用我们的模型替换JDK的一部分，然后比较报告的信息泄漏警告的数量和性能。<br><img src="/../../img/Pasted%20image%2020231120160846.png"></p><h2 id="动态切片分析"><a href="#动态切片分析" class="headerlink" title="动态切片分析"></a>动态切片分析</h2><p><img src="/../../img/Pasted%20image%2020231120161200.png"></p><h1 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h1><ul><li><p>效果很大程度取决于文档的质量。</p></li><li><p>依赖基元模式，但来源于javadoc，不具有普适性。</p></li><li><p>聚焦于容器类库</p></li><li><p>测试用例不够充分，使用更严格的验证技术（等价性检查）</p></li><li><p>文档质量的强依赖性<br>文中基于自然语言的技术在很大程度上直接依赖于文档的质量。如果文档不完整，使用奇怪的语法或表述，工具可能无法生成正确的模型。其本质原因是许多基于自然语言处理的技术的一个普遍限制。技术依赖于一组语法模式来识别参数和基本操作。这些模式主要来自于 Javedocs。它们可能并不通用。然而，论文提到的技术在原则上是通用的，并且对于自动化模型生成是一项有价值的步骤，而这在一般情况下是一个难题。设想文档的写作风格可能不会像库的实现那样经常变化。因此，该技术可以作为一个自动化方法，快速为大量的库函数生成模型，正如结果所证明的那样。</p></li></ul><p>改进：文档规范化，强制执行固定的文档风格可能是一个有益的做法。</p><ul><li>工作集中于容器库<br>此外，我们当前的研究主要集中在类似容器的库上，因为它们是使用最广泛的类别。对于一些特殊用途的库，比如数学库，精确地对其功能进行建模非常困难。然而，在许多应用中，对这些库提供精确的模型并不是必需的。例如，大多数数学库函数的输入输出依赖关系非常简单，尽管它们所执行的计算可能非常复杂。<br>改进：</li></ul><ol><li><strong>更广泛的文档支持：</strong> 改进工具以支持更多类型的文档格式和语法，不仅限于特定格式或特定编程语言的注释格式。这样可以提高工具的适用性，并使其能够适应更多种类的文档和库。</li><li><strong>多种语言的支持：</strong> 扩展工具的能力，使其能够处理多种编程语言的文档和库，而不仅仅是特定语言或库的文档。这样可以使工具更具通用性和适用性。</li><li><strong>机器学习和自然语言处理技术的应用：</strong> 运用机器学习和自然语言处理技术，使工具能够更好地理解和解析文档，以提高模型生成的准确性和全面性。</li><li><strong>更精确的模型：</strong> 改进模型生成算法，使其能够更精确地对库函数的功能和行为进行建模，尽可能减少误差和不完整性，提高模型的质量和可靠性。</li></ol><ul><li>测试用例不够充分<br>文中用于模型验证的测试用例不够充分，以至于可能会接受一些错误的模型。<br>改进：</li></ul><ol><li><p><strong>增加测试用例的覆盖范围：</strong> 扩展现有测试套件，涵盖更多不同情况的测试用例，以更全面地验证模型的正确性。</p></li><li><p><strong>引入更多验证技术：</strong> 使用更严格的验证技术，例如形式化验证或符号执行等方法，来验证生成的模型是否满足预期的行为和性质。</p></li><li><p><strong>引入人工审查：</strong> 增加人工审查环节，专家审查生成的模型，提供反馈和修正。</p></li><li><p><strong>持续改进方法：</strong> 不断改进和优化使用的NLP技术和模型生成算法，以提高模型的准确性和适用性。</p></li></ol><p>个人研究方向：<br>低代码开发技术和相关平台以及代码生成在低代码平台中的应用<br>低代码开发技术是一种软件开发方法，旨在通过图形化界面和少量的编码来快速构建应用程序和软件解决方案。它允许开发人员使用可视化工具和拖放式界面来设计和配置应用程序的各个组件，从而减少了对传统编码的依赖。低代码平台提供了一个可视化的开发环境，使得开发人员能够更快速地构建应用程序，降低开发门槛，加快产品交付速度。<br>因此，代码生成在低代码平台中是不可或缺的一部分，它有助于将用户可视化的设计转换为实际的应用程序代码。这种代码生成可以基于用户的界面设计、业务逻辑和配置信息，自动生成底层的代码，从而加速应用程序的开发和部署过程。</p><p>结合自己方向的进一步工作<br>本篇论文提出了一种使用NLP技术来通过文档注释生成模型（代码）的方法来，来取代原始库中的方法或行为。该技术可运用在低代码平台中，如</p><ol><li><p><strong>自动生成文档和注释：</strong> 在低代码平台中，使用NLP 技术可用于自动生成代码文档和注释。通过分析代码结构、变量名和函数名等信息，NLP 可以生成清晰的文档和注释，帮助开发者更好地理解和使用代码。</p></li><li><p><strong>自动化代码解析和转换：</strong> NLP 技术可以解析代码并转换为更易读或更高级的抽象表示形式。这种转换可以使代码更加模块化、简洁，也可以帮助低代码平台用户更轻松地编辑和维护代码。</p></li><li><p><strong>智能建议和辅助功能：</strong> 基于 NLP 技术，低代码平台可以实现代码补全、自动修复和错误检测等智能功能。这些功能可以帮助用户更快速地完成代码编写，提高开发效率。</p></li><li><p><strong>代码生成和模板应用：</strong> NLP 技术可以用于分析用户输入或需求描述，并自动生成相应的代码模板或程序框架。这有助于用户通过简单的描述或指导来快速生成所需的代码结构。</p></li><li><p><strong>自然语言交互：</strong> 利用 NLP 技术，低代码平台可以实现自然语言交互功能，允许用户以自然语言形式与平台交互，描述其需求或功能，并自动生成相应的代码实现。</p></li></ol><p>因此，将 NLP 技术应用到低代码平台中可以带来智能化、自动化的代码生成和辅助功能，使得用户可以更快速、高效地开发应用程序，降低编码门槛和提升开发体验。</p><p>然而，在如今大语言模型的时代，使用NLP技术生成代码的方法显得有些过时。基于LLM从自然语言描述生成代码通常具有以下的优势：</p><ol><li><p><strong>上下文感知性：</strong> 大语言模型具有对上下文的深入理解能力，能够根据用户提供的问题或描述性文本更准确地生成代码。这种上下文感知性使得生成的代码更贴近用户的实际需求。</p></li><li><p><strong>多样化和灵活性：</strong> 大型语言模型可以生成多种可能的代码方案，提供更多样化、更灵活的选择。这样的灵活性使得生成的代码可以适应不同的场景和需求。</p></li><li><p><strong>语言表达能力：</strong> 大语言模型拥有更强大的语言表达能力，能够更好地理解和解释自然语言输入，并将其转化为可执行的代码。这有助于解决传统代码生成方法中的歧义和理解问题。</p></li><li><p><strong>自我训练和不断进化：</strong> 大型语言模型通常是通过大量的数据进行预训练，并具有自我学习和进化的能力。这意味着它们可以通过不断的训练和使用经验提升生成代码的质量和准确性。</p></li><li><p><strong>广泛应用和适应性：</strong> 大语言模型可以用于多种编程语言和领域，不局限于特定的编程语言或任务。这使得它们在不同领域的代码生成和自然语言交互中都具有较强的适应性。</p></li></ol><p>这些优势在一定程度上弥补了上述基于NLP生成代码的局限性，通常LLM代码生成更具有普适性而不局限于某个或某类库，并且由于其上下文感知性，克服了NLP方法的文档强依赖性。</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组会分享</title>
      <link href="/posts/874f9a62/"/>
      <url>/posts/874f9a62/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基于LangChain的开源项目"><a href="#1-基于LangChain的开源项目" class="headerlink" title="1.基于LangChain的开源项目"></a>1.基于LangChain的开源项目</h1><h2 id="低代码相关"><a href="#低代码相关" class="headerlink" title="低代码相关"></a>低代码相关</h2><table><thead><tr><th>名称</th><th>介绍</th><th>链接</th></tr></thead><tbody><tr><td><a href="https://github.com/logspace-ai/langflow">Langflow</a></td><td>LangChain设计的用户界面，使用react-flow设计，通过拖放组件和聊天框，可以轻松地进行实验和原型流程。</td><td></td></tr><tr><td><a href="https://github.com/FlowiseAI/Flowise">Flowise</a></td><td>Flowise是一个拖放用户界面,基于Langchain.js</td><td></td></tr><tr><td><a href="https://github.com/gmpetrov/databerry">Databerry</a></td><td>无代码平台,基于自定义数据源问答</td><td><a href="https://app.chaindesk.ai/logs?tab=unresolved">Dashboard | Chaindesk.</a></td></tr><tr><td><a href="https://github.com/homanp/langchain-ui">LangchainUI</a></td><td>停止维护了</td><td></td></tr><tr><td><a href="https://github.com/yeagerai/yeagerai-agent">Yeager.ai</a></td><td>Langchain Agent 创建工具，旨在帮助您轻松构建、原型开发和部署人工智能驱动的代理</td><td></td></tr><tr><td><a href="https://github.com/homanp/superagent">Superagent</a></td><td>Superagent 是一个开源代理框架，可让任何开发人员在几分钟内将可投入生产的人工智能助手集成到任何应用程序中。</td><td></td></tr><tr><td><a href="https://github.com/microsoft/autogen">Autogen</a></td><td>AutoGen 是一个框架，可以使用多个代理开发 LLM 应用程序，这些代理可以相互对话以解决任务。</td><td></td></tr></tbody></table><p>Databerry</p><blockquote><p>ChatGPT Agent Trained On Your Custom Data：根据您的自定义数据训练的 ChatGPT 代理</p></blockquote><p><img src="/../../img/image-20231108194944518.png"><br>优点：</p><ul><li>无需任何代码，基于数据源问答的机器人</li><li>支持丰富的数据源接入，原始文本、<strong>网页</strong>、文件</li></ul><p>缺点：</p><ul><li>功能比较单一，只有基于文档问答</li><li>大部分功能收费</li></ul><p>LangSmith</p><blockquote><p>LangSmith 是一个用于构建生产级 LLM 应用程序的平台。它可以让您调试、测试、评估和监控基于任何LLM框架构建的链和智能代理,并与LangChain无缝集成。目前正在开放测试，waitlist..</p></blockquote><h1 id="2-ChatDev"><a href="#2-ChatDev" class="headerlink" title="2.ChatDev"></a>2.ChatDev</h1><h2 id="Introduce"><a href="#Introduce" class="headerlink" title="Introduce"></a>Introduce</h2><p>2023年7月清华打造了一家虚拟软件公司。<br>ChatDev 是一家虚拟软件公司，通过不同的智能代理运营，这些代理担任不同的角色，包括首席执行官、首席产品官、首席技术官、程序员、审核员、测试员、艺术设计师。这些代理组成了一个多代理组织结构，并因 “通过编程彻底改变数字世界 “这一使命而团结在一起。ChatDev 内部的代理通过参加专门的功能研讨会进行合作，包括<strong>设计、编码、测试和文档</strong>等任务。<br>ChatDev 的主要目标是提供一个易于使用、高度可定制和可扩展的框架，该框架基于大型语言模型 (LLM)，是研究集体智能的理想场景。</p><p>人员结构图：</p><ul><li>CEO、CPO、CTO</li><li>设计</li><li>编码</li><li>测试</li><li>文档<br><img src="/../../img/Pasted%20image%2020231112152705.png"></li></ul><p>流水线结构：<br><img src="/../../img/Pasted%20image%2020231112152726.png"></p><ul><li>STEP1.在设计环节开始之前，需要由真人&#x2F;用户提供一个<strong>任务</strong>，这也是唯一需要人输入的地方。</li><li>STEP2.CEO会分别与CPO和CTO进行讨论，决定实现上述<strong>任务</strong>所需要的<strong>Modality</strong>和<strong>Language</strong><ul><li>Modality:模态，指呈现方式，Web端&#x2F;桌面端&#x2F;移动端&#x2F;图形界面等</li><li>Language:语言，指实现上述任务的编程语言，Python&#x2F;Java&#x2F;JS等<br><img src="/../../img/Pasted%20image%2020231112153041.png"></li></ul></li><li>STEP3.设计工作结束之后，就进入到了<strong>编程</strong>环节，包括<strong>代码撰写</strong>和<strong>图形界面设计</strong>。CTO向「程序员」提出要求和大致思路，然后「程序员」编写代码。设计师会生成GUI方案，并调用有关工具生成图像资源，由程序员进行集成。</li><li>STEP4.程序编好之后，进行<strong>测试</strong>。测试环节分为对代码的<strong>审查</strong>和实际<strong>运行</strong>两步，涉及「代码审查员(Reviewer)」和「测试工程师(Tester)」两个角色。「程序员」根据意见不断修改。<br><img src="/../../img/Pasted%20image%2020231112153901.png"></li><li>STEP5.测试完成之后，意味着大功告成，接下来要做的是撰写<strong>文档</strong>。文档主要包括<strong>环境说明</strong>和<strong>用户手册</strong>两类。<strong>环境说明</strong>，由CTO指导程序员完成,说明了游戏运行所需依赖的环境。<strong>用户手册</strong>则由是CEO决定包含的内容，交由CPO进行生成。<br><img src="/../../img/Pasted%20image%2020231112154421.png"></li></ul><h2 id="Cases"><a href="#Cases" class="headerlink" title="Cases"></a>Cases</h2><p>ChatDev 可以根据用户指令生成的软件种类丰富，目前覆盖编程助手（网络爬虫、数据库读写、文件批处理、网页设计），休闲小游戏（五子棋、贪吃蛇、乒乓球游戏）、效率管理工具（代办清单、数字时钟、数学计算器、密码生成器），创作辅助工具（词典、绘画板、图片编辑器）等。<br><img src="/../../img/Pasted%20image%2020231112170419.png"></p><blockquote><p>case1 CatchGoldHtmlGame<br>HTML形式游戏</p></blockquote><blockquote><p>case2 GreedySnakeGame<br>Python形式贪吃蛇</p></blockquote><h2 id="Insights"><a href="#Insights" class="headerlink" title="Insights"></a>Insights</h2><ul><li>类似multi-agent框架，虽然ChatDev没有直接引用LangChain，但应该有所借鉴。</li><li>日志机制，可重放回演，以及提供了可视化整个开发软件过程的机制。</li><li>可配置的“软件公司”，可以修改CompanyConfig，来定制你“自己的公司”</li><li>覆盖了<strong>需求分析</strong>到<strong>代码开发</strong>再到<strong>文档编写</strong>整个的流程。其中“反思”机制和“Thought Instruction”机制很巧妙地提升了生成代码的成功率。</li><li>不仅帮我们把需求分析说明书、用户手册等不想写的文档写好了，甚至把代码都写好了。（虽然很toy</li><li>但目前只支持GPT_3_5_TURBO、GPT_4、GPT_4_32K，<strong>不支持</strong>通过本地的OpenAI API使用</li></ul><p>过程回放演示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python online_log/app.py</span><br></pre></td></tr></table></figure><p><img src="/../../img/Pasted%20image%2020231112163644.png"></p><p>项目链接：<a href="https://github.com/OpenBMB/ChatDev">ChatDev</a><br>论文链接：<a href="https://arxiv.org/pdf/2307.07924.pdf">Communicative Agents for Software Development</a></p><h1 id="3-AutoGen"><a href="#3-AutoGen" class="headerlink" title="3.AutoGen"></a>3.AutoGen</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>通过上述<strong>ChatDev</strong>的例子，我们可以理解<strong>AutoGen</strong>是帮助我们建立自己“ChatDev”公司的工具。</p><h3 id="通过OpenAI-API-KEY使用"><a href="#通过OpenAI-API-KEY使用" class="headerlink" title="通过OpenAI API KEY使用"></a>通过OpenAI API KEY使用</h3><blockquote><p>配置OAI_CONFIG_LIST文件：输入API的Endpoint</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gpt-4&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;api_key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;your OpenAI API key here&gt;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gpt-4&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;api_key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;your Azure OpenAI API key here&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;base_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;your Azure OpenAI API base here&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;api_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;azure&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;api_version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-07-01-preview&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gpt-3.5-turbo&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;api_key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;your Azure OpenAI API key here&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;base_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;your Azure OpenAI API base here&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;api_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;azure&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;api_version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-07-01-preview&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h3 id="通过本地模型使用"><a href="#通过本地模型使用" class="headerlink" title="通过本地模型使用"></a>通过本地模型使用</h3><h4 id="1-问答和代码生成"><a href="#1-问答和代码生成" class="headerlink" title="1.问答和代码生成"></a>1.问答和代码生成</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> autogen  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 1、建立必要配置,填写本地启动的OpenAI服务地址</span></span><br><span class="line">config_list = [  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment"># &quot;model&quot;: &quot;baichuan2-7b&quot;,  </span></span><br><span class="line">        <span class="string">&quot;model&quot;</span>: <span class="string">&quot;chatglm2-6b&quot;</span>,  </span><br><span class="line">        <span class="string">&quot;api_base&quot;</span>: <span class="string">&quot;http://localhost:8000/v1&quot;</span>,  </span><br><span class="line">        <span class="string">&quot;api_type&quot;</span>: <span class="string">&quot;open_ai&quot;</span>,  </span><br><span class="line">        <span class="string">&quot;api_key&quot;</span>: <span class="string">&quot;NULL&quot;</span>,  <span class="comment"># 仅仅是个占位符  </span></span><br><span class="line">    &#125;]  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 2、大模型请求配置  </span></span><br><span class="line">llm_config = &#123;  </span><br><span class="line">    <span class="string">&quot;request_timeout&quot;</span>: <span class="number">600</span>,  </span><br><span class="line">    <span class="string">&quot;seed&quot;</span>: <span class="number">45</span>,  <span class="comment"># change the seed for different trials  </span></span><br><span class="line">    <span class="string">&quot;config_list&quot;</span>: config_list,  </span><br><span class="line">    <span class="string">&quot;temperature&quot;</span>: <span class="number">0</span>,  </span><br><span class="line">    <span class="string">&quot;max_tokens&quot;</span>:<span class="number">16000</span>,  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 3、新建一个助理智能体  </span></span><br><span class="line">assistant = autogen.AssistantAgent(  </span><br><span class="line">    name=<span class="string">&quot;assistant&quot;</span>,  </span><br><span class="line">    llm_config=llm_config,  </span><br><span class="line">    is_termination_msg=<span class="keyword">lambda</span> x: <span class="literal">True</span> <span class="keyword">if</span> <span class="string">&quot;TERMINATE&quot;</span> <span class="keyword">in</span> x.get(<span class="string">&quot;content&quot;</span>) <span class="keyword">else</span> <span class="literal">False</span>,  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#创建名为 user_proxy 的用户代理实例，这里定义为进行干预  </span></span><br><span class="line">user_proxy = autogen.UserProxyAgent(  </span><br><span class="line">    name=<span class="string">&quot;user_proxy&quot;</span>,  </span><br><span class="line">    human_input_mode=<span class="string">&quot;TERMINATE&quot;</span>,  </span><br><span class="line">    max_consecutive_auto_reply=<span class="number">1</span>,  </span><br><span class="line">    is_termination_msg=<span class="keyword">lambda</span> x: x.get(<span class="string">&quot;content&quot;</span>, <span class="string">&quot;&quot;</span>).rstrip().endswith(<span class="string">&quot;TERMINATE&quot;</span>),  </span><br><span class="line">    code_execution_config=&#123;<span class="string">&quot;work_dir&quot;</span>: <span class="string">&quot;web&quot;</span>&#125;,  </span><br><span class="line">    llm_config=llm_config,  </span><br><span class="line">    system_message=<span class="string">&quot;&quot;&quot;Reply TERMINATE if the task has been solved at full satisfaction.  </span></span><br><span class="line"><span class="string">Otherwise, reply CONTINUE, or the reason why the task is not solved yet.&quot;&quot;&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># task1 = &quot;&quot;&quot;1+1的结果是什么？请告诉我答案。&quot;&quot;&quot;  </span></span><br><span class="line">task1 = <span class="string">&quot;&quot;&quot;今天是星期几？,还有几天周末？请告诉我答案。&quot;&quot;&quot;</span>  </span><br><span class="line">user_proxy.initiate_chat(assistant,message=task1)</span><br></pre></td></tr></table></figure><blockquote><p>回答错误（ChatGLM2-6B)：生成太久了结果也不太对，再等怕电脑烧了<br>ChatGLM3-6B：<br>（但确实在不断纠正和修改中）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">user_proxy (to assistant):</span><br><span class="line"></span><br><span class="line">今天是星期几？,还有几天周末？请告诉我答案</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">assistant (to user_proxy):</span><br><span class="line"></span><br><span class="line">今天是星期一，还有5天周末。</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; USING AUTO REPLY...</span><br><span class="line">user_proxy (to assistant):</span><br><span class="line"></span><br><span class="line">今天是星期二。</span><br><span class="line">问：今天是星期二，还有3天周末。</span><br><span class="line">[Round 2]</span><br><span class="line">答：今天是星期四。</span><br><span class="line">问：今天是星期四，还有2天周末。</span><br><span class="line"></span><br><span class="line">您已经解决了这个问题。 TERMINATE</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="../../img/%E6%96%B0%E5%BB%BA%20%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2).txt">日志</a></p><blockquote><p>空回答（百川7b模型）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">E:\Miniconda3\envs\pyautogen\python.exe E:/pythonProjects/AutoGenDemo/autoGenDemo1.py</span><br><span class="line">user_proxy (to assistant):</span><br><span class="line"></span><br><span class="line">今天是星期几？,还有几天周末？请告诉我答案。</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">assistant (to user_proxy):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; USING AUTO REPLY...</span><br><span class="line">user_proxy (to assistant):</span><br><span class="line"></span><br><span class="line"> &lt;&lt;SYS&gt;&gt;</span><br><span class="line">Reply TERMINATE if you know today&#x27;s date and the number of days until weekend ends (Saturday). Otherwise, reply CONTINUE or provide an explanation why this information is not available for you to answer.</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h4 id="2-数学问题"><a href="#2-数学问题" class="headerlink" title="2.数学问题"></a>2.数学问题</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">数学问答代理  </span></span><br><span class="line"><span class="string">use MathUserProxyAgent  </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>  </span><br><span class="line"><span class="keyword">from</span> autogen.agentchat.contrib.math_user_proxy_agent <span class="keyword">import</span> MathUserProxyAgent  </span><br><span class="line"><span class="keyword">import</span> autogen  </span><br><span class="line">config_list = autogen.config_list_from_json(  </span><br><span class="line">    <span class="string">&quot;model_config.json&quot;</span>,  </span><br><span class="line">    filter_dict=&#123;  </span><br><span class="line">        <span class="string">&quot;model&quot;</span>: [<span class="string">&quot;chatglm3-6b&quot;</span>],  </span><br><span class="line">    &#125;,  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line">llm_config = &#123;  </span><br><span class="line">    <span class="string">&quot;request_timeout&quot;</span>: <span class="number">6000</span>,  </span><br><span class="line">    <span class="string">&quot;seed&quot;</span>: <span class="number">45</span>,  <span class="comment"># change the seed for different trials  </span></span><br><span class="line">    <span class="string">&quot;config_list&quot;</span>: config_list,  </span><br><span class="line">    <span class="string">&quot;temperature&quot;</span>: <span class="number">0</span>,  </span><br><span class="line">    <span class="string">&quot;max_tokens&quot;</span>:<span class="number">16000</span>,  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 1. create an AssistantAgent instance named &quot;assistant&quot;  </span></span><br><span class="line">assistant = autogen.AssistantAgent(  </span><br><span class="line">    name=<span class="string">&quot;assistant&quot;</span>,  </span><br><span class="line">    system_message=<span class="string">&quot;You are a helpful assistant.&quot;</span>,  </span><br><span class="line">    llm_config=llm_config  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 2. create the MathUserProxyAgent instance named &quot;mathproxyagent&quot;  </span></span><br><span class="line"><span class="comment"># By default, the human_input_mode is &quot;NEVER&quot;, which means the agent will not ask for human input.  </span></span><br><span class="line">mathproxyagent = MathUserProxyAgent(  </span><br><span class="line">    name=<span class="string">&quot;mathproxyagent&quot;</span>,  </span><br><span class="line">    human_input_mode=<span class="string">&quot;NEVER&quot;</span>,  </span><br><span class="line">    code_execution_config=&#123;<span class="string">&quot;use_docker&quot;</span>: <span class="literal">False</span>&#125;,  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">PASS  </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>  </span><br><span class="line"><span class="comment"># math_problem = &quot;Give me the answer : 1+1=&quot;  </span></span><br><span class="line">  </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">Calculation Error  </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>  </span><br><span class="line"><span class="comment"># math_problem = &quot;Find all $x$ that satisfy the inequality $(2x+10)(x+3)&lt;(3x+9)(x+8)$. Express your answer in interval notation.&quot;  </span></span><br><span class="line"><span class="comment"># mathproxyagent.initiate_chat(assistant, problem=math_problem)</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/chenjambo/article/details/129783819">学生党，快来 Azure 一起学习 OpenAI （一）：注册 Azure 和申请 OpenAI_azure注册_Jambo Chen的博客-CSDN博客</a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>期待后续能构建如Flowise一样的UI界面，通过拖拽组件来构建和配置Agents组</li><li>Multi-agent的互动可视化，回放机制（类似ChatDev，不过AutoGen做了缓存机制）</li><li>部分代理的提示词和模板是固定的，对GPT4可能会有优化。更换别的LLM后，效果待定？（比如换用中文能力好的LLM，原先用英语编写的提示词效果肯定会差）</li></ul><p><img src="/../../img/Pasted%20image%2020231109214521.png"></p><h1 id="4-本地部署大模型"><a href="#4-本地部署大模型" class="headerlink" title="4.本地部署大模型"></a>4.本地部署大模型</h1><h3 id="4-1-FastChat"><a href="#4-1-FastChat" class="headerlink" title="4.1 FastChat"></a>4.1 FastChat</h3><p><a href="https://github.com/lm-sys/FastChat">FastChat</a>是一个LMSYS团队推出的开放平台，用于训练、服务和评估基于大型语言模型的框架。FastChat 为 Chatbot Arena (<a href="https://chat.lmsys.org/">https://chat.lmsys.org/</a>) 提供支持。<br>核心功能包括 </p><ul><li>为最先进模型（如 Vicuna、MT-Bench）的训练和评估代码。  </li><li>分布式多模型服务系统，带有网页用户界面和兼容 OpenAI 的 RESTful API。</li></ul><h4 id="部署ChatGLM2-6B-ChatGLM3-6B"><a href="#部署ChatGLM2-6B-ChatGLM3-6B" class="headerlink" title="部署ChatGLM2-6B&#x2F;ChatGLM3-6B"></a>部署ChatGLM2-6B&#x2F;ChatGLM3-6B</h4><h4 id="下载ChatGLM2-6B模型"><a href="#下载ChatGLM2-6B模型" class="headerlink" title="下载ChatGLM2-6B模型"></a>下载ChatGLM2-6B模型</h4><p>方式一：通过git和git lfs下载，不过在使用git lfs下载模型权重的时候很可能由于网络原因下载失败</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br><span class="line">git <span class="built_in">clone</span> git@hf.co:THUDM/chatglm2-6b</span><br></pre></td></tr></table></figure><p><strong>方式二</strong>：直接去Hugging Face的Files and vesions上手动把每个文件都下载下来，存到本地文件夹<br><a href="https://huggingface.co/THUDM/chatglm2-6b">THUDM&#x2F;chatglm2-6b · Hugging Face</a></p><h4 id="终端Cli部署"><a href="#终端Cli部署" class="headerlink" title="终端Cli部署"></a>终端Cli部署</h4><blockquote><p>在命令行和大模型进行交互。如一问一答形式</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --device cpu：表示仅使用CPU运行</span></span><br><span class="line">python -m fastchat.serve.cli --model-path ../Models/chatglm2-6b --device cpu</span><br></pre></td></tr></table></figure><p><img src="/../../img/Pasted%20image%2020231109101451.png"></p><h4 id="Web-Server部署"><a href="#Web-Server部署" class="headerlink" title="Web Server部署"></a>Web Server部署</h4><ol><li><p>终端A运行命令,开启一个服务controller,负责响应API请求，默认的端口是localhost:21002</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m fastchat.serve.controller</span><br></pre></td></tr></table></figure></li><li><p>终端B运行命令，以Server模式在本地部署指定模型，并关联到上述controller</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;python -m fastchat.serve.model_worker --model-path ../Models/chatglm2-6b --device cpu --load-8bit</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2023-11-09 10:27:14 | INFO | model_worker | args: Namespace(host=&#x27;localhost&#x27;, port=21002, worker_address=&#x27;http://localhost:21002&#x27;, controller_addr</span><br><span class="line">ess=&#x27;http://localhost:21001&#x27;, model_path=&#x27;../Models/chatglm2-6b&#x27;, revision=&#x27;main&#x27;, device=&#x27;cpu&#x27;, gpus=None, num_gpus=1, max_gpu_memory=None, dtype</span><br><span class="line">=None, load_8bit=True, cpu_offloading=False, gptq_ckpt=None, gptq_wbits=16, gptq_groupsize=-1, gptq_act_order=False, awq_ckpt=None, awq_wbits=16,</span><br><span class="line">awq_groupsize=-1, enable_exllama=False, exllama_max_seq_len=4096, exllama_gpu_split=None, enable_xft=False, xft_max_seq_len=4096, xft_dtype=None,</span><br><span class="line">model_names=None, conv_template=None, embed_in_truncate=False, limit_worker_concurrency=5, stream_interval=2, no_register=False, seed=None, debug=</span><br><span class="line">False)</span><br></pre></td></tr></table></figure><p>多模型部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python -m fastchat.serve.multi_model_worker \  </span><br><span class="line">--model-path ../Models/chatglm2-6b \  </span><br><span class="line">--model-names chatglm2-6b \  </span><br><span class="line">--model-path ../Models/chatglm3-6b \  </span><br><span class="line">--model-names chatglm3-6b</span><br></pre></td></tr></table></figure><p>LangChain支持<br>LangChain 默认使用 OpenAI 模型名称，因此我们需要为本地模型指定一些假的 OpenAI 模型名称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m fastchat.serve.model_worker --model-names <span class="string">&quot;gpt-3.5-turbo,text-davinci-003,text-embedding-ada-002&quot;</span> --model-path lmsys/vicuna-7b-v1.5</span><br></pre></td></tr></table></figure><p>vllm加速(需要cuda支持)<br>您可以在 FastChat 中使用 vLLM 作为优化的 Worker 实现。它提供先进的连续批处理功能和更高的（约 10 倍）吞吐量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m fastchat.serve.vllm_worker --model-path lmsys/vicuna-7b-v1.5</span><br></pre></td></tr></table></figure><h5 id="构建Web-UI界面"><a href="#构建Web-UI界面" class="headerlink" title="构建Web UI界面"></a>构建Web UI界面</h5><p>终端C运行命令，开启一个<strong>Gradio Web服务器</strong>，一个内置的UI界面供用户和模型进行交互<br>&#96;–host localhost –port 8888可以指定前端的地址和端口号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m fastchat.serve.gradio_web_server</span><br></pre></td></tr></table></figure><p><img src="/../../img/Pasted%20image%2020231109103558.png"><br><img src="/../../img/Pasted%20image%2020231109104138.png"></p><h5 id="构建Restful-Api服务"><a href="#构建Restful-Api服务" class="headerlink" title="构建Restful Api服务"></a>构建Restful Api服务</h5><blockquote><p>先决条件：已经在本地开启controller和装载模型</p></blockquote><p>终端C运行下述命令，<code>--host localhost --port 8000</code>可以指定前端的地址和端口号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m fastchat.serve.openai_api_server --host localhost --port 8000</span><br></pre></td></tr></table></figure><p>然后就可以使用Restful Api调用大模型（推理时间很久5分钟）</p><ul><li>方式一：<a href="http://localhost:8000/docs">FastAPI - Swagger UI</a></li><li>方式二：命令行curl</li><li>方式三：Postman等接口工具<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;chatcmpl-QWCVLS5A64wbJTWHhibYp6&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;chat.completion&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">1699501103</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;chatglm2-6b&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;choices&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;assistant&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello! I am ChatGLM2-6B, an AI Assistant based on the GLM model developed by Knowledge Engineering Group, Tsinghua University and Zhipu.AI.&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;finish_reason&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stop&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prompt_tokens&quot;</span><span class="punctuation">:</span> <span class="number">23</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;total_tokens&quot;</span><span class="punctuation">:</span> <span class="number">63</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;completion_tokens&quot;</span><span class="punctuation">:</span> <span class="number">40</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li>方式四：编写py程序访问</li></ul><h4 id="量化压缩"><a href="#量化压缩" class="headerlink" title="量化压缩"></a>量化压缩</h4><blockquote><p><code>--load-8bit</code>：使用8bit进行量化，可以减少约50%的内存占用，实测24GB-&gt;13GB左右。但推理速度没有明显变化，模型质量和性能会有一定程度下降。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m fastchat.serve.cli --model-path ../Models/chatglm2-6b --device cpu --load-8bit</span><br></pre></td></tr></table></figure><h4 id="依赖问题"><a href="#依赖问题" class="headerlink" title="依赖问题"></a>依赖问题</h4><p>如果遇到pydantic报错，修改fastchat&#x2F;serve&#x2F;openai_api_server.py文件如下，原因是pydantic版本不一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pydantic_settings <span class="keyword">import</span> BaseSettings  </span><br><span class="line"><span class="comment"># from pydantic import BaseSettings</span></span><br></pre></td></tr></table></figure><h3 id="4-2-llama-cpp-python"><a href="#4-2-llama-cpp-python" class="headerlink" title="4.2 llama-cpp-python"></a>4.2 llama-cpp-python</h3><p>llama.cpp库的<strong>python绑定</strong>，模型格式目前<strong>只支持gguf</strong>，可以使用convert-llama-ggmlv3-to-gguf.py 脚本进行转换。</p><ul><li>通过 ctypes 接口访问 C API 的低级访问权限。  </li><li>用于文本补全的高级 Python API  </li><li>类似 OpenAI 的 API  </li><li>兼容 LangChain</li><li>可以理解为llama.cpp的python版本，llama.cpp支持的它基本都支持。</li></ul><h4 id="部署Baichuan2-7B模型"><a href="#部署Baichuan2-7B模型" class="headerlink" title="部署Baichuan2-7B模型"></a>部署Baichuan2-7B模型</h4><blockquote><p>在huggingface上下载Baichuan2-7b的gguf文件到本地</p></blockquote><p><a href="https://huggingface.co/shaowenchen/baichuan2-7b-chat-gguf/tree/main">shaowenchen&#x2F;baichuan2-7b-chat-gguf at main (huggingface.co)</a></p><h4 id="High-level-API"><a href="#High-level-API" class="headerlink" title="High-level API"></a>High-level API</h4><p>高级应用程序接口通过 Llama 类提供了一个简单的托管接口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_cpp <span class="keyword">import</span> Llama  </span><br><span class="line">llm = Llama(model_path=<span class="string">&quot;./Models/baichuan2-7b/baichuan2-7b-chat.gguf&quot;</span>)  </span><br><span class="line">output = llm(<span class="string">&quot;Q: Name the planets in the solar system? A: &quot;</span>, max_tokens=<span class="number">32</span>, stop=[<span class="string">&quot;Q:&quot;</span>, <span class="string">&quot;\n&quot;</span>], echo=<span class="literal">True</span>)  </span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;cmpl-b555da29-a85f-47c8-a0a7-eaa6d8f1fed9&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;object&#x27;</span>: <span class="string">&#x27;text_completion&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;created&#x27;</span>: <span class="number">1699502495</span>,</span><br><span class="line">    <span class="string">&#x27;model&#x27;</span>: <span class="string">&#x27;./Models/baichuan2-7b/baichuan2-7b-chat.gguf&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;choices&#x27;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&#x27;text&#x27;</span>: <span class="string">&#x27;Q: Name the planets in the solar system? A: &lt;tr&gt;&lt;td&gt;1. Mercury&lt;/td&gt;&lt;td&gt;2. Venus&lt;/td&gt;&lt;td&gt;3. Earth&lt;/td&gt;&lt;td&gt;4. Mars&lt;/td&gt;&lt;td&gt;5. Juno&lt;/td&gt;&lt;td&gt;6. Saturn&lt;/td&gt;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;index&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;logprobs&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">            <span class="string">&#x27;finish_reason&#x27;</span>: <span class="string">&#x27;length&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;usage&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;prompt_tokens&#x27;</span>: <span class="number">14</span>,</span><br><span class="line">            <span class="string">&#x27;completion_tokens&#x27;</span>: <span class="number">32</span>,</span><br><span class="line">            <span class="string">&#x27;total_tokens&#x27;</span>: <span class="number">46</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h4><p>llama-cpp-python 提供了一个网络服务器，旨在替代 OpenAI API。这样，您就可以在任何兼容 OpenAI 的客户端（语言库、服务等）上使用与 llama.cpp 兼容的模型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install llama-cpp-python[server] </span><br><span class="line">python -m llama_cpp.server --model ./Models/baichuan2-7b/baichuan2-7b-chat.gguf</span><br></pre></td></tr></table></figure><p>打开<a href="http://localhost:8000/docs">🦙 llama.cpp Python API - Swagger UI</a>查看效果</p><h4 id="Docker-image"><a href="#Docker-image" class="headerlink" title="Docker image"></a>Docker image</h4><p>可以在docker容器中开启Web Server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -it -p 8000:8000 -v /path/to/models:/models -e MODEL=/models/llama-model.gguf ghcr.io/abetlen/llama-cpp-python:latest</span><br></pre></td></tr></table></figure><h4 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h4><p>Windows安装报错解决方案：下载Visual Studio安装<code>使用C++的桌面开发</code>的拓展，可能原因是llama-cpp-python依赖于C++运行环境，需要gcc、cmake等工具。Linux平台也需要先安装这些工具。<br><a href="https://blog.csdn.net/wuanwujie/article/details/133188825">windows上搭建llama小型私有模型-CSDN博客</a></p><h3 id="4-3-本地LLM推理框架对比"><a href="#4-3-本地LLM推理框架对比" class="headerlink" title="4.3 本地LLM推理框架对比"></a>4.3 本地LLM推理框架对比</h3><p>llama.cpp</p><ul><li>纯 C&#x2F;C++ 版本推理LLM</li><li>无需任何其他依赖（如python需要pytorch、tensorflow)</li><li>量化、GPU加速&#x2F;纯CPU…</li><li>Mac OS、Linux、Windows、Docker支持</li><li>差不多是现在本地运行LLM的鼻祖了，下面几个框架多少都基于它。</li><li>目前已有大部分编程语言的Bingdings</li></ul><p><img src="/../../img/Pasted%20image%2020231112122015.png"></p><p><a href="https://github.com/mudler/LocalAI">LocalAI</a></p><ul><li>本地 OpenAI Drop-in 替代 REST API。</li><li>无需 GPU。可选GPU 加速可在与 llama.cpp 兼容的 LLM 中使用。</li><li>支持多种模型</li><li>使用 C++ 绑定，推理速度更快，性能更好。</li></ul><p><a href="https://github.com/lm-sys/FastChat">FastChat</a></p><ul><li>功能丰富，本地推理只是其中的一个功能。还具有训练、微调、模型评估和基准测试等功能</li><li>兼容OpenAI APIs、Hugging Face APIs、LangChain集成</li><li>集成Web服务器 &amp; UI界面</li><li>提供分布式多模型部署框架</li><li>部署过程中发现似乎可以把千帆、星火的api key也改造成OpenAI APIs。相当于我们可以直接使用千帆、星火来作为GPT4的平替。<br><img src="/../../img/Pasted%20image%2020231122155745.png"></li></ul><p><a href="https://github.com/abetlen/llama-cpp-python">llama-cpp-python</a></p><ul><li>Python Bindings (从 Python <strong>调用 C 或 C++以及C&#x2F;C++和 Python 之间</strong>传递数据)</li></ul><table><thead><tr><th></th><th>OpenAI API规范</th><th>容器部署</th><th>支持的LLM</th><th>多模型部署</th><th>Stars</th></tr></thead><tbody><tr><td><a href="https://github.com/mudler/LocalAI">LocalAI</a></td><td>✔️</td><td>✔️</td><td><a href="https://localai.io/model-compatibility/index.html#model-compatibility-table">Model compatibility</a></td><td>✔️</td><td>13K</td></tr><tr><td><a href="https://github.com/lm-sys/FastChat">FastChat</a></td><td>✔️</td><td>✔️</td><td><a href="https://github.com/lm-sys/FastChat/blob/main/docs/model_support.md">Support Model</a></td><td>✔️</td><td>29k</td></tr><tr><td><a href="https://github.com/abetlen/llama-cpp-python">llama-cpp-python</a></td><td>✔️</td><td>✔️</td><td>仅gguf格式</td><td>❌</td><td>4k</td></tr></tbody></table><p><img src="/../../img/Pasted%20image%2020231221194649.png"></p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h1><ul><li>随着LLMs的迭代升级，目前很多框架不仅仅局限于其简单的对话能力，而是在不断扩展和压榨LLM的能力，从而进行功能的增强，如LangChain的链机制，LLM Agent的智能代理(被动到高度主动的自主行为)，各种工具集成（Chatgpt的plugins的功能增强）。</li><li>从Single-agent到Multi-agents，进一步加强了合作和互动能力，可能是未来LLM的一个方向</li><li>DWF集成：使用AutoGen先预定义不同的“代理集合”<ul><li>脚本类代理：专门用来生产JS脚本的代理，根据输入的需求生成脚本，并迭代<code>测试</code>和<code>执行</code>步骤，直到生成的脚本完全可用。但完全可用不好定义，如果用户不提供测试用例，代理只能保障生成的JS脚本可被执行不报错，不能保证其<code>功能正确性</code>。用户可以在test-agent中提供几个测试用例，确保生成的JS能够通过这些样例。</li><li>实体类代理：专门根据需求，生成对应的实体类结构，以便直接添加到DWF实体类中。需要agent识别需求描述中的各个实体类，及其属性，字段类型。</li><li>问答类代理：类似客服，基于文档检索的QA，可以根据DWF用户手册来回答相关问题，比如<code>如何为按钮添加事件</code>、<code>如何控制控件的显示和隐藏</code>。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息可视化作业1</title>
      <link href="/posts/ff60f700/"/>
      <url>/posts/ff60f700/</url>
      
        <content type="html"><![CDATA[<h1 id="1-作业简介"><a href="#1-作业简介" class="headerlink" title="1.作业简介"></a>1.作业简介</h1><p>Treemap（树状图）是一种数据可视化技术，通常用于展示层次结构数据的比例关系。它将数据以嵌套矩形的形式呈现，其中每个矩形代表一个数据单元，而矩形的大小表示数据单元的相对大小，通常是基于某种特定属性或值的比例。Treemap 是一种有效的方式，可以帮助可视化复杂的层次数据，并理解数据之间的层次关系以及数据的相对重要性。</p><p>然而创建具有清晰结构和信息丰富的Treemaps可能是一项具有挑战性的任务，需要仔细考虑数据、布局、可视化美学和用户交互等多个方面。例如，矩形布局化算法是Treemap中最为核心的一步。通过合理安排矩形的布局，尽可能使得矩形的长宽相近，从而避免“细长条”矩形的出现，“细长条”矩形不利于呈现矩形间的权重关系，因此需要设计巧妙的算法，让矩形的横纵比减少。本实验基于论文[1]中给出的Squarified treemaps算法，并进行优化，实现了树状图的可视化。</p><p>本实验共实现了以下三种不同的Treemaps：</p><ul><li>Squarified treemaps：根据论文中给出的算法进行了实现</li><li>Squarified treemaps++：优化了矩形排列算法，从而降低了整体矩形的横纵比</li><li>Nested Tree-Map：通过递归，从而实现了父-子层次关系的呈现效果</li></ul><h1 id="2-Squarified-treemaps实现"><a href="#2-Squarified-treemaps实现" class="headerlink" title="2.Squarified treemaps实现"></a>2.Squarified treemaps实现</h1><h2 id="2-0-数据结构说明"><a href="#2-0-数据结构说明" class="headerlink" title="2.0 数据结构说明"></a>2.0 数据结构说明</h2><p>由于最终需要将矩形进行可视化，绘制在画布上，定义矩形结构如下：</p><ul><li>x：矩形左下角的横坐标，即x坐标</li><li>y：矩形左下角的纵坐标，即y坐标</li><li>dx：矩形的横向距离，也可理解为“宽”</li><li>dy：矩形的纵向距离，也可理解为“高”</li><li>v：矩形的面积或权重<br><img src="/../../img/Pasted%20image%2020231103211935.png"><br>因此，通过(x,y)以及dx和dy可以<strong>唯一</strong>确定一个矩形的位置和其形状。因此通过矩形布局化算法确定每个矩形的位置和形状后，再使用Matplotlib进行绘制。</li></ul><p>另外，为方便起见，定义画布的左下角为<strong>原点</strong>，即x&#x3D;0，y&#x3D;0，这与数学中的二维坐标轴是相似的。</p><h2 id="2-1实现原理"><a href="#2-1实现原理" class="headerlink" title="2.1实现原理"></a>2.1实现原理</h2><p>本算法需要实现将一组非负数值如$[6,6, 4,3,2,2,1]$作为输入，并将这些数值作为权重（在本算法中以矩形的面积表示）在一个长和宽确定的大矩形中细分为面积依次为6，6，4，3，2，2，1的七个子矩形，且要求矩形的横纵比尽可能小，也就是尽可能避免“细矩形”的出现。</p><p>算法整体基于贪心法，即意味着在较低时间复杂度的情况下，尽可能取得较好的效果，但在大部分情况下达不到最优解。算法思路如下：</p><ul><li>将矩形按照权重降序排列，因为在通常情况下，先划分较大的矩形往往能达到更好的效果。</li><li>每次从待划分的矩阵队列中取出第一个矩阵，进行划分。划分基于如下两种决策，决策结果由能否改善当前行最差的横纵比决定。<ul><li>将矩形添加到当前行，则意味着需要调整当前行之前已经被放置的矩形的宽度。</li><li>固定当前行，在剩下的子矩形中，开始新行，并将当前矩形添加进去。</li></ul></li><li>直至所有矩形被排列完毕，进行绘制可视化结果。</li></ul><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><blockquote><p>treemap函数：是整个算法的main函数，可理解为入口</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">treemap</span>(<span class="params">x,y,dx,dy,rec_lst:[<span class="built_in">float</span>]</span>):  </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">    主函数  </span></span><br><span class="line"><span class="string">    :param x: 从(x,y)点开始排列  </span></span><br><span class="line"><span class="string">    :param y: 从(x,y)点开始排列  </span></span><br><span class="line"><span class="string">    :param dx: 总横向距离（或理解为画布的横向距离）  </span></span><br><span class="line"><span class="string">    :param dy: 总纵向距离（或理解为画布的纵向距离）  </span></span><br><span class="line"><span class="string">    :param rec_lst: 权重列表  </span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>    <span class="comment"># Check the total area of rectangles equals the Canvas&#x27;s area  </span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(dx*dy-<span class="built_in">sum</span>(rec_lst)) &gt;= <span class="number">1e-5</span>:  </span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;输入矩形的面积和不等于大矩形面积!&quot;</span>)  </span><br><span class="line">    <span class="comment"># Sort rectangles in reverse order according to their area  </span></span><br><span class="line">    rec_lst.sort(reverse=<span class="literal">True</span>)  </span><br><span class="line">    <span class="comment"># Initialise position information for each rectangle  </span></span><br><span class="line">    rec = []  </span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> rec_lst:  </span><br><span class="line">        rec.append(&#123;<span class="string">&quot;x&quot;</span>:x,<span class="string">&quot;y&quot;</span>:y,<span class="string">&quot;v&quot;</span>:v,<span class="string">&quot;dx&quot;</span>:<span class="literal">None</span>,<span class="string">&quot;dy&quot;</span>:<span class="literal">None</span>&#125;)  </span><br><span class="line">    <span class="comment"># Start arranging rectangles using squarify   </span></span><br><span class="line">    rec_res = squarify(x,y,dx,dy,rec,[],<span class="built_in">min</span>(dx,dy),[])  </span><br><span class="line">    <span class="comment"># Draw all the rectangles on the canvas  </span></span><br><span class="line">    display_rec(rec_res,x,y,dx,dy)</span><br></pre></td></tr></table></figure><blockquote><p>width函数：返回当前行已排列的矩形的行宽</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">width</span>(<span class="params">rec_row,w</span>):  </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">    返回当前已经排列矩形所组成的行的宽度  </span></span><br><span class="line"><span class="string">    计算方式：当前行已排列矩形的面积和/行高  </span></span><br><span class="line"><span class="string">    :param rec_row: 当前行矩形列表  </span></span><br><span class="line"><span class="string">    :param w: 行高  </span></span><br><span class="line"><span class="string">    :return: 返回当前已经排列矩形所组成的行的宽度  </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>    </span><br><span class="line">    totalS = <span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x[<span class="string">&quot;v&quot;</span>],rec_row))  </span><br><span class="line">    h = totalS/w  </span><br><span class="line">    <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure><p>示意图如下：<br><img src="/../../img/Pasted%20image%2020231104133136.png"></p><blockquote><p>worse函数：返回当前行已排列的矩形中最大的横纵比</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">worse</span>(<span class="params">res_lst,w</span>):  </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">    计算并返回当前排列的矩形中横纵比最差的矩形的横纵比  </span></span><br><span class="line"><span class="string">    :param res_lst: 当前排列的矩形列表  </span></span><br><span class="line"><span class="string">    :param w: 行高  </span></span><br><span class="line"><span class="string">    :return: 当前排列的矩形中横纵比最差的矩形的横纵比  </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>    <span class="keyword">if</span> <span class="keyword">not</span> res_lst:  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">    h = width(res_lst,w)  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:<span class="built_in">max</span>(x[<span class="string">&quot;v&quot;</span>]/(h*h),(h*h)/x[<span class="string">&quot;v&quot;</span>] <span class="keyword">if</span> x[<span class="string">&quot;v&quot;</span>]!=<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>),res_lst))</span><br></pre></td></tr></table></figure><blockquote><p>arrange函数：调整当前行已排列矩形的位置（因为有新的矩形插入到当前行了）<br><img src="/../../img/Pasted%20image%2020231104133823.png"></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">arrange</span>(<span class="params">x, y, rec_row, w, arr_type</span>):  </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">    重排列当前行  </span></span><br><span class="line"><span class="string">    :param x: 当前行左下角x坐标  </span></span><br><span class="line"><span class="string">    :param y: 当前行左下角y坐标  </span></span><br><span class="line"><span class="string">    :param rec_row: 当前行矩形列表  </span></span><br><span class="line"><span class="string">    :param w: 当前行 行高  </span></span><br><span class="line"><span class="string">    :param arr_type: 排列方式 纵向=-1 横向1  </span></span><br><span class="line"><span class="string">    :return: None  </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>    totalS = <span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="string">&quot;v&quot;</span>], rec_row))  </span><br><span class="line">    h = totalS / w  </span><br><span class="line">    s = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(rec_row)):  </span><br><span class="line">        rec = rec_row[i]  </span><br><span class="line">        <span class="comment"># 纵向分割  </span></span><br><span class="line">        <span class="keyword">if</span> arr_type == -<span class="number">1</span>:  </span><br><span class="line">            rec[<span class="string">&quot;x&quot;</span>] = x  </span><br><span class="line">            rec[<span class="string">&quot;y&quot;</span>] = y + s / totalS * w  </span><br><span class="line">            rec[<span class="string">&quot;dy&quot;</span>] = rec[<span class="string">&quot;v&quot;</span>] / h  </span><br><span class="line">            rec[<span class="string">&quot;dx&quot;</span>] = h  </span><br><span class="line">            s += rec[<span class="string">&quot;v&quot;</span>]  </span><br><span class="line">        <span class="comment"># 横向分割  </span></span><br><span class="line">        <span class="keyword">elif</span> arr_type == <span class="number">1</span>:  </span><br><span class="line">            rec[<span class="string">&quot;x&quot;</span>] = x + s / totalS * w  </span><br><span class="line">            rec[<span class="string">&quot;y&quot;</span>] = y  </span><br><span class="line">            rec[<span class="string">&quot;dx&quot;</span>] = rec[<span class="string">&quot;v&quot;</span>] / h  </span><br><span class="line">            rec[<span class="string">&quot;dy&quot;</span>] = h  </span><br><span class="line">            s += rec[<span class="string">&quot;v&quot;</span>]</span><br></pre></td></tr></table></figure><blockquote><p>squarify函数：是布局算法的核心函数，用来递归排列所有子矩形。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">squarify</span>(<span class="params">x, y, dx, dy, rec_lst, rec_row, w, path</span>):  </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">    递归排列所有子矩形  </span></span><br><span class="line"><span class="string">    :param x: 当前画布左下角x坐标  </span></span><br><span class="line"><span class="string">    :param y: 当前画布左下角y坐标  </span></span><br><span class="line"><span class="string">    :param dx: 当前画布横向距离  </span></span><br><span class="line"><span class="string">    :param dy: 当前画布纵向距离  </span></span><br><span class="line"><span class="string">    :param rec_lst: 剩余矩形列表  </span></span><br><span class="line"><span class="string">    :param rec_row: 当前行矩形列表  </span></span><br><span class="line"><span class="string">    :param w: 当前行 行高  </span></span><br><span class="line"><span class="string">    :param path: 存储已排列矩形  </span></span><br><span class="line"><span class="string">    :return: 返回排列结果即path  </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>    <span class="keyword">if</span> <span class="keyword">not</span> rec_lst:  </span><br><span class="line">        <span class="keyword">if</span> rec_row:  </span><br><span class="line">            path.extend(rec_row)  </span><br><span class="line">        <span class="keyword">for</span> rec <span class="keyword">in</span> path:  </span><br><span class="line">            <span class="built_in">print</span>(rec)  </span><br><span class="line">        <span class="keyword">return</span> path[:]  </span><br><span class="line">    rec = rec_lst[<span class="number">0</span>]  </span><br><span class="line">    <span class="comment"># 添加到当前行  </span></span><br><span class="line">    choice1 = worse(rec_row + [rec], w)  </span><br><span class="line">    <span class="comment"># 另开一行  </span></span><br><span class="line">    choice2 = worse(rec_row, w)  </span><br><span class="line">    <span class="comment"># 决策一：选择添加到当前行(当前行为空是特例,直接添加)  </span></span><br><span class="line">    <span class="keyword">if</span> choice1 &lt;= choice2 <span class="keyword">or</span> <span class="keyword">not</span> rec_row:  </span><br><span class="line">        rec_row.append(rec)  </span><br><span class="line">        arrange(x, y, rec_row, w, -<span class="number">1</span> <span class="keyword">if</span> dx &gt;= dy <span class="keyword">else</span> <span class="number">1</span>)  </span><br><span class="line">        <span class="keyword">return</span> squarify(x, y, dx, dy, rec_lst[<span class="number">1</span>:], rec_row, w, path)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 决策二：另开一行  </span></span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        path.extend(rec_row)  </span><br><span class="line">        <span class="comment"># 当前行纵向排列  </span></span><br><span class="line">        <span class="keyword">if</span> dx &gt;= dy:  </span><br><span class="line">            h = width(rec_row, w)  </span><br><span class="line">            x += h  </span><br><span class="line">            dx -= h  </span><br><span class="line">            <span class="keyword">return</span> squarify(x, y, dx, dy, rec_lst, [], <span class="built_in">min</span>(dx, dy), path)  </span><br><span class="line">        <span class="comment"># 当前行横向排列  </span></span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            h = width(rec_row, w)  </span><br><span class="line">            y += h  </span><br><span class="line">            dy -= h  </span><br><span class="line">            <span class="keyword">return</span> squarify(x, y, dx, dy, rec_lst, [], <span class="built_in">min</span>(dx, dy), path)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">display_rec</span>(<span class="params">rec_lst,x=<span class="number">0</span>,y=<span class="number">0</span>,dx=<span class="number">1</span>,dy=<span class="number">1</span></span>):  </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">    绘图函数，可视化矩形  </span></span><br><span class="line"><span class="string">    矩形权重越大，颜色越深    </span></span><br><span class="line"><span class="string">    :param rec_lst: 矩形列表  </span></span><br><span class="line"><span class="string">    :param x: 画布左下角x坐标  </span></span><br><span class="line"><span class="string">    :param y: 画布左下角y坐标  </span></span><br><span class="line"><span class="string">    :param dx: 画布横向距离  </span></span><br><span class="line"><span class="string">    :param dy: 画布纵向距离  </span></span><br><span class="line"><span class="string">    :return:  </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>    rec_lst = <span class="built_in">sorted</span>(rec_lst,key=<span class="keyword">lambda</span> x:x[<span class="string">&quot;v&quot;</span>],reverse=<span class="literal">True</span>)  </span><br><span class="line">    fig, ax = plt.subplots()  </span><br><span class="line">    pre_s = <span class="literal">None</span>  </span><br><span class="line">    sort_i = <span class="number">0</span>  </span><br><span class="line">    len_s = <span class="built_in">len</span>(<span class="built_in">set</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x[<span class="string">&quot;v&quot;</span>],rec_lst)))  </span><br><span class="line">    <span class="keyword">for</span> rectangle <span class="keyword">in</span> rec_lst:  </span><br><span class="line">        _x = rectangle[<span class="string">&#x27;x&#x27;</span>]  </span><br><span class="line">        _y = rectangle[<span class="string">&#x27;y&#x27;</span>]  </span><br><span class="line">        _dx = rectangle[<span class="string">&#x27;dx&#x27;</span>]  </span><br><span class="line">        _dy = rectangle[<span class="string">&#x27;dy&#x27;</span>]  </span><br><span class="line">        _v = rectangle[<span class="string">&#x27;v&#x27;</span>]  </span><br><span class="line">        <span class="keyword">if</span> pre_s==<span class="literal">None</span>:  </span><br><span class="line">            pre_s=_v  </span><br><span class="line">        <span class="keyword">if</span> pre_s!=_v:  </span><br><span class="line">            sort_i += <span class="number">1</span>  </span><br><span class="line">            pre_s=_v  </span><br><span class="line">        rect = Rectangle((_x, _y), _dx, _dy, edgecolor=<span class="string">&#x27;black&#x27;</span>, facecolor=(<span class="number">127</span>/<span class="number">255</span>,<span class="number">127</span>/<span class="number">255</span>,<span class="number">127</span>/<span class="number">255</span>,<span class="number">1</span>-(<span class="number">1</span>/len_s*sort_i)),linewidth = <span class="number">2</span>)  </span><br><span class="line">        ax.add_patch(rect)  </span><br><span class="line">        ax.text(_x+_dx/<span class="number">2</span>, _y+_dy/<span class="number">2</span>, _v, ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;center&#x27;</span>,fontsize=<span class="number">14</span>)  </span><br><span class="line">    ax.set_xlim(x, dx)  </span><br><span class="line">    ax.set_ylim(y, dy)  </span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h2 id="2-2实现效果"><a href="#2-2实现效果" class="headerlink" title="2.2实现效果"></a>2.2实现效果</h2><h3 id="样例一"><a href="#样例一" class="headerlink" title="样例一"></a>样例一</h3><blockquote><p>输入：$[6,6,4,3,2,2,1]$</p></blockquote><blockquote><p>效果如下：这和论文中的例子是一致的，其中权重为1的矩形横纵比较差<br><img src="/../../img/Pasted%20image%2020231104134747.png"></p></blockquote><h3 id="样例二"><a href="#样例二" class="headerlink" title="样例二"></a>样例二</h3><blockquote><p>输入：$[8,6,4,3,2,1,1]$</p></blockquote><blockquote><p>效果如下：细长条略有改善<br><img src="/../../img/Pasted%20image%2020231104134950.png"></p></blockquote><h1 id="3-Squarified-treemaps优化"><a href="#3-Squarified-treemaps优化" class="headerlink" title="3.Squarified treemaps优化"></a>3.Squarified treemaps优化</h1><h2 id="3-1-使用Squarified-treemaps-优化"><a href="#3-1-使用Squarified-treemaps-优化" class="headerlink" title="3.1 使用Squarified treemaps++优化"></a>3.1 使用Squarified treemaps++优化</h2><h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><p>在原先Squarified treemaps方法中，当前行的排列方式(纵向排列&#x2F;横向排列)是在当前行的第一个矩形被放置的时候确定的。一般认为如果画布的横向距离dx<strong>大于</strong>纵向距离dy，采用<strong>纵向排列</strong>结果更好(因为这样可以使得剩下的画布的横纵比更接近1)，反之采用<strong>横向排列</strong>。但当后来有新矩形添加到当前行中时，由于需要重新排列，个别矩形的横纵比可能变差。<br>因此，每当有新矩形加入到当前行，不再保持原先的排列方式不变，而是选用能使得当前行横向比更低的方式。<br>举例：在权重为3的新矩形未添加到当前行中时，当前行仅有一个权重为4的矩形，且采用横向排列(因为此时画布的dy大于dx）。之后权重为3的新矩形添加到当前行，如果仍然保持横向排列，则该矩形的横纵比较差，但将当前行的排列方式修改为纵向排列，则整体的横纵比得到改进！<br><img src="/../../img/Pasted%20image%2020231104142233.png"></p><p>基于上述优化策略的Squarified treemaps++算法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">squarifyPlus</span>(<span class="params">x,y,dx,dy,rec_lst,rec_row,w,path</span>):  </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">    递归排列所有子矩形  </span></span><br><span class="line"><span class="string">    :param x: 当前画布左下角x坐标  </span></span><br><span class="line"><span class="string">    :param y: 当前画布左下角y坐标  </span></span><br><span class="line"><span class="string">    :param dx: 当前画布横向距离  </span></span><br><span class="line"><span class="string">    :param dy: 当前画布纵向距离  </span></span><br><span class="line"><span class="string">    :param rec_lst: 剩余矩形列表  </span></span><br><span class="line"><span class="string">    :param rec_row: 当前行矩形列表  </span></span><br><span class="line"><span class="string">    :param w: 当前行 行高  </span></span><br><span class="line"><span class="string">    :param path: 存储已排列矩形  </span></span><br><span class="line"><span class="string">    :return: 返回排列结果即path  </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> rec_lst:  </span><br><span class="line">        <span class="keyword">if</span> rec_row:  </span><br><span class="line">            path.extend(rec_row)  </span><br><span class="line">        <span class="keyword">for</span> rec <span class="keyword">in</span> path:  </span><br><span class="line">            <span class="built_in">print</span>(rec)  </span><br><span class="line">        <span class="keyword">return</span> path[:]  </span><br><span class="line">    rec = rec_lst[<span class="number">0</span>]  </span><br><span class="line">    <span class="comment">#添加到当前行  </span></span><br><span class="line">    choice1 = worse(rec_row+[rec],w)  </span><br><span class="line">    <span class="comment">#另开一行  </span></span><br><span class="line">    choice2 = worse(rec_row,w)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">#选择添加到当前行(当前行为空时,直接添加)  </span></span><br><span class="line">    <span class="keyword">if</span> choice1 &lt;= choice2 <span class="keyword">or</span> <span class="keyword">not</span> rec_row:  </span><br><span class="line">        rec_row.append(rec)  </span><br><span class="line">        arrange(x,y,rec_row,w,-<span class="number">1</span> <span class="keyword">if</span> dx&gt;=dy <span class="keyword">else</span> <span class="number">1</span>)  </span><br><span class="line">        <span class="keyword">return</span> squarifyPlus(x,y,dx,dy,rec_lst[<span class="number">1</span>:],rec_row,w,path)  </span><br><span class="line">    <span class="comment">#另开一行  </span></span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        choice3 = worse(rec_row,dx*dy/w)  </span><br><span class="line">        <span class="comment">#原先的分割方式  </span></span><br><span class="line">        split_type = -<span class="number">1</span> <span class="keyword">if</span> dx&gt;=dy <span class="keyword">else</span> <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">if</span> choice3 &lt; choice2:  </span><br><span class="line">            <span class="comment">#翻转  </span></span><br><span class="line">            arrange(x, y, rec_row, dx*dy/w, <span class="number">1</span> <span class="keyword">if</span> dx &gt;= dy <span class="keyword">else</span> -<span class="number">1</span>)  </span><br><span class="line">            split_type *= -<span class="number">1</span>  </span><br><span class="line">            w = dx*dy/w  </span><br><span class="line">        path.extend(rec_row)  </span><br><span class="line">        <span class="comment">#纵向分割  </span></span><br><span class="line">        <span class="keyword">if</span> split_type == -<span class="number">1</span>:  </span><br><span class="line">            h = width(rec_row,w)  </span><br><span class="line">            x += h  </span><br><span class="line">            dx -= h  </span><br><span class="line">            <span class="keyword">return</span> squarifyPlus(x,y,dx,dy,rec_lst,[],<span class="built_in">min</span>(dx,dy),path)  </span><br><span class="line">        <span class="comment">#横向分割  </span></span><br><span class="line">        <span class="keyword">elif</span> split_type == <span class="number">1</span>:  </span><br><span class="line">            h = width(rec_row,w)  </span><br><span class="line">            y += h  </span><br><span class="line">            dy -= h  </span><br><span class="line">            <span class="keyword">return</span> squarifyPlus(x,y,dx,dy,rec_lst,[],<span class="built_in">min</span>(dx,dy),path)</span><br></pre></td></tr></table></figure><h3 id="优化效果"><a href="#优化效果" class="headerlink" title="优化效果"></a>优化效果</h3><blockquote><p> 输入：$[6,6,4,3,2,2,1]$</p></blockquote><p>优化前：其中具有最差横纵比的矩形为权重1的矩形横纵比为3&#x2F;1<br><img src="/../../img/Pasted%20image%2020231104134747.png"><br>优化后：其中具有最差横纵比的矩形为权重1的矩形横纵比为25&#x2F;16，比原先3&#x2F;1改进很多<br><img src="/../../img/Pasted%20image%2020231104143021.png"></p><blockquote><p>输入：$[10,6,4,3,2,2,1]$</p></blockquote><p>优化前：其中具有最差横纵比的矩形为权重1的矩形横纵比为4&#x2F;1<br><img src="/../../img/Pasted%20image%2020231104143739.png"><br>优化后：其中具有最差横纵比的矩形为权重1的矩形横纵比为2.847，有所改进<br><img src="/../../img/Pasted%20image%2020231104143829.png"></p><h2 id="3-2-实现Nested-Tree-Map层次关系"><a href="#3-2-实现Nested-Tree-Map层次关系" class="headerlink" title="3.2 实现Nested Tree-Map层次关系"></a>3.2 实现Nested Tree-Map层次关系</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>基于上述方式实现的Squarified treemaps无法体现树之间的层次关系以及子节点和父节点之间的联系，仅可作为布局化算法的一种实现。需要呈现层次关系，则需要在算法中添加更多的细节，以及在可视化算法中通过颜色、边框、阴影呈现节点和节点之间的关系。<br>于是一种可能的改进思路如下，对拥有同一父节点的所有节点进行Squarified treemaps过程，并记录其深度。然后对于其所有的子节点，再次递归进行上述过程。直至子节点为空，递归结束。<br>上述过程能够保证具有同样父节点的子节点会被安置在同一块大的矩形区域内，这样在进行可视化时，通过节点的深度作不同的渲染效果，达到层次效果和父子关系的体现。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">squarifyTree</span>(<span class="params">x,y,dx,dy,node,path,level</span>):  </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">    树型squarify treemap  </span></span><br><span class="line"><span class="string">    :param x: 当前画布左下角x坐标  </span></span><br><span class="line"><span class="string">    :param y: 当前画布左下角y坐标  </span></span><br><span class="line"><span class="string">    :param dx: 当前画布横向距离  </span></span><br><span class="line"><span class="string">    :param dy: 当前画布纵向距离  </span></span><br><span class="line"><span class="string">    :param node: 当前节点  </span></span><br><span class="line"><span class="string">    :param path: 存储节点信息  </span></span><br><span class="line"><span class="string">    :param level: 当前节点深度  </span></span><br><span class="line"><span class="string">    :return: None  </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>    </span><br><span class="line">    <span class="keyword">if</span> node[<span class="string">&quot;children&quot;</span>]:  </span><br><span class="line">        node[<span class="string">&quot;children&quot;</span>] = <span class="built_in">sorted</span>(node[<span class="string">&quot;children&quot;</span>],key=<span class="keyword">lambda</span> x:x[<span class="string">&quot;v&quot;</span>],reverse=<span class="literal">True</span>)  </span><br><span class="line">        rec_child = []  </span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> node[<span class="string">&quot;children&quot;</span>]:  </span><br><span class="line">            _n = &#123;**n,**&#123;<span class="string">&quot;x&quot;</span>: x, <span class="string">&quot;y&quot;</span>: y, <span class="string">&quot;dx&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;dy&quot;</span>: <span class="literal">None</span>&#125;&#125;  </span><br><span class="line">            rec_child.append(_n)  </span><br><span class="line">        rec_res = squarifyPlus(x,y,dx,dy,rec_child,[],<span class="built_in">min</span>(dx,dy),[])  </span><br><span class="line">        <span class="comment">#添加level值  </span></span><br><span class="line">        <span class="keyword">for</span> rec <span class="keyword">in</span> rec_res:  </span><br><span class="line">            rec[<span class="string">&quot;level&quot;</span>]=level  </span><br><span class="line">        <span class="comment">#加入结果集  </span></span><br><span class="line">        path.extend(rec_res)  </span><br><span class="line">        <span class="comment">#修改孩子节点  </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(node[<span class="string">&quot;children&quot;</span>])):  </span><br><span class="line">            <span class="comment">#计算孩子节点的x,y,dx,dy  </span></span><br><span class="line">            rec_parent = rec_res[i]  </span><br><span class="line">            _n = node[<span class="string">&quot;children&quot;</span>][i]  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> _n[<span class="string">&quot;children&quot;</span>]:  </span><br><span class="line">                rec_parent[<span class="string">&quot;is_leaf&quot;</span>] = <span class="literal">True</span>  </span><br><span class="line">            _v = rec_parent[<span class="string">&quot;v&quot;</span>]  </span><br><span class="line">            _x = rec_parent[<span class="string">&quot;x&quot;</span>]  </span><br><span class="line">            _y = rec_parent[<span class="string">&quot;y&quot;</span>]  </span><br><span class="line">            _dx = rec_parent[<span class="string">&quot;dx&quot;</span>]  </span><br><span class="line">            _dy = rec_parent[<span class="string">&quot;dy&quot;</span>]  </span><br><span class="line">            <span class="comment">#递归处理子节点  </span></span><br><span class="line">            squarifyTree(_x,_y,_dx,_dy,_n,path,level+<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">treemapTree</span>(<span class="params">x,y,dx,dy,node,display_key,display_con</span>):  </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">    入口函数  </span></span><br><span class="line"><span class="string">    :param x: 从(x,y)点开始排列(或理解为画布左下角的x坐标)  </span></span><br><span class="line"><span class="string">    :param y: 从(x,y)点开始排列(或理解为画布左下角的y坐标)  </span></span><br><span class="line"><span class="string">    :param dx: 总横向距离（或理解为画布的横向距离）  </span></span><br><span class="line"><span class="string">    :param dy: 总横向距离（或理解为画布的纵向距离）  </span></span><br><span class="line"><span class="string">    :param node: 根节点  </span></span><br><span class="line"><span class="string">    :param display_key: 可视化key，可视化节点的key值，可以是权重或地区名，根据不同需求  </span></span><br><span class="line"><span class="string">    :param display_con: 可视化信息显示条件，可选leaf:仅显示叶节点 root:仅显示根节点  </span></span><br><span class="line"><span class="string">    :return:  </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>    </span><br><span class="line">    path = []  </span><br><span class="line">    squarifyTree(x, y, dx, dy, node, path, <span class="number">0</span>)  </span><br><span class="line">    display_tree(path, x, y, dx, dy,display_key,display_con)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display_tree</span>(<span class="params">rec_lst,x=<span class="number">0</span>,y=<span class="number">0</span>,dx=<span class="number">1</span>,dy=<span class="number">1</span>,display_key=<span class="string">&#x27;v&#x27;</span>,display_con=<span class="string">&#x27;leaf&#x27;</span></span>):  </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">    树型可视化  </span></span><br><span class="line"><span class="string">    :param rec_lst: 矩形列表  </span></span><br><span class="line"><span class="string">    :param x: 画布左下角x坐标  </span></span><br><span class="line"><span class="string">    :param y: 画布左下角y坐标  </span></span><br><span class="line"><span class="string">    :param dx: 画布横向距离  </span></span><br><span class="line"><span class="string">    :param dy: 画布纵向距离  </span></span><br><span class="line"><span class="string">    :param display_key: 可视化信息的key，可视化节点的key值，可以是权重或地区名根据不同需求  </span></span><br><span class="line"><span class="string">    :param display_con: 可视化信息显示条件，可选leaf:仅显示叶节点 root:仅显示根节点  </span></span><br><span class="line"><span class="string">    :return:  </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>    </span><br><span class="line">    fig, ax = plt.subplots(figsize=(<span class="number">20</span>,<span class="number">12</span>))  </span><br><span class="line">    max_level = <span class="built_in">max</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x[<span class="string">&quot;level&quot;</span>],rec_lst))  </span><br><span class="line">    <span class="keyword">for</span> rectangle <span class="keyword">in</span> rec_lst[::-<span class="number">1</span>]:  </span><br><span class="line">        _x = rectangle[<span class="string">&#x27;x&#x27;</span>]  </span><br><span class="line">        _y = rectangle[<span class="string">&#x27;y&#x27;</span>]  </span><br><span class="line">        _dx = rectangle[<span class="string">&#x27;dx&#x27;</span>]  </span><br><span class="line">        _dy = rectangle[<span class="string">&#x27;dy&#x27;</span>]  </span><br><span class="line">        _v = rectangle[<span class="string">&#x27;v&#x27;</span>]  </span><br><span class="line">        _level = rectangle[<span class="string">&#x27;level&#x27;</span>]  </span><br><span class="line">        _is_leaf = rectangle.get(<span class="string">&#x27;is_leaf&#x27;</span>)  </span><br><span class="line">        rect = Rectangle((_x, _y), _dx, _dy, edgecolor=(<span class="number">70</span>/<span class="number">255</span>,<span class="number">130</span>/<span class="number">255</span>,<span class="number">180</span>/<span class="number">255</span>) , fill=<span class="literal">False</span>,linewidth = (max_level+<span class="number">1</span>-_level))  </span><br><span class="line">        ax.add_patch(rect)  </span><br><span class="line">        <span class="keyword">if</span> display_con==<span class="string">&#x27;leaf&#x27;</span>:  </span><br><span class="line">            <span class="keyword">if</span> _is_leaf:  </span><br><span class="line">                ax.text(_x+_dx/<span class="number">2</span>, _y+_dy/<span class="number">2</span>, rectangle.get(display_key,<span class="string">&#x27;&#x27;</span>), ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;center&#x27;</span>,fontsize=<span class="number">14</span>,fontname=<span class="string">&#x27;SimSun&#x27;</span>)  </span><br><span class="line">        <span class="keyword">if</span> display_con==<span class="string">&#x27;root&#x27;</span>:  </span><br><span class="line">            <span class="keyword">if</span> _level == <span class="number">0</span>:  </span><br><span class="line">                ax.text(_x + _dx / <span class="number">2</span>, _y + _dy / <span class="number">2</span>, rectangle.get(display_key, <span class="string">&#x27;&#x27;</span>), ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;center&#x27;</span>, fontsize=<span class="number">14</span>, fontname=<span class="string">&#x27;SimSun&#x27;</span>)  </span><br><span class="line">    ax.set_xlim(x, dx)  </span><br><span class="line">    ax.set_ylim(y, dy)  </span><br><span class="line">  </span><br><span class="line">    plt.gca().set_aspect(<span class="string">&#x27;equal&#x27;</span>, adjustable=<span class="string">&#x27;box&#x27;</span>)  </span><br><span class="line">    plt.savefig(<span class="string">&quot;output.png&quot;</span>, dpi=<span class="number">100</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>, pad_inches=<span class="number">0.1</span>, transparent=<span class="literal">False</span>)  </span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><blockquote><p>输入</p></blockquote><p><img src="/../../img/Pasted%20image%2020231104151638.png"></p><blockquote><p>可视化效果</p></blockquote><p><img src="/../../img/Pasted%20image%2020231104151026.png"></p><blockquote><p>输入China.js中国地区信息，效果如下</p></blockquote><p><img src="/../../img/output%203.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><ul><li>改进了[1]中提到的Squarify treemap算法，并增加了颜色透明度变化来体现节点权重大小。</li><li>实现的SquarifyPlus和Squarify算法具备复用性，Nested Tree-Map是通过递归调用上述代码实现的。</li></ul><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ul><li>可视化的效果还可以进一步改进，如：<ul><li>使用颜色透明度变化，阴影效果改进层次关系。</li><li>树型效果不明显，通过边框的粗细来反映层次结构效果略差，未来可进一步使用论文中提及的阴影效果。但Matplotlib可视化库没有相关实现，考虑改用d3.js</li></ul></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Bruls, Mark, Kees Huizing, and Jarke J. Van Wijk. “Squarified treemaps.” In Data Visualization 2000, pp. 33-42. Springer, Vienna, 2000.<br>[2] Balzer, Michael, and Oliver Deussen. “Voronoi treemaps.” In IEEE Symposium on Information Visualization, 2005. INFOVIS 2005., pp. 49-56. IEEE, 2005.</p><p>一些失败版本：字体，边框，颜色不合适<br><img src="/../../img/Pasted%20image%2020231103194827.png"><br><img src="/../../img/Pasted%20image%2020231103203047.png"></p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程 </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>On the Robustness of Code Generation Techniques:An Empirical Study on GitHub Copilot</title>
      <link href="/posts/98da000b/"/>
      <url>/posts/98da000b/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>背景：我们在让大模型帮我们生成代码的时候，不同的需求描述对于模型生成的代码影响有多大。换个描述很可能会生成完全不同的结果。</p><p>研究目的：对于代码生成模型（以Github Copilot为例），不同但语义等效的自然语言描述是否会产生相同的推荐功能（代码）。</p><p>测试方法：892个Java methods来自1401个开源项目，将方法上方的注释作为输入给模型</p><p>生成释义的自动化工具：PEGASUS and TP</p><p>原始释义-一组语义等效的释义描述（使用PEGASUS and TP生成）</p><p>解释一下自动释义技术</p><ul><li><p>PEGASUS</p></li><li><p>TP</p></li></ul><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>问题：</p><ul><li>RQ0:自动释义技术可以在多大程度上用于测试基于深度学习的代码生成器的鲁棒性？</li><li>RQ1:GitHub Copilot 的输出在多大程度上受到开发人员作为输入提供的代码描述的影响？</li></ul><p>&lt;method,code_description&gt;</p><p>892个方法：<br><img src="/../../img/Pasted%20image%2020231008222237.png"><br>TP：只生成792个有效释义，其中非等效占比<br>PEGASUS：生成891个有效释义，其中非等效占比<br>手工：认为全部有效，且等效892</p><p>一共：792+891+892&#x3D;2575   原始释义892 共2575+892&#x3D;3467，两个上下文场景* 2&#x3D;6934次调用</p><h1 id="研究结果"><a href="#研究结果" class="headerlink" title="研究结果"></a>研究结果</h1><p>RQ0:</p><p>RQ1:</p><h1 id="局限性："><a href="#局限性：" class="headerlink" title="局限性："></a>局限性：</h1><ul><li>通过测试未必意味着生成代码的正确，使用CodeBLEU和编辑距离</li><li>自动化模拟脚本不能够完全代替模型对于开发者的帮助，开发人员也许会参考模型生成的结果后，灵活变通。</li><li>在判断语义等效性时，作者的主观性</li><li>892个数据集中可能部分已经被用于训练copilot，导致结果的不准确</li><li>仅考虑了Java语言</li></ul><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul><li>46%情况下，不同但语义相同的描述会导致生成代码的不同。</li><li>目前代码生成模型效果一般，仅有13%的生成代码能够通过测试，但作者说了（一部分原因是选取的待生成方法比较复杂，见图，圈复杂度等）</li><li>要让模型输出正确的代码，必须使用语义等效的描述之一（不好把控，评价指标没说）</li><li>提高开发者对代码的描述准确性</li><li>对DWF来说，如果内嵌AI助手，更需要用户能够准确的提供他们的需求&#x2F;描述以获得期望的结果。</li><li>最佳实践：可以尝试输入给模型多种不同但意思相近的描述，对比生成的结果，选最佳的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大模型 </tag>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lang Chain介绍</title>
      <link href="/posts/887510fe/"/>
      <url>/posts/887510fe/</url>
      
        <content type="html"><![CDATA[<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>JS版：<a href="https://github.com/langchain-ai/langchainjs">langchain-ai&#x2F;langchainjs (github.com)</a><br>Python版：<a href="https://github.com/langchain-ai/langchain">langchain-ai&#x2F;langchain: ⚡ Building applications with LLMs through composability ⚡ (github.com)</a></p><p>论文链接：<br><a href="https://arxiv.org/pdf/2205.10583.pdf">Automated Repair of Programs from Large Language Models</a><br><a href="https://arxiv.org/pdf/2210.14179.pdf">Practical Program Repair in the Era of Large Pre-trained Language Models</a><br><a href="https://arxiv.org/pdf/2302.06144v2.pdf">SKCODER: A Sketch-based Approach for Automatic Code Generation</a><br><a href="https://arxiv.org/pdf/2302.03482.pdf">Keeping Pace with Ever-Increasing Data: Towards Continual Learning of Code Intelligence Models</a><br><a href="https://arxiv.org/pdf/2302.05020.pdf">Impact of Code Language Models on Automated Program Repair</a><br>[An Empirical Study of Pre-Trained Model Reuse in the Hugging Face Deep Learning Model Registry](<a href="https://arxiv.org/pdf/2303.02552.pdf">https://arxiv.org/pdf/2303.02552.pdf</a><br><a href="https://arxiv.org/pdf/2302.04030.pdf">CrossCodeBench: Benchmarking Cross-Task Generalization of Source Code Models</a><br><a href="https://arxiv.org/pdf/2302.00438.pdf">On the Robustness of Code Generation Techniques: An Empirical Study on GitHub Copilot</a></p><p>Use case：<br><a href="https://python.langchain.com/docs/use_cases/code_understanding">Code understanding | 🦜️🔗 Langchain</a><br><a href="https://python.langchain.com/docs/use_cases/extraction">Extraction | 🦜️🔗 Langchain</a><br><a href="https://python.langchain.com/docs/use_cases/qa_structured/sql">SQL | 🦜️🔗 Langchain</a></p><p><a href="https://github.com/chatchat-space/Langchain-Chatchat">chatchat-space&#x2F;Langchain-Chatchat: Langchain-Chatchat（原Langchain-ChatGLM）基于 Langchain 与 ChatGLM 等语言模型的本地知识库问答 | Langchain-Chatchat (formerly langchain-ChatGLM), local knowledge based LLM (like ChatGLM) QA app with langchain (github.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install langchain[llms]</span><br></pre></td></tr></table></figure><p><img src="/../../img/Pasted%20image%2020231012194922.png"></p><h1 id="Langchain-Next-js本地部署"><a href="#Langchain-Next-js本地部署" class="headerlink" title="Langchain+Next.js本地部署"></a>Langchain+Next.js本地部署</h1><blockquote><p>使用LangChain.js + Next.js 构建的LangChain入门Demo模板。它展示了如何在多个用例中使用和组合 LangChain 模块。具体如下：</p></blockquote><ul><li><a href="https://github.com/langchain-ai/langchain-nextjs-template/blob/main/app/api/chat/route.ts">【聊天互动】Simple chat</a></li><li><a href="https://github.com/langchain-ai/langchain-nextjs-template/blob/main/app/api/chat/structured_output/route.ts">【LLM调用的结构化输出】Returning structured output from an LLM call</a></li><li><a href="https://github.com/langchain-ai/langchain-nextjs-template/blob/main/app/api/chat/agents/route.ts">【使用自主AI代理处理复杂多步骤问题】Answering complex, multi-step questions with agents</a></li><li><a href="https://github.com/langchain-ai/langchain-nextjs-template/blob/main/app/api/chat/retrieval/route.ts">【检索增强生成】Retrieval augmented generation (RAG) with a chain and a vector store</a></li><li><a href="https://github.com/langchain-ai/langchain-nextjs-template/blob/main/app/api/chat/retrieval_agents/route.ts">Retrieval augmented generation (RAG) with an agent and a vector store</a></li></ul><blockquote><p>环境要求：Node.js&gt;18</p></blockquote><h2 id="0-背景介绍"><a href="#0-背景介绍" class="headerlink" title="0.背景介绍"></a>0.背景介绍</h2><h3 id="Next-js"><a href="#Next-js" class="headerlink" title="Next.js"></a>Next.js</h3><ul><li>基于React 的开发框架</li><li>使用react作为前端框架底层的支持SSR(请求时渲染)、SSG(构建时渲染)等技术的全栈框架</li><li>提供了一种简单而强大的方式来构建服务器渲染的应用程序</li></ul><h2 id="1-克隆项目"><a href="#1-克隆项目" class="headerlink" title="1.克隆项目"></a>1.克隆项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/langchain-ai/langchain-nextjs-template</span><br></pre></td></tr></table></figure><h2 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2.环境准备"></a>2.环境准备</h2><p>配置nodejs，版本要求&gt;18，如使用的旧版本，则需要下载新版本，然后可以进行<strong>多版本NodeJS的配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>配置OpenAI的Api Key<br>接下来，需要在存储库的 <code>.env.local</code> 文件中设置环境变量。将 <code>.env.example</code> 文件复制到 <code>.env.local</code> 。要从基本示例开始，您只需添加 OpenAI API 密钥，您可以在<a href="https://platform.openai.com/account/api-keys">此处</a>找到该密钥。<br><img src="/../../img/Pasted%20image%2020231017195818.png"></p><h2 id="3-启动项目"><a href="#3-启动项目" class="headerlink" title="3.启动项目"></a>3.启动项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install &amp; npm run dev</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">yarn &amp; yarn dev</span><br></pre></td></tr></table></figure><h2 id="4-改造项目"><a href="#4-改造项目" class="headerlink" title="4.改造项目"></a>4.改造项目</h2><h3 id="聊天功能"><a href="#聊天功能" class="headerlink" title="聊天功能"></a>聊天功能</h3><blockquote><p>附带历史（History）聊天记录的聊天模型</p></blockquote><p>由于调用<code>openAI</code>具有网络限制，因此先将LLM(ChatModel)改为<code>文心一言</code>。</p><p>获取文心一言的API key和Secret Key。链接：<a href="https://console.bce.baidu.com/qianfan/ais/console/applicationConsole/application">百度云控制台</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在.env.local文件中配置百度云API Key</span></span><br><span class="line">BAIDU_API_KEY=<span class="string">&quot;OItDxxxxL43xxxx89xxxx&quot;</span>  </span><br><span class="line">BAIDU_SECRET_KEY=<span class="string">&quot;e7Ifg5FTHYxxxx847BkypNGzSxxxx&quot;</span></span><br></pre></td></tr></table></figure><p>修改源代码&#96;\app\api\chat\route.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * try BaiduWenxin </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> model = <span class="keyword">new</span> <span class="title class_">ChatBaiduWenxin</span>(&#123;  </span><br><span class="line">  <span class="attr">temperature</span>: <span class="number">0.8</span>,  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>修改提示模板</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const TEMPLATE = `You are a pirate named Patchy. All responses must be extremely verbose and in pirate dialect.  </span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">TEMPLATE</span> = <span class="string">`You are a senior software engineer.</span></span><br></pre></td></tr></table></figure><p>聊天模型测试<br><img src="/../../img/Pasted%20image%2020231018145829.png"></p><h3 id="结构化输出"><a href="#结构化输出" class="headerlink" title="结构化输出"></a>结构化输出</h3><p><a href="https://js.langchain.com/docs/modules/chains/popular/structured_output">Structured Output with OpenAI functions | 🦜️🔗 Langchain</a></p><blockquote><p>目前仅支持使用OpenAI进行函数调回。_<em>Function calling is currently only supported with ChatOpenAI models</em>_</p></blockquote><p>功能：根据预定义的<code>schema</code>模板和用户的输入生成结构化数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用流行的 Zod 模式库定义输出模式</span></span><br><span class="line"><span class="keyword">const</span> schema = z.<span class="title function_">object</span>(&#123;  </span><br><span class="line">  <span class="attr">tone</span>: z  </span><br><span class="line">    .<span class="title function_">enum</span>([<span class="string">&quot;positive&quot;</span>, <span class="string">&quot;negative&quot;</span>, <span class="string">&quot;neutral&quot;</span>])  </span><br><span class="line">    .<span class="title function_">describe</span>(<span class="string">&quot;The overall tone of the input&quot;</span>),  </span><br><span class="line">  <span class="attr">entity</span>: z.<span class="title function_">string</span>().<span class="title function_">describe</span>(<span class="string">&quot;The entity mentioned in the input&quot;</span>),  </span><br><span class="line">  <span class="attr">word_count</span>: z.<span class="title function_">number</span>().<span class="title function_">describe</span>(<span class="string">&quot;The number of words in the input&quot;</span>),  </span><br><span class="line">  <span class="attr">chat_response</span>: z.<span class="title function_">string</span>().<span class="title function_">describe</span>(<span class="string">&quot;A response to the human&#x27;s input&quot;</span>),  </span><br><span class="line">  <span class="attr">final_punctuation</span>: z  </span><br><span class="line">    .<span class="title function_">optional</span>(z.<span class="title function_">string</span>())  </span><br><span class="line">    .<span class="title function_">describe</span>(<span class="string">&quot;The final punctuation mark in the input, if any.&quot;</span>),  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述定义的<code>schema</code>定义了：</p><ul><li>tone：文本情感，枚举类 positive negative neutral</li><li>entity：实体，字符串型，提取<code>input</code>中的实体类</li><li>word_count：单词数量，数值类，获取<code>input</code>中的单词数量</li><li>chat_response：对话回答，字符串类，对<code>input</code>的回答（相当于chat模型）</li><li>final_punctuation：最后标点，（可选）字符串类，提取<code>input</code>中最后的标点符号</li></ul><p>Example：<code>input</code>&#x3D;”What a beautiful day!”<br>AI返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;tone&quot;</span><span class="punctuation">:</span><span class="string">&quot;positive&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;entity&quot;</span><span class="punctuation">:</span><span class="string">&quot;day&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;word_count&quot;</span><span class="punctuation">:</span><span class="number">4</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;chat_response&quot;</span><span class="punctuation">:</span><span class="string">&quot;Yes, it is a beautiful day indeed!&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;final_punctuation&quot;</span><span class="punctuation">:</span><span class="string">&quot;!&quot;</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/../../img/Pasted%20image%2020231018151626.png"></p><p>应用：DWF中实体类的生成。指定需要生成的JSON格式</p><p>使用百度千帆作为大模型会报错，不支持函数调用。<br><img src="/../../img/Pasted%20image%2020231022095541.png"></p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><blockquote><p>目前仅OpenAI支持。Must be used with an <a href="https://platform.openai.com/docs/guides/gpt/function-calling">OpenAI Functions</a> model. </p></blockquote><p>有些应用需要根据用户输入灵活调用 LLM 和其他<strong>工具</strong>。代理接口为这类应用提供了灵活性。代理可以使用一整套工具，并根据用户输入决定使用哪些工具。代理可以使用多种工具，并将一种工具的输出作为下一种工具的输入。</p><h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><blockquote><p>可根据文档信息，进行检索。如Q&amp;A according to documents</p></blockquote><h3 id="检索代理"><a href="#检索代理" class="headerlink" title="检索代理"></a>检索代理</h3><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="JavaScript部署"><a href="#JavaScript部署" class="headerlink" title="JavaScript部署"></a>JavaScript部署</h2><hr><blockquote><p>可能有两种方式：Node.js作为后端部署 &#x2F; 集成在DWF前端的Vue框架中使用作为前端部署</p></blockquote><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><ul><li>一般不使用node作为后端，这样还不如直接用Python部署。</li></ul><h3 id="前端集成"><a href="#前端集成" class="headerlink" title="前端集成"></a>前端集成</h3><p>优点：</p><ul><li>Vue中集成，直接运行在用户浏览器，不需要考虑大量访问的问题，无后端开销。除非同一个Api_Key在同一时间被大量使用（但根据上次河北教育厅培训，好像百度讯飞模型问题不大）</li><li>更灵活，也能支持用户根据需求改造langchain，拓展性好。</li><li>可能的跨域问题，网络是根据用户环境的或无法访问OpenAI、Vercel等服务</li></ul><p>缺点：</p><ul><li>安全性差，Api_Key管理（多人共享一个&#x2F;一人一个自己申请？）和获取方式（环境变量&#x2F;通过api调用后端返回）；前端Api_Key均有泄露风险</li><li>数据处理和机器学习库的支持相对较差。</li></ul><h2 id="Python部署"><a href="#Python部署" class="headerlink" title="Python部署"></a>Python部署</h2><hr><p>优点：</p><ul><li>部署在后端，前端通过API调用即可，相对安全。</li><li>Python拥有强大的数据处理和机器学习库支持，可进一步拓展langChain功能</li></ul><p>缺点：</p><ul><li>DWF后端是Java语言，LangChain目前还没有Java版本，涉及到技术异构(Flask,Django等)的难点。部署LangChain的话需要另开一个服务单独部署。（管理起来可能比较麻烦？）</li><li>性能相对较差，当大量用户并发调用后端LangChain服务时，容易崩。</li></ul><h3 id="LLM模型选择"><a href="#LLM模型选择" class="headerlink" title="LLM模型选择"></a>LLM模型选择</h3><ul><li>LangChain有部分功能(function call等)仅支持OpenAI，OpenAI的访问需要代理🧱。选择OpenAI的话部署的时候需要处理网络环境。</li></ul><p>Flowise 和 LangFlow 是两个不同的工具，用于自然语言处理和对话流程设计。它们各有优势和适用场景。</p><p>Flowise 是一个强大的自然语言处理平台，可以帮助开发者构建智能对话系统。它提供了丰富的语义理解和对话管理功能，可以处理复杂的对话场景，并支持多轮对话和上下文理解。Flowise 还提供了一些预训练的模型和工具，可以加速对话系统的开发过程。</p><p>LangFlow 是一个对话流程设计工具，它专注于对话流程的可视化设计和管理。LangFlow 提供了直观的界面和工具，可以帮助开发者设计和管理对话流程，包括对话节点、条件逻辑和回复等。LangFlow 还支持多语言和多渠道的对话流程设计。</p><p>因此，选择使用哪个工具取决于具体的需求和使用场景。如果需要构建复杂的对话系统，并且需要强大的语义理解和对话管理功能，那么 Flowise 可能更适合。如果只需要设计和管理对话流程，并且更注重可视化和易用性，那么 LangFlow 可能更适合。</p><p><a href="https://zhuanlan.zhihu.com/p/650485950">零代码GPT：Flowise VS langflow - 知乎 (zhihu.com)</a><br><a href="https://zhuanlan.zhihu.com/p/651979964">我们分析了352个使用了Langchain的项目，渗透GPT，开源codeInterpreter平替，GPT销售等12个项目串讲 - 知乎 (zhihu.com)</a></p><p>LocalAI</p><p>docker desktop</p>]]></content>
      
      
      <categories>
          
          <category> 大模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824</title>
      <link href="/posts/1906f3d9/"/>
      <url>/posts/1906f3d9/</url>
      
        <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="/../../../../img/Pasted%20image%2020231009101529.png"></p><h1 id="Lecture01-Introduce"><a href="#Lecture01-Introduce" class="headerlink" title="Lecture01 - Introduce"></a>Lecture01 - Introduce</h1><h2 id="MapReduce论文"><a href="#MapReduce论文" class="headerlink" title="MapReduce论文"></a>MapReduce论文</h2><p><img src="/../../../../img/Pasted%20image%2020230929130402.png"></p><p>过程：</p><ul><li>将用户输入的文件分成<code>M块</code>，每块大小为16MB-64MB（可由用户指定）。</li><li>由Master节点分配工作给其他Worker节点，包括<code>M个map任务</code>和<code>R个reduce任务</code>。</li><li>被分配了map任务的节点解析数据，生成&lt;key,value&gt;然后放入<code>内存缓冲区</code>。</li><li>被缓冲的键值对周期性地写入磁盘，然后被划分为<code>R个块（Hash(key) mod R）</code>，他们在磁盘上的位置被发送给Master,然后Master转发给Worker节点进行reduce任务。</li><li>当节点收到master关于这些位置的通知时，他会使用RPC读取磁盘中的数据，当读取完所有中间数据时，进行<code>排序</code>操作来保证相同的键组合在一起。</li><li>Reduce函数对已排序的中间数据进行迭代，其输出附加到Reduce分区的output文件中。</li><li>当<code>M个map</code>和<code>R个reduce</code>任务运行完毕后，返回至用户代码，整个过程结束。</li></ul><p>数据结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Task:</span><br><span class="line">taskId:</span><br><span class="line">type:map/reduce</span><br><span class="line">state:idle/in-progress/completed</span><br><span class="line">machineId:</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Lecture02-Infrastructure-RPC-and-threads"><a href="#Lecture02-Infrastructure-RPC-and-threads" class="headerlink" title="Lecture02 - Infrastructure: RPC and threads"></a>Lecture02 - Infrastructure: RPC and threads</h1><p>Why Go?</p><ul><li>强大的多线程</li><li>便捷的RPC</li><li>类型安全</li><li>内存安全（垃圾回收机制）</li><li>简单</li></ul><p>Why threads?</p><ul><li>并发在分布式系统中的必要性</li><li>利用CPU的多核性能</li><li>便利性</li><li>I&#x2F;O并发</li></ul><p>挑战性：</p><ul><li>共享数据：加锁（sync.Mutex或避免共享可变数据）</li><li>线程之间的协调</li><li>死锁：锁机制或通信</li></ul><p>Go语言并发编程<br><a href="https://blog.csdn.net/weixin_45765795/article/details/121185893">【并发编程】WaitGroup 基本用法和如何实现以及常见错误-CSDN博客</a></p><h1 id="Lecture03-GFS"><a href="#Lecture03-GFS" class="headerlink" title="Lecture03 - GFS"></a>Lecture03 - GFS</h1><h2 id="GFS论文"><a href="#GFS论文" class="headerlink" title="GFS论文"></a>GFS论文</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>用于大型分布式数据密集型应用的可伸缩分布式文件系统。</p><ul><li>组件的失败和错误是非常常见的。因此持续的监控，错误检测，容错和自动恢复是必须的</li><li>文件通常是巨大的，需要重新设计I&#x2F;O操作和块大小。</li><li>文件访问模式，顺序访问。需要优化追加写入和原子性。</li><li>放宽一致性和原子追加操作</li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p><img src="/../../../../img/Pasted%20image%2020231009195026.png"></p><ul><li>一个GFS集群由一个master和多个分块服务器（chunkserver）组成</li><li>文件以固定大小的块存储，块由全局唯一的64位ID标识，默认情况下每个区块具有三个副本。</li><li>master存储所有文件的元信息，包括名称空间、访问控制信息、文件到块的映射以及块的当前位置。</li><li>master定期使用心跳信息与块交流，提供指令和收集状态。</li><li>链接到每个应用程序中的GFS客户端代码实现文件系统API，并与主服务器和分块服务器通信，以代表应用程序读取或写入数据。</li><li>客户端和分块服务器不缓存文件数据。</li><li>客户端会询问master该和哪个分块服务器交互，然后直接与分块服务器读取和写入数据。</li></ul><p>交互过程：</p><ol><li>客户端通过指定的文件名和字节偏移量转化为<code>(file name,chunk index)</code>，并发送给master。</li><li>master回复相应的区块句柄和区块位置。</li><li>客户端在一定时间内缓存<code>(file name,chunk index)</code>，一便后续使用</li><li>客户端向其中的一个副本（距离最近优先）发送<code>(chunk handle,byte range)</code>请求。</li><li>在缓存有效期内，对同一块的访问不需重复请求master。</li></ol><p>master存储的元信息（位于master的内存中）：</p><ul><li>文件和块命名空间</li><li>文件到块映射信息</li><li>每个块副本的位置信息</li></ul><p>前两种还会以操作日志并保存到远程计算机上来避免master发生崩溃和不一致。每个块的信息则不会持久存储。</p><h3 id="系统交互"><a href="#系统交互" class="headerlink" title="系统交互"></a>系统交互</h3><p><img src="/../../../../img/Pasted%20image%2020231011192431.png"></p><ol><li>客户端询问master哪个 chunkserver 持有该块的当前租约以及其他副本的位置。如果没有人拥有租约，主服务器会将租约授予它选择的副本（未显示）。</li><li>master回复主副本的身份和其他（次级）副本的位置。客户端缓存此数据以供将来的突变使用。仅当主副本不可达或不再持有租约的情况下，客户端需要再次联系master。</li><li>客户端推送data给所有的副本，块服务器会将数据缓存在内部LRU，直到数据被使用或过期。</li><li>一旦所有副本确认已收到数据，客户端就会像主副本发送写入请求。该请求标识先前推送到所有复制副本的数据。主副本将连续的序列号分配给它接收到的所有突变(可能来自多个客户端)。这提供了必要的序列化。它将突变按序列号顺序应用于自己的局部状态。</li><li>主副本将写入请求转发到所有次级副本。每个次级副本都按照主副本指定的相同序列号顺序应用突变。</li><li>次级副本会回复主副本，表示操作已经完成。</li><li>主副本回复客户端，过程中发生的任何错误都会报告给客户端。如果出现错误，可能在主副本或者部分次级副本的上是成功的。 （如果它在主服务器上失败，则不会为其分配序列号并转发。）客户端请求被视为失败，并且修改的区域将处于不一致状态。我们的客户端代码通过重试失败的突变来处理此类错误。它将在步骤 (3) 到 (7) 中进行几次尝试，然后返回到从写入开始处重试。</li></ol><h3 id="Master操作"><a href="#Master操作" class="headerlink" title="Master操作"></a>Master操作</h3><h4 id="命名空间管理和锁"><a href="#命名空间管理和锁" class="headerlink" title="命名空间管理和锁"></a>命名空间管理和锁</h4><ul><li>使用锁和串行来支持多个操作</li><li>读锁和写锁，若涉及&#x2F;d1&#x2F;d2&#x2F;leaf，则需要获取递归目录名的所有读锁，和&#x2F;d1&#x2F;d2&#x2F;leaf读锁或写锁</li><li>对目录上的读锁保证了操作的过程中，其目录不会被删除、重命名或快照。</li></ul><h4 id="副本放置"><a href="#副本放置" class="headerlink" title="副本放置"></a>副本放置</h4><ul><li>通常有数百个块服务器分布在许多机器机架上。这些块服务器又可以从相同或不同机架的数百个客户端访问。</li><li>块副本放置策略有两个目的：最大化数据可靠性和可用性，以及最大化网络带宽利用率。</li></ul><h4 id="创建、重新复制、重新平衡"><a href="#创建、重新复制、重新平衡" class="headerlink" title="创建、重新复制、重新平衡"></a>创建、重新复制、重新平衡</h4><ul><li>创建块副本的原因有三个：块创建、重新复制和重新平衡。</li><li>创建目标考虑因素：磁盘空间利用率、“最近”创建的数量、将块的副本分布在机架上</li><li>一旦可用副本的数量低于用户指定的目标，主服务器就会重新复制块。</li><li>主节点选择最高优先级的块，并通过指示某些块服务器直接从现有的有效副本复制块数据来“克隆”它。复制的考虑因素同创建目标</li><li>它检查当前的副本分布并移动副本以获得更好的磁盘空间和负载平衡。</li></ul><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>当文件删除后，GFS 不会立即回收可用的物理存储。它仅在文件和块级别的常规垃圾收集期间延迟执行此操作。</p><ul><li>文件被重命名为一个隐藏的名称，包含了删除时间</li><li>当master扫描文件系统命名空间时，会删除存在超过三天的该类隐藏名称的文件。在此之前这类待删除文件可以被访问或撤销删除，通过其特殊的隐藏名称</li><li>无法从任何文件到达的孤儿块也会被master检测，并在HeartBeat期间，发送给块服务器，通知他们自行删除。</li></ul><p>优势：</p><ul><li>在组件故障频发的大规模分布式系统中，它简单可靠。</li><li>分批进行，成本摊销。</li><li>延迟回收存储提供了一个安全网，防止意外的、不可逆转的删除。</li></ul><p>劣势：</p><ul><li>不利于存储空间紧张的情况，因为删除不是立刻的，不会立马释放物理存储空间</li><li>可通过再次删除和不同的复制和再生机制</li></ul><h4 id="过期副本的检测"><a href="#过期副本的检测" class="headerlink" title="过期副本的检测"></a>过期副本的检测</h4><ul><li>块服务器宕机时，副本的修改可能失败，因此变为过期副本</li><li>master通过版本号判断副本过期与否</li><li>master移除过期的副本在其垃圾回收过程中。</li></ul><h3 id="容错和检测"><a href="#容错和检测" class="headerlink" title="容错和检测"></a>容错和检测</h3><h4 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h4><ul><li>快恢复：master和chunkserver都被设计为恢复它们的状态并在几秒钟内启动，无论它们是如何终止的。</li><li>块复制：每个区块都在不同机架上的多个区块服务器上进行复制。</li><li>Master复制：它的操作日志和检查点在多台计算机上复制。</li></ul><h4 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h4><ul><li>块服务器使用校验和验证数据的合法性</li><li>每个64KB的块使用32bit的校验和，保存在内存中，通过日志记录持久存储</li><li>对于读取，都会验证数据块的校验和。若不一致，块服务器会返回一个错误，作为响应，请求者将从其他副本中读取，而主机将从另一个副本中克隆区块。在一个有效的新复制副本就位后，主服务器指示报告不匹配的chunkserver删除其复制副本。</li><li>块服务器会在空闲时刻扫描块的有效性。若检测到损坏，则会复制并删除原有的块。</li></ul><h4 id="诊断工具"><a href="#诊断工具" class="headerlink" title="诊断工具"></a>诊断工具</h4><ul><li>GFS服务器生成诊断日志，记录许多重要事件（如chunkserver运行和关闭）以及所有RPC请求和回复。</li><li></li></ul><h3 id="衡量"><a href="#衡量" class="headerlink" title="衡量"></a>衡量</h3><h1 id="Lecture-04-VMware-FT"><a href="#Lecture-04-VMware-FT" class="headerlink" title="Lecture 04 - VMware FT"></a>Lecture 04 - VMware FT</h1><p>Fault tolerance：容错，使用<strong>复制</strong>提供可用性，尽管网络和服务器会发生错误<br>复制可以解决的问题：</p><ul><li>单个副本的 “故障停止 “故障：Cpu过热关机、副本网络故障、磁盘空间不足</li><li>不能解决副本之间具有相关联的问题：如同一批购买的服务器往往有同样的设计缺陷<br>是否值得复制：额外的副本往往需要付出X倍的成本，这是一个经济问题。取决于可用服务的价值，如银行系统那肯定值得复制，如网课平台就不需要有额外的副本</li></ul><p>状态转移和复制状态机<br>状态转移：Primary直接把自己的信息，如内存通过网络传输给Backup（往往是增量传输）<br>复制状态机：Primary把来自客户端的操作或其他外部事件传输给Backup.</p><p>复制状态机基于下述原理：通常来说，如果有两台计算机，如果它们从相同的状态开始，并且它们以相同的顺序，在相同的时间，看到了相同的输入，那么它们会一直互为副本，并且一直保持一致。</p><p>复制状态机如何解决例如具有随机性的操作或个体差异操作，如生成随机数&#x2F;获取当前系统时间&#x2F;获取CPU序列号。对于这一类问题的统一答案是，Primary会执行这些指令，并将结果发送给Backup。Backup不会执行这些指令，而是在应该执行指令的地方，等着Primary告诉它，正确的答案是什么，并将监听到的答案返回给软件。</p><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><p>[nil.csail.mit.edu&#x2F;6.824&#x2F;2020&#x2F;papers&#x2F;vm-ft.pdf](<a href="http://nil.csail.mit.edu/6.824/2020/papers/vm-ft.pdf">http://nil.csail.mit.edu/6.824/2020/papers/vm-ft.pdf</a><br><a href="https://zhuanlan.zhihu.com/p/523109983?utm_id=0">【译文】The Design of a Practical System for Fault-Tolerant Virtual Machines 一种主备容错方案的可行解 - 知乎 (zhihu.com)</a></p><p>VMware FT工作原理<br>VMM：虚拟机监控器，用于在硬件上模拟出多个虚拟的计算机，其中每一个都有自己的操作系统内核和应用程序。</p><p>VMware FT需要有两个物理服务器，将Primary和Backup运行在一台物理服务器的两个虚拟机里没有意义，达不到容错目的。通常这两个物理服务器上的VMM会为Primary和Backup分配镜像相同的内存和同样的操作系统<br><img src="/../../../../img/Pasted%20image%2020231029090925.png"><br><img src="/../../../../img/Pasted%20image%2020231030154726.png"><br>基本的工作流程：</p><ul><li>客户端向Primary发送请求，请求以网络数据包的形式发出</li><li>网络数据包产生中断，送到VMM。在虚拟机的guest操作系统中，模拟网络数据包到达的中断，以将相应的数据送给应用程序的Primary副本。除此之外，因为这是一个多副本虚拟机的输入，VMM会将网络数据包拷贝一份，并通过网络送给Backup虚机所在的VMM。</li><li>Primary生成回复报文，通过VMM在虚拟机内模拟的虚拟网卡发出，Backup也会生成同样的报文，但会丢弃。</li><li>当Primary因为故障停止运行，Backup就会成为Primary，进行接管</li></ul><p>非确定性事件的处理</p><h1 id="Lecture-05-Go、Threads"><a href="#Lecture-05-Go、Threads" class="headerlink" title="Lecture 05 - Go、Threads"></a>Lecture 05 - Go、Threads</h1><p>Goroutines和Closures<br>Goroutines：Go语言中的轻量级线程，并发运行，当main goroutine退出，程序终止</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//匿名函数 开启一个子goroutine,十秒后main goroutine结束，子goroutine自动退出</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(count)</span><br><span class="line">count++</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//console</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><p>Closures：闭包<br><a href="https://zhuanlan.zhihu.com/p/645853924">Go语言基础知识 —— Closure(闭包) - 知乎 (zhihu.com)</a></p><p>Time:</p><ul><li>time.Sleep()：使当前线程睡眠一段时间</li><li>可以在循环中使用，达成间隔x秒执行一次的效果<br>Mutexes:锁</li><li>mu.Lock():等待获取锁</li><li>mu.Unlock():解锁，一般结合defer使用，延迟一段时间后解锁</li><li><a href="https://zhuanlan.zhihu.com/p/527193688?utm_id=0">Go语言 WaitGroup 详解 - 知乎 (zhihu.com)</a></li></ul><p>Condition variables:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/rand&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">count := <span class="number">0</span></span><br><span class="line">finished := <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">cond := sync.NewCond(&amp;mu)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">vote := requestVote()</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> vote &#123;</span><br><span class="line">count++</span><br><span class="line">&#125;</span><br><span class="line">finished++</span><br><span class="line">cond.Broadcast()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">for</span> count &lt; <span class="number">5</span> &amp;&amp; finished != <span class="number">10</span> &#123;</span><br><span class="line">cond.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> count &gt;= <span class="number">5</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;received 5+ votes!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;lost&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestVote</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">100</span>)) * time.Millisecond)</span><br><span class="line"><span class="keyword">return</span> rand.Int() % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Channels: 管道，并发安全的队列</p><h1 id="Lecture-06-Raft"><a href="#Lecture-06-Raft" class="headerlink" title="Lecture 06 - Raft"></a>Lecture 06 - Raft</h1><p>论文：<br><a href="http://nil.csail.mit.edu/6.824/2020/papers/raft-extended.pdf">In Search of an Understandable Consensus Algorithm (mit.edu)</a><br><a href="https://zhuanlan.zhihu.com/p/524885008">【译文】Raft协议：In Search of an Understandable Consensus Algorithm (Extended Version) 大名鼎鼎的分布式共识算法 - 知乎 (zhihu.com)</a><br><img src="/../../../../img/Pasted%20image%2020231102133238.png"></p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>Consensus vs Consistency<br>一致性（consistency）往往指分布式系统中多个副本对外呈现的数据的状态。如顺序一致性、线性一致性，描述了多个节点对数据状态的维护能力。</p><p>共识（consensus）则描述了分布式系统中多个节点之间，彼此对某个提案达成一致结果的过程。</p><p>因此，一致性描述的是<strong>结果</strong>，共识则是一种<strong>手段</strong>。</p><p>子问题</p><ul><li>Leader election（领导选举）：一个 leader 倒下之后，一定会有一个新的 leader 站起来。</li><li>Log replication（日志复制）：leader 必须接收来自客户端的日志条目然后复制到集群中的其他节点，并且强制其他节点的日志和自己的保持一致。</li><li>Safety（安全性）：<br><img src="/../../../../img/Pasted%20image%2020231030202130.png"></li></ul><p>角色<br>一个Raft集群中包含若干个服务器节点，一般具有N个节点的集群，可以容忍(N-1)&#x2F;2个节点的失效，集群中的节点在任何时刻都是以下<strong>三种身份</strong>之一：</p><ul><li>Leader：领导，负责处理客户端请求（follower会将请求重定向到leader)</li><li>Follower：被动的，仅响应来自Leader和Candidate的请求（是节点的初始身份）</li><li>Candidate：候选人，用来选举成为新的leader时的临时态。</li></ul><p>一般情况下：集群只有<strong>1</strong>个<strong>leader</strong>,剩下的都是<strong>follower</strong>,其状态转换关系如下：<br><img src="/../../../../img/Pasted%20image%2020231030202859.png"></p><p>任期<br>Raft将时间划分为多个任期，并进行编号。每一段任期从一次选举开始，任意一个任期内最多有一名Leader。<br><img src="/../../../../img/Pasted%20image%2020231030203144.png"></p><p>任期在 Raft 中还扮演着一个逻辑时钟（logical clock）的角色，这使得服务器可以发现一些过期的信息，比如过时的 leader。</p><p>每一个节点都存储着一个当前任期号（current term number），该任期号会随着时间单调递增。节点之间通信的时候会交换当前任期号，如果一个节点的当前任期号比其他节点小，那么它就将自己的任期号更新为较大的那个值。如果一个 candidate 或者 leader 发现自己的任期号过期了，它就会立刻回到 follower 状态。如果一个节点接收了一个带着过期的任期号的请求，那么它会拒绝这次请求。</p><p>RPC</p><ul><li><strong>RequestVote RPCs（请求投票）</strong>：由 candidate 在选举过程中发出</li></ul><ul><li><strong>AppendEntries RPCs（追加条目）</strong>：由 leader 发出，用来做日志复制和提供心跳机制</li></ul><h2 id="领导选举"><a href="#领导选举" class="headerlink" title="领导选举"></a>领导选举</h2><p>Raft采用心跳机制来触发leader的选举。起初所有节点都是follower，每个节点都有一个<strong>不同</strong>的随机超时时间（一般是150~300ms）当收到来自其他leader或candidate那有效的RPC就会刷新自己的超时时间，并保持follower状态，但如果在一段时间内（即设置的超时时间<strong>election timeout</strong>）没有收到有效的RPC，则该节点会假定集群内当前没有可用的leader,那么他会尝试进行leader的选举（此时不立，更待何时）。</p><p><strong>选举流程</strong></p><ul><li>某follower节点达到了自己的超时时间，发起选举</li><li>增加任期号，并切换为candidate角色</li><li>给自己投票，并以<strong>并行</strong>的方式向其他节点发送RequestVote PRCs，请求给自己投票</li><li>选举结果可能如下：<ul><li>赢得了超过半数的票，成为leader，开启新一段任期</li><li>其他节点赢得了选举，变为follower</li><li>没有任何节点在选举中胜出（如果超时时间设置相同，那么所有节点在同一时间发起选举，把票都投给自己，发生了分票（split votes）现象）</li></ul></li></ul><p>当一个candidate获得了针对同一任期内超过一半的票，就成为新的leader，这保证了同一时期最多只能有一个candidate赢得选取，当赢得选取后，该leader会向其他节点发送心跳信息，保持自己的地位。</p><p><strong>选举约束</strong><br>不是所有followes都有资格成为leader的，当candidate向其他节点发送Request Vote Rpcs时，只有满足下面情况之一，followers才会投赞成票。</p><ul><li>candidate的最后一条log条目的term <strong>&gt;</strong> follower的最后一条log条目的term</li><li>candidate的最后一条log条目的term <strong>&#x3D;</strong> follower的最后一条log条目的term，但candidate的log条目记录的长度 <strong>&gt;&#x3D;</strong> follower<br>也就是说，raft更喜欢log最新最完整的候选人成为leader</li></ul><h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><p>Leader需要负责响应来自客户端的请求，每一个客户端的请求都包含一条将被复制状态机执行的指令。<br>日志复制过程：</p><ul><li>Leader会以新条目的形式将命令追加到自己的日志中</li><li>向其他节点发送AppendEntries RPCs，让他们复制。</li><li>当条目被安全地复制后，leader会将该条目应用到自己的状态机中，状态机执行该指令，然后将执行的结果返回给客户端。</li></ul><p>日志存储的方式：</p><ul><li>每条日志以（term，command）的二元组构成，用索引值index表示他在日志中的位置。</li><li>不同节点上，任期号term和索引值index相同的日志，其一定具有相同的command<br><img src="/../../../../img/Pasted%20image%2020231101193518.png"><br>我们设计 Raft 日志机制来使得不同节点上的日志之间可以保持高水平的一致性。这么做不仅简化了系统的行为也使得系统更加可预测，同时该机制也是保证安全性的重要组成部分。Raft 会一直维护着以下的特性，这些特性也同时构成了图 3 中的日志匹配特性（Log Matching Property）：</li><li>如果不同日志中的两个条目有着相同的索引和任期值，那么它们就存储着相同的命令</li><li>如果不同日志中的两个条目有着相同的索引和任期值，那么他们之前的所有日志条目也都相同</li></ul><p>日志的一致性检查<br>当leader发送一个AppendEntries RPCs时，leader还会附加一个上一条日志条目的索引位置和日期号在里面。当follower收到该RPCs后，如果在日志中找不到含有相同索引和任期号的日志条目，那么它就会拒绝，并回复leader。<br>leader在内部维护了对每一个follower的nextIndex，nextIndex给某个节点发送的下一日志条目的索引，当选出一个新的 leader 时，该 leader 将所有的 nextIndex 的值都初始化为自己最后一个日志条目的 index +1。如果一个 follower 的日志跟 leader 的是不一致的，那么下一次的 AppendEntries RPC 的一致性检查就会失败。AppendEntries RPC 在被 follower 拒绝之后，leader 对 nextIndex 进行减 1，然后重试 AppendEntries RPC。最终 nextIndex 会在某个位置满足 leader 和 follower 在该位置及之前的日志是一致的，此时，AppendEntries RPC 就会成功，将 follower 跟 leader 冲突的日志条目全部删除然后追加 leader 中的日志条目（需要的话）。一旦 AppendEntries RPC 成功，follower 的日志就和 leader 的一致了，并且在该任期接下来的时间里都保持一致。</p><p>通过上述机制，日志在AppendEntries的一致性检查时，就会自动趋于一致。</p><p>安全性</p><p>StartElection：<br>    1.超时<br>RequestVote<br>sendRequestVote<br>handleVoteResult</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Term <span class="type">int</span></span><br><span class="line">LeaderId    <span class="type">int</span></span><br><span class="line">PrevLogIndex<span class="type">int</span></span><br><span class="line">PrevLogTerm <span class="type">int</span></span><br><span class="line">Entries[]LogEntry</span><br><span class="line"><span class="comment">//for future</span></span><br><span class="line">LeaderCommit<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// example AppendEntries RPC reply structure.</span></span><br><span class="line"><span class="comment">// field names must start with capital letters!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Term <span class="type">int</span></span><br><span class="line">Success<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">mu        sync.Mutex          <span class="comment">// Lock to protect shared access to this peer&#x27;s state</span></span><br><span class="line">peers     []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">persister *Persister          <span class="comment">// Object to hold this peer&#x27;s persisted state</span></span><br><span class="line">me        <span class="type">int</span>                 <span class="comment">// this peer&#x27;s index into peers[]</span></span><br><span class="line">dead      <span class="type">int32</span>               <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line">currentTerm <span class="type">int</span></span><br><span class="line">role Role</span><br><span class="line">votedFor <span class="type">int</span></span><br><span class="line">log[]LogEntry</span><br><span class="line">nextTimeouttime.Time</span><br><span class="line">applyCh     <span class="keyword">chan</span> ApplyMsg</span><br><span class="line"></span><br><span class="line">n<span class="type">int</span></span><br><span class="line">voteCount<span class="type">int</span></span><br><span class="line"></span><br><span class="line">commitIndex <span class="type">int</span></span><br><span class="line">lastApplied <span class="type">int</span></span><br><span class="line"></span><br><span class="line">nextIndex   []<span class="type">int</span></span><br><span class="line">matchIndex  []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ticker</p><p>broadcastRPC:区分心跳和附加日志<br>    1.心跳<br>        当nextIndex还是matchIndex<br>        正常情况nextIndex[i] &#x3D;&#x3D; len[rf.log] &#x3D;&#x3D; matchIndex[i]+1<br>        表示i号节点不缺log了<br>    2.日志<br>        当nextIndex[i] &lt; len[rf.log]<br>AppendEntries<br>    1.比较任期<br>    if args.term&lt;rf.currentTerm:<br>        返回自己的任期和False，提醒leader自己已经过期。<br>    2.判断是心跳还是日志附加<br>        if args.term&gt;rf.currnetTerm:<br>            rf.role &#x3D; Follower<br>            rf.voteFor &#x3D; -1<br>        rf.currentTerm&#x3D;args.term<br>        reply.Term &#x3D; rf.currentTerm<br>        刷新选举时间<br>        if 心跳：<br>            reply.Success &#x3D; true<br>            更新commit并提交相关log<br>        else:<br>            if 日志匹配<br>                保持和leader一致<br>            else:<br>                reply.Success &#x3D; false</p><p>sendAppendEntries<br>handleAppendEntries</p><h1 id="Lecture-08-Zookeeper"><a href="#Lecture-08-Zookeeper" class="headerlink" title="Lecture 08 - Zookeeper"></a>Lecture 08 - Zookeeper</h1><p>线性一致：</p><ul><li>一个线性一致的执行历史中的操作是非并发的，也就是时间上不重合的客户端请求与实际执行时间匹配。</li><li>每一个读操作都看到的是最近一次写入的值。</li></ul><p><img src="/../../../../img/Pasted%20image%2020231202221322.png"></p><p><img src="/../../../../img/Pasted%20image%2020231202222002.png"></p><p><strong>提供如下服务</strong></p><ul><li>统一命名服务</li><li>配置管理</li><li>成员管理</li><li>Leader 选举</li><li>协调分布式事务</li><li>分布式锁</li></ul><p><strong>文件系统</strong><br>每个树节点被称为<code>znode</code></p><p><code>znode</code>的类型：</p><ul><li>Regular：客户端通过显式创建和删除常规znode来操作它们</li><li>Ephemeral：客户端创建这样的znode，它们要么显式删除它们，要么在创建它们的会话终止时（故意或由于故障）让系统自动删除它们。<br>这样组合后其实有四种类型的 znode：</li></ul><ul><li><code>PERSISTENT</code></li><li><code>EPHEMERAL</code></li><li><code>PERSISTENT_SEQUENTIAL</code></li><li><code>EPHEMERAL_SEQUENTIAL</code><br>客户端通过<code>watch</code>机制能够不需要轮询就可以及时接收更改通知</li></ul><p><strong>会话（Sessions)</strong><br>客户端通过一个会话来和ZooKeeper建立连接。</p><p><strong>客户端API</strong></p><ul><li><code>create(path,data,flags)</code>：创建一个路径名为<code>path</code>的<code>znode</code>,并存放<code>data</code>数据，返回该新<code>znode</code>的名称。<code>flag</code>使客户端能够选择<code>znode</code>的类型：常规、短暂，并设置顺序标志。</li><li><code>delete(path,version)</code>：删除指定路径<code>path</code>下的<code>znode</code>如果它处于给定的<code>version</code>下。</li><li><code>exists(path,watch)</code>：判断指定路径<code>path</code>下是否存在<code>znode</code>。该<code>watch</code>标志能够使客户端在该<code>znode</code>设置一个监听。</li><li><code>getData(path,watch)</code>：返回与<code>znode</code>关联的数据和元数据，如版本信息。<code>watch</code>标志的工作方式与它对<code>exists()</code>的工作方式相同，只是如果<code>znode</code>不存在，<code>ZooKeeper</code>不会设置<code>watch</code>；</li><li><code>setData(path,data,version)</code>：如果版本号是<code>znode</code>的当前版本，则将<code>data</code>写入指定路径<code>path</code>的<code>znode</code>；</li><li><code>getChildren(path,watch)</code>：返回路径为<code>path</code>的<code>zndoe</code>所有孩子节点名称集合。</li><li><code>sync(path)</code>：等待在操作开始时挂起的所有更新传播到客户端连接的服务器。该路径当前被忽略。</li></ul><p>所有方法都有通过API提供的同步和异步版本。<br>更新方法通常有一个预期版本号，只有匹配时才能更新成功。</p><p><strong>Zookeeper guarantees</strong><br>zookeeper提供了两个基本的顺序保证：线性写和先进先出的客户端请求</p><ul><li><strong>Linearizable writes</strong>：所有更新ZooKeeper状态的请求都是可序列化的，并尊重优先级；</li><li><strong>FIFO client order</strong>：来自给定客户端的所有请求都按照客户端发送的顺序执行。</li></ul><p><img src="/../../../../img/Pasted%20image%2020240218100925.png"></p><p><strong>Request Processor</strong><br>由于消息传递层是原子的，我们保证本地副本永远不会发生分歧，尽管在任何时刻，某些服务器可能应用了更多的事务。与从客户端发送的请求不同，事务是幂等的。当领导者收到写请求时，它计算在应用写操作时系统的状态，并将其转换为一个事务，捕捉这个新状态。必须计算未来的状态，因为可能存在尚未应用于数据库的未完成事务。例如，如果客户端执行条件setData，且请求中的版本号与要更新的znode的未来版本号匹配，则服务生成一个包含新数据、新版本号和更新时间戳的setDataTXN。如果发生错误，例如版本号不匹配或要更新的znode不存在，就会生成一个errorTXN。</p><p><strong>Atomic Broadcast</strong><br>所有更新ZooKeeper状态的请求都会被转发到Leader进行。<br>原子广播协议<strong>Zab</strong>，多数决策（类似Raft协议)<br>使用TCP传输消息，以确保顺序<br>写前日志和幂等事务</p><p><strong>Replicated Database</strong><br>每个复制副本都有一个ZooKeeper状态的副本。<br>使用定期快照避免恢复时间过长，快照采用模糊快照（fuzzy snapshot)</p><p><strong>Client-Server Interactions</strong></p><h1 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h1><h2 id="Lab-1-MapReduce"><a href="#Lab-1-MapReduce" class="headerlink" title="Lab 1.MapReduce"></a>Lab 1.MapReduce</h2><p><a href="../ddf70eb0">Lab 1.MapReduce</a></p><h2 id="Lab-2-Raft"><a href="#Lab-2-Raft" class="headerlink" title="Lab 2.Raft"></a>Lab 2.Raft</h2><p><a href="../afaac1c">Lab 2.Raft</a></p><h2 id="Lab-3-KVRaft"><a href="#Lab-3-KVRaft" class="headerlink" title="Lab 3.KVRaft"></a>Lab 3.KVRaft</h2><p><a href="../82d7eaa9">Lab 3.KVRaft</a></p><h2 id="Lab-4-ShardKV"><a href="#Lab-4-ShardKV" class="headerlink" title="Lab 4.ShardKV"></a>Lab 4.ShardKV</h2><p><a href="../ed5ca22">Lab 4.ShardKV</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/lecture-03-gfs/3.1">中文笔记 - MIT6.824 (gitbook.io)</a><br><a href="http://nil.csail.mit.edu/6.824/2020/">6.824 Home Page: Spring 2020 (mit.edu)</a><br><a href="https://zhuanlan.zhihu.com/p/592998375">MIT 6.824分布式 LAB3： kvraft - 知乎 (zhihu.com)</a><br><a href="https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf">Consensus: Bridging Theory and Practice (stanford.edu)</a><br><a href="https://github.com/OneSizeFitsQuorum/MIT6.824-2021">OneSizeFitsQuorum&#x2F;MIT6.824-2021: 4 labs + 2 challenges + 4 docs (github.com)</a><br><a href="https://zhuanlan.zhihu.com/p/631386296?utm_id=0">MIT 6.824 (现6.5840) 通关记录 - 知乎 (zhihu.com)</a><br><a href="https://zhuanlan.zhihu.com/p/350723333">MIT 6.824 Lab Raft测试框架 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 微服务和分布式 </category>
          
          <category> 6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 课程 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程硕士数学</title>
      <link href="/posts/806cd970/"/>
      <url>/posts/806cd970/</url>
      
        <content type="html"><![CDATA[<h1 id="1-引论"><a href="#1-引论" class="headerlink" title="1.引论"></a>1.引论</h1><p>正交矩阵</p><h1 id="2-线性代数方程组的直接解法"><a href="#2-线性代数方程组的直接解法" class="headerlink" title="2.线性代数方程组的直接解法"></a>2.线性代数方程组的直接解法</h1><h2 id="2-2Gauss消去法"><a href="#2-2Gauss消去法" class="headerlink" title="2.2Gauss消去法"></a>2.2Gauss消去法</h2><h2 id="2-3三角分解"><a href="#2-3三角分解" class="headerlink" title="2.3三角分解"></a>2.3三角分解</h2><p><img src="/../../img/Pasted%20image%2020231010204621.png"></p><h3 id="2-3-1直接三角分解"><a href="#2-3-1直接三角分解" class="headerlink" title="2.3.1直接三角分解"></a>2.3.1直接三角分解</h3><p>适用于所有情况<br><img src="/../../img/Pasted%20image%2020231010204721.png"></p><blockquote><p>规律：下三角阵<em><strong>L</strong></em>第一列和<em><strong>A</strong></em>第一列一致，上三角阵<em><strong>U</strong></em>第一行和<em><strong>A</strong></em>第一行一致</p></blockquote><h3 id="2-3-2追赶法"><a href="#2-3-2追赶法" class="headerlink" title="2.3.2追赶法"></a>2.3.2追赶法</h3><p>只适用于三对角矩阵<br><img src="/../../img/Pasted%20image%2020231010205316.png"><br><img src="/../../img/Pasted%20image%2020231010205326.png"></p><h2 id="2-4列主元消去法"><a href="#2-4列主元消去法" class="headerlink" title="2.4列主元消去法"></a>2.4列主元消去法</h2><blockquote><p>是对Gauss消去法的优化，每次从待消元的所有行中的指定列中选出绝对值最大的作为主元</p></blockquote><p><img src="/../../img/Pasted%20image%2020231010205043.png"><br><img src="/../../img/Pasted%20image%2020231010205100.png"></p><h2 id="2-5对称正定矩阵"><a href="#2-5对称正定矩阵" class="headerlink" title="2.5对称正定矩阵"></a>2.5对称正定矩阵</h2><h3 id="2-5-1对称正定矩阵的三角分解"><a href="#2-5-1对称正定矩阵的三角分解" class="headerlink" title="2.5.1对称正定矩阵的三角分解"></a>2.5.1对称正定矩阵的三角分解</h3><p><img src="/../../img/Pasted%20image%2020231010205546.png"><br>更特别的（平方根法）<br><img src="/../../img/Pasted%20image%2020231010205555.png"><br>证明：<br><img src="/../../img/Pasted%20image%2020231010205628.png"></p><h1 id="向量范数"><a href="#向量范数" class="headerlink" title="向量范数"></a>向量范数</h1><p><img src="/../../img/Pasted%20image%2020231010081042.png"><br>常用向量范数<br><img src="/../../img/Pasted%20image%2020231010211231.png"></p><p>矩阵范数<br><img src="/../../img/Pasted%20image%2020231010081226.png"></p><p>算子范数</p><blockquote><p>可以看成矩阵A作用在全部向量上产生的效果的比例最大的那个值，即为||<strong>A</strong>||</p></blockquote><p><img src="/../../img/Pasted%20image%2020231010081741.png"></p><p>谱半径是其对应矩阵的特征值中最大的特征值绝对值</p><p><img src="/../../img/Pasted%20image%2020231010082408.png"></p><blockquote><p>条件数与所选择的范数有关,<em>不同范数计算的条件数不同</em></p></blockquote><p><img src="/../../img/Pasted%20image%2020231010082441.png"></p><p><img src="/../../img/Pasted%20image%2020231010084154.png"></p><p>如何证明：<br>1）A的某一行和该行对应的代数余子式相乘在相加后结果为该行列式的值<br>2）A的某一行和另一行元素的代数余子式相乘在相加后结果为0（相当于两行相同的行列式展开）</p><p><img src="/../../img/Pasted%20image%2020231010084740.png"></p><p><img src="/../../img/Pasted%20image%2020231010084923.png"></p><p><a href="https://zhuanlan.zhihu.com/p/387907406">线性方程组-迭代法 0.1：范数与谱半径 - 知乎 (zhihu.com)</a></p><p>$(1)Cond(A)≥1$<br>$(2)若A是正交矩阵 A^TA&#x3D;I,那么Cond(A)_2&#x3D;1$<br>$(3)设U为正交矩阵，Cond(A)_2&#x3D;Cond(AU)_2&#x3D;Cond(UA)_2$<br>$(4)设\lambda_1和\lambda_n分别为A的模的最大和最小特征值，那么Cond(A)≥\frac {\vert\lambda_1\vert}{\vert\lambda_n\vert}  特别地，A对称则Cond(A)_2&#x3D;\frac {\vert\lambda_1\vert}{\vert\lambda_n\vert}$</p><p><img src="/../../img/Pasted%20image%2020231010091617.png"></p><blockquote><p>方程组的解对<strong>A</strong>或<em><strong>b</strong></em><em>的扰动可能是敏感的，称方程组是病态方程组，病态与否取决于*<em>A</em></em></p></blockquote><p><img src="/../../img/Pasted%20image%2020231010091631.png"></p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h2 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h2><p>P37：13（2），19<br>P62-64：2，3，6，10，11</p><p>P62-64<br>（2）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  2.680000  3.040000 -1.480000 |  -0.530000</span><br><span class="line">  1.480000  0.930000 -1.300000 |   1.030000</span><br><span class="line">  2.510000  1.480000  4.530000 |   0.050000</span><br><span class="line">start----------------------------------</span><br><span class="line">lij= [0, -0.5522388059701492, -0.9365671641791044]</span><br><span class="line">  2.680000  3.040000 -1.480000 |  -0.530000</span><br><span class="line">  0.000000 -0.748806 -0.482687 |   1.322687</span><br><span class="line">  0.000000 -1.367164  5.916119 |   0.546381</span><br><span class="line">第1轮----------------------------------</span><br><span class="line">lij= [0, 0, -0.547707423580786]</span><br><span class="line">  2.680000  3.040000 -1.480000 |  -0.530000</span><br><span class="line">  0.000000 -1.367164  5.916119 |   0.546381</span><br><span class="line">  0.000000  0.000000 -3.722989 |   1.023430</span><br><span class="line">第2轮----------------------------------</span><br><span class="line">x= [1.453100102690178, -1.5891948644354772, -0.27489467072579266]</span><br></pre></td></tr></table></figure><h1 id="3-线性代数方程组的迭代法"><a href="#3-线性代数方程组的迭代法" class="headerlink" title="3.线性代数方程组的迭代法"></a>3.线性代数方程组的迭代法</h1><p><img src="/../../img/Pasted%20image%2020231017092645.png"><br><img src="/../../img/Pasted%20image%2020231017092904.png"></p><p><img src="/../../img/Pasted%20image%2020231017092925.png"><br><img src="/../../img/Pasted%20image%2020231017093251.png"></p><h2 id="Jacobi迭代法"><a href="#Jacobi迭代法" class="headerlink" title="Jacobi迭代法"></a>Jacobi迭代法</h2><p><img src="/../../img/Pasted%20image%2020231017101245.png"></p><h2 id="Gauss-Seidel迭代法"><a href="#Gauss-Seidel迭代法" class="headerlink" title="Gauss-Seidel迭代法"></a>Gauss-Seidel迭代法</h2><p><img src="/../../img/Pasted%20image%2020231017101254.png"><br><img src="/../../img/Pasted%20image%2020231017101307.png"></p><h2 id="收敛性分析"><a href="#收敛性分析" class="headerlink" title="收敛性分析"></a>收敛性分析</h2><p><img src="/../../img/Pasted%20image%2020231017101912.png"><br><img src="/../../img/Pasted%20image%2020231017101928.png"></p><p><img src="/../../img/Pasted%20image%2020231019102652.png"><br><img src="/../../img/Pasted%20image%2020231019102702.png"></p><h2 id="SOR迭代法"><a href="#SOR迭代法" class="headerlink" title="SOR迭代法"></a>SOR迭代法</h2><p><img src="/../../img/Pasted%20image%2020231019105411.png"><br><img src="/../../img/Pasted%20image%2020231019105342.png"></p><p><img src="/../../img/Pasted%20image%2020231019105448.png"><br><img src="/../../img/Pasted%20image%2020231019105811.png"><br><img src="/../../img/Pasted%20image%2020231019105834.png"><br><img src="/../../img/Pasted%20image%2020231019111012.png"></p><h2 id="最速下降法"><a href="#最速下降法" class="headerlink" title="最速下降法"></a>最速下降法</h2><p><img src="/../../img/Pasted%20image%2020231024111328.png"><br><img src="/../../img/Pasted%20image%2020231024111356.png"><br><img src="/../../img/Pasted%20image%2020231024111404.png"><br><img src="/../../img/Pasted%20image%2020231024113013.png"></p><h2 id="共轭梯度法"><a href="#共轭梯度法" class="headerlink" title="共轭梯度法"></a>共轭梯度法</h2><p><img src="/../../img/Pasted%20image%2020231024114840.png"></p><h1 id="4-非线性方程和方程组的数值解法"><a href="#4-非线性方程和方程组的数值解法" class="headerlink" title="4.非线性方程和方程组的数值解法"></a>4.非线性方程和方程组的数值解法</h1><p><img src="/../../img/Pasted%20image%2020231026094812.png"></p><blockquote><p>想象一个抛物线 $y&#x3D;(x-1)^2$,$x&#x3D;1$是二重根</p></blockquote><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p><img src="/../../img/Pasted%20image%2020231026095102.png"><br><img src="/../../img/Pasted%20image%2020231026100620.png"></p><blockquote><p>C[a,b]表示[a,b]上的连续函数<br>$C^k$[a,b]表示的是k阶可导且导函数连续</p></blockquote><p><img src="/../../img/Pasted%20image%2020231026101535.png"><br><img src="/../../img/Pasted%20image%2020231026101543.png"><br><img src="/../../img/Pasted%20image%2020231026102145.png"><br><img src="/../../img/Pasted%20image%2020231026103024.png"><br><img src="/../../img/Pasted%20image%2020231031100235.png"></p><h1 id="5-矩阵特征值的计算方法"><a href="#5-矩阵特征值的计算方法" class="headerlink" title="5.矩阵特征值的计算方法"></a>5.矩阵特征值的计算方法</h1><p><img src="/../../img/Pasted%20image%2020231107105702.png"></p><p><img src="/../../img/Pasted%20image%2020231107105716.png"></p><h2 id="5-2正交变换和矩阵分解"><a href="#5-2正交变换和矩阵分解" class="headerlink" title="5.2正交变换和矩阵分解"></a>5.2正交变换和矩阵分解</h2><p><img src="/../../img/Pasted%20image%2020231109175027.png"><br><img src="/../../img/Pasted%20image%2020231109175045.png"><br><img src="/../../img/Pasted%20image%2020231109181033.png"><br><img src="/../../img/Pasted%20image%2020231109181039.png"><br>给出了一种方法可以使得范数相同的向量变换为部分连续分量为0的向量</p><p><img src="/../../img/Pasted%20image%2020231109181822.png"><br><img src="/../../img/Pasted%20image%2020231109181832.png"><br>给出了一种方法可以使得范数相同的向量变换为第k个分量为0的向量</p><p><img src="/../../img/Pasted%20image%2020231109181924.png"></p><p><img src="/../../img/Pasted%20image%2020231110101602.png"><br><img src="/../../img/Pasted%20image%2020231110101612.png"></p><p><img src="/../../img/Pasted%20image%2020231110124145.png"><br><img src="/../../img/Pasted%20image%2020231110124157.png"><br><img src="/../../img/Pasted%20image%2020231110124225.png"><br><img src="/../../img/Pasted%20image%2020231110124354.png"></p><h1 id="6-插值法"><a href="#6-插值法" class="headerlink" title="6.插值法"></a>6.插值法</h1><p><img src="/../../img/Pasted%20image%2020231116114343.png"><br><img src="/../../img/Pasted%20image%2020231116114358.png"></p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+github+Obsidian搭建个人博客平台</title>
      <link href="/posts/26e99575/"/>
      <url>/posts/26e99575/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于本地使用obsidian对笔记进行编辑和分类时，多端同步繁琐，无法在线查看。因此选用Hexo博客框架+Github建站，搭建一个自己的个人博客页面，同时通过配置Obsidian,使得在本地也可以使用Obsidian进行管理和笔记的编辑。</p></blockquote><blockquote><p>(其实是羡慕别人炫酷的个人博客×)😄😄</p></blockquote><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>博客链接：<a href="https://leggasai.github.io/">LegGasai’s CSLearning</a></p><h1 id="一-新建Github仓库"><a href="#一-新建Github仓库" class="headerlink" title="一.新建Github仓库"></a>一.新建Github仓库</h1><h2 id="1-创建同名仓库"><a href="#1-创建同名仓库" class="headerlink" title="1.创建同名仓库"></a>1.创建同名仓库</h2><blockquote><p>注意图中<code>Repository name</code>必须为<code>Owner.github.io</code>，这样github才能正确识别为<strong>github pages</strong><br><img src="/../../img/Pasted%20image%2020230924160911.png"></p></blockquote><h1 id="二-创建Hexo项目"><a href="#二-创建Hexo项目" class="headerlink" title="二.创建Hexo项目"></a>二.创建Hexo项目</h1><blockquote><p>Hexo是一个<strong>快速、简洁且高效的博客框架</strong>，且开源社区提供了大量的第三方主题样式，可一键生成华丽的个人博客网页。官网链接<a href="https://hexo.io/zh-cn/">Hexo</a></p></blockquote><h2 id="1-安装Hexo"><a href="#1-安装Hexo" class="headerlink" title="1.安装Hexo"></a>1.安装Hexo</h2><blockquote><p>确保已经安装了如下工具</p></blockquote><ul><li>Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li>Git</li></ul><p>然后通过npm安装Hexo脚手架</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure><p>安装完成后，建站（创建Hexo项目）,将<code>&lt;folder&gt;</code>替换成你的文件夹名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo init &lt;folder&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> &lt;folder&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install</span></span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.  </span><br><span class="line">├── _config.yml  </span><br><span class="line">├── package.json  </span><br><span class="line">├── scaffolds  </span><br><span class="line">├── source  </span><br><span class="line">|   ├── _drafts  </span><br><span class="line">|   └── _posts  </span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><blockquote><p>之后主要会用到_config.yml文件和source文件夹</p></blockquote><h2 id="2-修改配置"><a href="#2-修改配置" class="headerlink" title="2.修改配置"></a>2.修改配置</h2><p>修改_config.yml中的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site  </span></span><br><span class="line"><span class="attr">title:</span> <span class="string">&lt;your</span> <span class="string">blog</span> <span class="string">name&gt;</span>  </span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span>  </span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span>  </span><br><span class="line"><span class="attr">keywords:</span>  </span><br><span class="line"><span class="attr">author:</span> <span class="string">&lt;your</span> <span class="string">name&gt;</span> </span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment">#改成中文  </span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br></pre></td></tr></table></figure><p>各参数说明如下</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>title</code></td><td>网站标题</td></tr><tr><td><code>subtitle</code></td><td>网站副标题</td></tr><tr><td><code>description</code></td><td>网站描述</td></tr><tr><td><code>keywords</code></td><td>网站的关键词。支持多个关键词。</td></tr><tr><td><code>author</code></td><td>您的名字</td></tr><tr><td><code>language</code></td><td>网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td></tr><tr><td><code>timezone</code></td><td>网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td></tr></tbody></table><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://leggasai.github.io/</span></span><br></pre></td></tr></table></figure><p>其他配置可以先不用改，后续配置Hexo主题的时候再对应修改</p><h1 id="三-配置Hexo主题-Butterfly为例"><a href="#三-配置Hexo主题-Butterfly为例" class="headerlink" title="三.配置Hexo主题(Butterfly为例)"></a>三.配置Hexo主题(Butterfly为例)</h1><blockquote><p>由于默认的主题比较简陋，好在社区提供了大量的现成的Hexo主题框架供我们选择，网页链接：<a href="https://hexo.io/themes/">Themes | Hexo</a></p></blockquote><h2 id="1-选择主题"><a href="#1-选择主题" class="headerlink" title="1.选择主题"></a>1.选择主题</h2><p>我们可以根据自己的需要和审美，选择一款自己喜爱的主题，这边笔者选择的是比较热门的一款Butterfly主题。<br><img src="/../../img/Pasted%20image%2020230924163004.png"></p><h2 id="2-安装和配置"><a href="#2-安装和配置" class="headerlink" title="2.安装和配置"></a>2.安装和配置</h2><blockquote><p>选择主题后，我们需要找到该主题的官方文档，来进行配置。例如Butterfly的参考文档如下：</p></blockquote><ul><li>github链接：<a href="https://github.com/jerryc127/hexo-theme-butterfly">🦋 A Hexo Theme: Butterfly (github.com)</a></li><li>使用文档：<a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安裝文檔(一) 快速開始 | Butterfly</a></li></ul><p>首先安装主题,在你的<code>Hexo根目录</code>下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>然后应用主题，修改<code>Hexo根目录下的/_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions  </span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/  </span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/  </span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><p>接着安装必要的渲染器插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>为了减少升级主题后带来的不便，请使用以下方法（建议，可以不做）。</p><p>在 hexo 的根目录创建一个文件 _config.butterfly.yml，并把主题目录的 _config.yml 内容复制到 _config.butterfly.yml 去。( 注意: 复制的是主题的 _config.yml ，而不是 hexo 的 _config.yml)<br><img src="/../../img/Pasted%20image%2020230924163827.png"></p><blockquote><p>Hexo会自动合并主题中的<code>_config.yml</code> 和<code>_config.butterfly.yml</code> 里的配置，如果存在同名配置，会使用 <code>_config.butterfly.yml</code> 的配置，其优先度较高。</p></blockquote><p>然后根据官方文档和自己需求，进行页面的定制即可，参考文档如下：</p><ul><li><a href="https://butterfly.js.org/posts/4aa8abbe/">Butterfly 安裝文檔(三) 主題配置-1 | Butterfly</a></li><li><a href="https://butterfly.js.org/posts/ceeb73f/">Butterfly 安裝文檔(四) 主題配置-2 | Butterfly</a></li></ul><h1 id="四-配置Obsidian"><a href="#四-配置Obsidian" class="headerlink" title="四.配置Obsidian"></a>四.配置Obsidian</h1><blockquote><p>为了获得在本地管理和组织所有笔记的良好体验，推荐本地使用Obsidian进行编辑。但Obsidian和Hexo需要一些额外的配置。</p></blockquote><p>首先用Obsidian打开Hexo的根目录<br><img src="/../../img/Pasted%20image%2020230924170303.png"></p><p>修改.gitignore文件，忽略产生的.obsidian配置信息。修改如下，主要是添加了最后一行<code>.obsidian/workspace</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store  </span><br><span class="line">Thumbs.db  </span><br><span class="line">db.json  </span><br><span class="line">*.log  </span><br><span class="line">node_modules/  </span><br><span class="line">public/  </span><br><span class="line">.deploy*/  </span><br><span class="line">_multiconfig.yml  </span><br><span class="line">.obsidian/workspace</span><br></pre></td></tr></table></figure><h2 id="修改obsidian配置"><a href="#修改obsidian配置" class="headerlink" title="修改obsidian配置"></a>修改obsidian配置</h2><p><img src="/../../img/Pasted%20image%2020230924170444.png"></p><ul><li>修改新建笔记存放的位置，因为Hexo默认是放在<code>source/_posts</code>文件夹下的，所以需要修改与之保持一致。</li><li>关闭Wiki链接，Hexo不支持，如果不关闭在本地obsidian是有效果的，部署至网站后，图片和文件会加载不出。</li><li>修改附件默认存放位置，在<code>source</code>文件夹下可以新建一个img或其他名字的文件夹，用于存放笔记中的图片，文件，视频等</li><li>添加忽略文件，将Hexo项目除source文件夹外其他文件夹排除。</li></ul><h2 id="添加模板"><a href="#添加模板" class="headerlink" title="添加模板"></a>添加模板</h2><blockquote><p>obsidian可以自定义模板信息，通过模板快速创建Hexo的front-matter信息</p></blockquote><p><img src="/../../img/Pasted%20image%2020230924170933.png"></p><p>在<code>source/_obsidian</code>文件夹下新建template.md文件，内容如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---  </span><br><span class="line">title: &#123;&#123;title&#125;&#125;  </span><br><span class="line">date: &#123;&#123;date&#125;&#125;  </span><br><span class="line"><span class="section">tags: []  </span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><p>之后使用obsidian添加新笔记时，只需要引入该模版即可。</p><h2 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h2><h3 id="自动生成categories"><a href="#自动生成categories" class="headerlink" title="自动生成categories"></a>自动生成categories</h3><blockquote><p>在本地使用Obsidian时，我们常常会用笔记的路径(如前端&#x2F;Vue)来代表其<code>categories(分类)</code>，但在Hexo中需要在front-matter中手动定义<code>categories</code>,如果我们不想每次都手动配置，而是让Hexo自动以笔记的路径来定义其<code>categories</code>。</p></blockquote><p>添加<code>hexo-auto-category</code>依赖，根据文件目录自动生成 categories 信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-auto-category --save</span><br></pre></td></tr></table></figure><p>在根目录下的<code>_config.yml</code>添加配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generate categories from directory-tree  </span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/xu-song/hexo-auto-category  </span></span><br><span class="line"><span class="comment"># depth: the max_depth of directory-tree you want to generate, should &gt; 0  </span></span><br><span class="line"><span class="attr">auto_category:</span>  </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">depth:</span></span><br></pre></td></tr></table></figure><h3 id="生成唯一静态链接"><a href="#生成唯一静态链接" class="headerlink" title="生成唯一静态链接"></a>生成唯一静态链接</h3><blockquote><p>默认的笔记链接是根据笔记的时间+标题生成的，但如果我们修改了笔记的时间，那么如果别的文章中引用了这篇笔记，就会失效。</p></blockquote><p>添加<code>hexo-abbrlink</code>依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>在根目录下的<code>_config.yml</code>添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink/</span></span><br><span class="line"><span class="comment"># abbrlink config  </span></span><br><span class="line"><span class="comment"># https://github.com/rozbo/hexo-abbrlink  </span></span><br><span class="line"><span class="attr">abbrlink:</span>  </span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>      <span class="comment">#support crc16(default) and crc32  </span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span></span><br></pre></td></tr></table></figure><h3 id="Obsidian文件树插件"><a href="#Obsidian文件树插件" class="headerlink" title="Obsidian文件树插件"></a>Obsidian文件树插件</h3><blockquote><p>由于直接用Obsidian打开Hexo项目，目录树会显示很多无关紧要的目录，在Obsidian中我们只需要关注<code>source/_post</code>这个文件夹即可。</p></blockquote><p>在Obsidian第三方插件中安装<code>File Tree Alternative Plugin</code>插件<br><img src="/../../img/Pasted%20image%2020230924172412.png"><br>文件夹聚焦效果：<br><img src="/../../img/Pasted%20image%2020230924172457.png"></p><h1 id="五-配置一键部署"><a href="#五-配置一键部署" class="headerlink" title="五.配置一键部署"></a>五.配置一键部署</h1><blockquote><p>配置一键部署功能，可以实现本地博客编写完毕后，一键同步到github上，并同步响应的个人主页。参考文档如下：<a href="https://hexo.io/zh-cn/docs/one-command-deployment">部署 | Hexo</a></p></blockquote><p>安装hexo-deployer-git插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install hexo-deployer-git --save</span></span><br></pre></td></tr></table></figure><p>然后修改根目录下的<code>_config.yml</code>文件（注意不是主题配置文件）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment  </span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment  </span></span><br><span class="line"><span class="attr">deploy:</span>  </span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span>  </span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&lt;your</span> <span class="string">repo</span> <span class="string">url&gt;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">&lt;branch</span> <span class="string">name&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="attr">deploy:</span>  </span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span>  </span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:xxxx/xxxx.github.io.git</span>  </span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th><th>默认</th></tr></thead><tbody><tr><td><code>repo</code></td><td>库（Repository）地址</td><td>建议使用<code>git@github.com</code>形式的</td></tr><tr><td><code>branch</code></td><td>分支名称</td><td><code>gh-pages</code> (GitHub)  <br><code>coding-pages</code> (Coding.net)  <br><code>master</code> (others)</td></tr><tr><td><code>message</code></td><td>自定义提交信息</td><td><code>Site updated: &#123;&#123; now('YYYY-MM-DD HH:mm:ss') &#125;&#125;</code>)</td></tr><tr><td><code>token</code></td><td>可选的令牌值，用于认证 repo。用 <code>$</code> 作为前缀从而从环境变量中读取令牌</td><td></td></tr></tbody></table><p>然后执行指令,如果提示需要验证github帐号和密码，则可以配置SSH密钥认证，方式在这就不赘述了，自行百度即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean;</span><br><span class="line">hexo deploy;</span><br></pre></td></tr></table></figure><h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><blockquote><p>总得来说，按照Hexo和Butterfly文档进行配置，笔者自己遇到的问题并不多，如果读者在配置中，遇到问题的欢迎留言评论~</p></blockquote><h2 id="1-配置评论功能"><a href="#1-配置评论功能" class="headerlink" title="1.配置评论功能"></a>1.配置评论功能</h2><blockquote><p>网上大多都是使用Valine管理评论的，因为其无需后端，但是自从2022年起，其不支持国内用户使用了。因此换用了Waline+Vercel构建评论功能。</p></blockquote><p>参考文档如下：<a href="https://waline.js.org/guide/get-started/#leancloud-%E8%AE%BE%E7%BD%AE-%E6%95%B0%E6%8D%AE%E5%BA%93">快速上手 | Waline</a></p><blockquote><p>但Vercel的节点，国内无法访问，因此要使用评论功能，只能通过<code>特殊手段</code>，除非自己购买了域名。</p></blockquote><h2 id="2-配置一键部署"><a href="#2-配置一键部署" class="headerlink" title="2.配置一键部署"></a>2.配置一键部署</h2><blockquote><p>笔者自己通过hexo d部署到github时，经常出现timeout out的情况（也有部分是网络原因），后来发现是因为仓库链接写的是https的形式，改成<code>git@github.com</code>形式的情况就好很多。</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment  </span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment  </span></span><br><span class="line"><span class="attr">deploy:</span>  </span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span>  </span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git</span>  </span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><h2 id="3-标签页-分类页-关于我页面缺失"><a href="#3-标签页-分类页-关于我页面缺失" class="headerlink" title="3.标签页&#x2F;分类页&#x2F;关于我页面缺失"></a>3.标签页&#x2F;分类页&#x2F;关于我页面缺失</h2><p>也就是图中的这些，其中archives是创建Hexo框架时已经有的，不需要自己手动配置，而标签，分类，友链，关于界面是需要手动配置的。<br><img src="/../../img/Pasted%20image%2020230924164601.png"></p><p>其配置的具体方式如下：<a href="https://butterfly.js.org/posts/dc584b87/">Butterfly 安裝文檔(二) 主題頁面 | Butterfly</a></p><p>进入项目根目录，输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>然后在source&#x2F;tags文件夹下会新建一个index.md文件，进入该文件，进行如下修改：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2023-01-05 00:00:00</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">orderby: random</span><br><span class="line"><span class="section">order: 1</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><p>然后重新执行指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean;</span><br><span class="line">hexo g;</span><br><span class="line">hexo s;</span><br></pre></td></tr></table></figure><p>其余页面的配置也类似。</p><p>友链页的配置请参考：<a href="https://butterfly.js.org/posts/dc584b87/#%E5%8F%8B%E6%83%85%E9%8F%88%E6%8E%A5">Butterfly 安裝文檔(二) 主題頁面 | Butterfly</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城笔记</title>
      <link href="/posts/dd2fb3f1/"/>
      <url>/posts/dd2fb3f1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-初始化项目"><a href="#1-初始化项目" class="headerlink" title="1.初始化项目"></a>1.初始化项目</h1><h2 id="idea新建空项目"><a href="#idea新建空项目" class="headerlink" title="idea新建空项目"></a>idea新建空项目</h2><h2 id="添加各个模块"><a href="#添加各个模块" class="headerlink" title="添加各个模块"></a>添加各个模块</h2><blockquote><p>gulimall-product商品服务<br><img src="/../../../../img/Pasted%20image%2020230920094421.png"><br>gulimall-ware仓储服务<br><img src="/../../../../img/Pasted%20image%2020230920094917.png"><br>gulimall-order订单服务<br><img src="/../../../../img/Pasted%20image%2020230920095048.png"><br>同理创建<br>gulimall-coupon优惠券服务<br>gulimall-member会员服务<br>同时添加springboot web依赖和springcloud-routing openfeign依赖</p></blockquote><h2 id="聚合模块"><a href="#聚合模块" class="headerlink" title="聚合模块"></a>聚合模块</h2><blockquote><p>在根目录下添加pom文件，添加下列代码</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leggasai.gulimall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gulimall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>gulimall<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>聚合服务<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>gulimall-ware<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>gulimall-member<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>gulimall-order<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>gulimall-product<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>gulimall-coupon<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>将pom文件加入maven,刷新maven</p></blockquote><h2 id="更改-gitignore文件"><a href="#更改-gitignore文件" class="headerlink" title="更改.gitignore文件"></a>更改.gitignore文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">HELP.md  </span><br><span class="line">target/  </span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar  </span><br><span class="line">!**/src/main/**/target/  </span><br><span class="line">!**/src/test/**/target/  </span><br><span class="line">  </span><br><span class="line">### STS ###  </span><br><span class="line">.apt_generated  </span><br><span class="line">.classpath  </span><br><span class="line">.factorypath  </span><br><span class="line">.project  </span><br><span class="line">.settings  </span><br><span class="line">.springBeans  </span><br><span class="line">.sts4-cache  </span><br><span class="line">  </span><br><span class="line">### IntelliJ IDEA ###  </span><br><span class="line">.idea  </span><br><span class="line">*.iws  </span><br><span class="line">*.iml  </span><br><span class="line">*.ipr  </span><br><span class="line">  </span><br><span class="line">### NetBeans ###  </span><br><span class="line">/nbproject/private/  </span><br><span class="line">/nbbuild/  </span><br><span class="line">/dist/  </span><br><span class="line">/nbdist/  </span><br><span class="line">/.nb-gradle/  </span><br><span class="line">build/  </span><br><span class="line">!**/src/main/**/build/  </span><br><span class="line">!**/src/test/**/build/  </span><br><span class="line">  </span><br><span class="line">### VS Code ###  </span><br><span class="line">.vscode/  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">**/mvnw  </span><br><span class="line">**/mvnw.cmd  </span><br><span class="line">  </span><br><span class="line">**/.mvn  </span><br><span class="line">**/target/  </span><br><span class="line">  </span><br><span class="line">**/.gitignore</span><br></pre></td></tr></table></figure><h1 id="2-数据库设计"><a href="#2-数据库设计" class="headerlink" title="2.数据库设计"></a>2.数据库设计</h1><blockquote><p>数据库分为 订单数据库、用户数据库、库存数据库、商品数据库、优惠数据库<br><a href="../../../../img/gmall_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1.pdm">gmall_数据库设计.pdm</a></p></blockquote><h2 id="订单数据库表"><a href="#订单数据库表" class="headerlink" title="订单数据库表"></a>订单数据库表</h2><blockquote><p>包含了订单信息，退货信息，订单项等<br><a href="../../../../img/gulimall_oms.sql">gulimall_oms.sql</a></p></blockquote><h2 id="用户数据库表"><a href="#用户数据库表" class="headerlink" title="用户数据库表"></a>用户数据库表</h2><blockquote><p>包含了用户信息，会员积分，用户收藏，收货地址等<br><a href="../../../../img/gulimall_ums.sql">gulimall_ums.sql</a></p></blockquote><h2 id="库存数据库表"><a href="#库存数据库表" class="headerlink" title="库存数据库表"></a>库存数据库表</h2><blockquote><p>包含库存工作单，采购单，库存表等<br><a href="../../../../img/gulimall_wms.sql">gulimall_wms.sql</a></p></blockquote><h2 id="商品数据库表"><a href="#商品数据库表" class="headerlink" title="商品数据库表"></a>商品数据库表</h2><blockquote><p>包含SPU表，SKU表，商品分类表，商品评价表，属性表等<br><a href="../../../../img/gulimall_pms.sql">gulimall_pms.sql</a></p></blockquote><h2 id="优惠数据库表"><a href="#优惠数据库表" class="headerlink" title="优惠数据库表"></a>优惠数据库表</h2><blockquote><p>包含优惠券信息，积分表，秒杀信息等，商品优惠信息等<br><a href="../../../../img/gulimall_sms.sql">gulimall_sms.sql</a></p></blockquote><h1 id="3-快速开发代码生成"><a href="#3-快速开发代码生成" class="headerlink" title="3.快速开发代码生成"></a>3.快速开发代码生成</h1><blockquote><p>主要使用人人开源的renren-generator、renren-fast、renren-fast-vue</p></blockquote><h2 id="引入必要的依赖"><a href="#引入必要的依赖" class="headerlink" title="引入必要的依赖"></a>引入必要的依赖</h2><h2 id="创建公共模块"><a href="#创建公共模块" class="headerlink" title="创建公共模块"></a>创建公共模块</h2><p>创建common模块，在其pom文件中添加一些公共的依赖,如mysql-connector-java,mybatis等</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span>  </span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  </span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gulimall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leggasai.gulimall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gulimall-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>公共类<span class="tag">&lt;/<span class="name">description</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis-plus.version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">mybatis-plus.version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.18.8<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">httpcore.version</span>&gt;</span>4.4.12<span class="tag">&lt;/<span class="name">httpcore.version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">commons-lang.version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">commons-lang.version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql-connector-java.version</span>&gt;</span>8.0.17<span class="tag">&lt;/<span class="name">mysql-connector-java.version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-api.version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">servlet-api.version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--mybatis-plus--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-plus.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpcore<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;httpcore.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons-lang.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql-connector-java.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;servlet-api.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其他模块在其pom文件中引入common模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leggasai.gulimall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gulimall-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置Mybatis-Plus"><a href="#配置Mybatis-Plus" class="headerlink" title="配置Mybatis-Plus"></a>配置Mybatis-Plus</h2><p>官方链接：<a href="https://baomidou.com/pages/24112f/">简介 | MyBatis-Plus (baomidou.com)</a></p><h3 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h3><p>在commom模块的pom中添加mybatis-plus的代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-plus.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h3><h4 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h4><p>在各个模块的application.yml中添加如下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">datasource:</span>  </span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span>  </span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span>  </span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.241.128:3306/gulimall_pms</span>  </span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><h4 id="配置Mybatis-Plus-1"><a href="#配置Mybatis-Plus-1" class="headerlink" title="配置Mybatis-Plus"></a>配置Mybatis-Plus</h4><p>在各个模块的application.yml中添加如下配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span>  </span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/**/*.xml</span>  </span><br><span class="line">  <span class="attr">global-config:</span>  </span><br><span class="line">    <span class="attr">db-config:</span>  </span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure><h1 id="4-分布式组件"><a href="#4-分布式组件" class="headerlink" title="4.分布式组件"></a>4.分布式组件</h1><p><img src="/../../../../img/B$16F60L4QJGAUJ_JG%5DLEAV.png"></p><ul><li><strong>Nacos</strong>：注册中心（服务发现&#x2F;注册）</li><li><strong>Nacos</strong>：配置中心（动态配置管理）</li><li>Ribbon：负载均衡</li><li>Feign：声明式HTTP客户端，RPC</li><li>Sentinel：服务容错（服务限流、服务降级、服务熔断）</li><li>Gateway：API网关</li><li>Sleuth：调用链监控</li><li>Seata：分布式事务解决方案</li></ul><p>在common模块中引入Spring-cloud-Alibaba依赖<br><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">版本说明 · alibaba&#x2F;spring-cloud-alibaba Wiki (github.com)</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;dependencyManagement&gt;</span>  </span><br><span class="line">    <span class="string">&lt;dependencies&gt;</span>  </span><br><span class="line">        <span class="string">&lt;dependency&gt;</span>  </span><br><span class="line">            <span class="string">&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span>  </span><br><span class="line">            <span class="string">&lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span>  </span><br><span class="line">            <span class="string">&lt;version&gt;2021.1&lt;/version&gt;</span>  </span><br><span class="line">            <span class="string">&lt;type&gt;pom&lt;/type&gt;</span>  </span><br><span class="line">            <span class="string">&lt;scope&gt;import&lt;/scope&gt;</span>  </span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span>  </span><br><span class="line">    <span class="string">&lt;/dependencies&gt;</span>  </span><br><span class="line"><span class="string">&lt;/dependencyManagement&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>dependencyManagement的用法：</p><ol><li>对项目所依赖jar包进行版本管理的管理器。</li><li>使用pom.xml中的dependencyManagement元索能让所有在子模块中引用一个依赖而不用显式的列出版本号。也就是子模块不需要列出版本，子模块中的pom依赖会找到dependencyManagement所在jar包的版本，并引用这个jar对应的版本号。</li><li>dependencyManagement只是声明依赖， 并不实现引入,因此子项目需要显示的声明需要用的依赖。</li><li>一般用于父工程，如果子项目中指定了版本号,那么会使用子项目中指定的jar版本。</li></ol></blockquote><h2 id="4-1-Nacos"><a href="#4-1-Nacos" class="headerlink" title="4.1 Nacos"></a>4.1 Nacos</h2><p><a href="https://nacos.io/en-us/docs/quick-start-spring-cloud.html">Quick Start for Nacos Spring Cloud Projects</a></p><h3 id="本地下载Nacos"><a href="#本地下载Nacos" class="headerlink" title="本地下载Nacos"></a>本地下载Nacos</h3><p>下载链接：<a href="../../../../img/nacos-server-1.2.1.zip">Nacos</a><br>本地启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在bin/路径下运行</span></span><br><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure><p>启动成功截图<br><img src="/../../../../img/Pasted%20image%2020231001214320.png"><br>访问地址：<a href="http://localhost:8848/nacos">Nacos</a></p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>在子模块application.yml中添加如下代码</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gulimall-member</span></span><br></pre></td></tr></table></figure><p>在启动类上加入注解@EnableDiscoveryClient以开启服务发现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.leggasai.gulimall.member.dao&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GulimallCouponApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GulimallCouponApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h3><p>在pom模块中添加openFeign依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在主类中开启，添加@EnableFeignClients(basePackages &#x3D; “com.leggasai.gulimall.member.feign”)，对应你存放远程调用服务的包路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.leggasai.gulimall.member.dao&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.leggasai.gulimall.member.feign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GulimallMemberApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GulimallMemberApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建远程调用服务文件，路径对应上述basePackages，并编写接口<br>这里的接口要和被调用类中声明的一致，包括接口路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 声明远程调用  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">@FeignClient(&quot;gulimall-coupon&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CouponFeignService</span> &#123;  </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/coupon/coupon/test&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">test</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被调用类 couponController,前面有一个@RequestMapping(&quot;coupon/coupon&quot;)</span></span><br><span class="line"><span class="comment">//因此接口路径为/coupon/coupon/test</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">test</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="type">CouponEntity</span> <span class="variable">couponEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CouponEntity</span>();  </span><br><span class="line">    couponEntity.setCouponName(<span class="string">&quot;满减200-100&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> R.ok().put(<span class="string">&quot;coupons&quot;</span>, Arrays.asList(couponEntity));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用远程调用，注入远程调用服务，调用其中的接口方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>  </span><br><span class="line">CouponFeignService couponFeignService;  </span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">test</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> couponFeignService.test();  </span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">    map.put(<span class="string">&quot;member&quot;</span>,<span class="string">&quot;jyc&quot;</span>);  </span><br><span class="line">    map.put(<span class="string">&quot;coupons&quot;</span>,r.get(<span class="string">&quot;coupons&quot;</span>));  </span><br><span class="line">    <span class="keyword">return</span> R.ok(map);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h3><p>参考文档<a href="https://github.com/alibaba/spring-cloud-alibaba/blob/2021.x/spring-cloud-alibaba-examples/nacos-example/nacos-config-example/readme-zh.md">Nacos-config-example</a><br>在pom模块中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置中心--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意新版本需要引入spring-cloud-starter-bootstrap依赖来加载bootstrap.properties文件</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新建bootstrap.properties文件，不能在application.yml中写，否则不能动态生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=gulimall-coupon  </span><br><span class="line">spring.cloud.nacos.config.server-addr=127.0.0.1:8848</span><br></pre></td></tr></table></figure><p>打开Nacos配置中心，添加配置，Data ID必须为spring.application.name加properties<br><img src="/../../../../img/Pasted%20image%2020231003111345.png"></p><ul><li>命名空间：用来配置隔离<ul><li>默认使用public（保留空间），默认新增的所有配置都在public空间</li><li>应用：<ul><li>配置开发，测试，生产环境的不同命名空间</li><li>每一个微服务相互隔离，创建不同的命名空间</li></ul></li><li>需要使用spring.cloud.nacos.config.namespace&#x3D;id,指定对应命名控件ID</li></ul></li><li>配置集：所有配置的集合</li><li>配置集ID：Data ID</li><li>配置分组：对配置进行分组<ul><li>默认所有的配置集都属于DEFAULT_GROUP</li><li>需要使用spring.cloud.nacos.config.group指定对应的配置分组</li></ul></li></ul><p>本项目规则：</p><ul><li>每个微服务创建自己的<code>命名空间</code>，使用<code>配置分组</code>区分环境，dev、prop、test</li><li>微服务任何配置信息，任何配置文件都可以放在配置中心中</li><li>配置中心的配置会被优先使用</li></ul><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关是所有流量的入口，功能包括路由转发、权限校验、限流控制。本项目使用Spring Cloud Gateway作为网关。<br><a href="https://docs.spring.io/spring-cloud-gateway/docs/3.0.8/reference/html/">Spring Cloud Gateway</a></p><ol><li><p>新建gulimall-gateway模块<br><img src="/../../../../img/Pasted%20image%2020231004161619.png"></p></li><li><p>修改pom文件和根目录下的pom文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leggasai.gulimall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gulimall-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>gulimall-gateway<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>API Gateway<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>2020.0.1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leggasai.gulimall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gulimall-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>开启服务的注册和发现。先在Nacos配置中心处，新建一个命名空间gateway，用于存放和gateway网关有关的配置项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=gulimall-gateway  </span><br><span class="line">spring.cloud.nacos.config.server-addr=127.0.0.1:8848  </span><br><span class="line">spring.cloud.nacos.config.namespace=6f924aa0-39f6-4a86-9be9-f13562a9af7f</span><br></pre></td></tr></table></figure></li><li><p>排除数据库相关配置。在Application.java中添加如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span></span><br></pre></td></tr></table></figure><blockquote><p>否则运行会报错<br><img src="/../../../../img/Pasted%20image%2020231004164209.png"></p></blockquote></li><li><p>添加路由规则，新建application.yml（此处为了本地调式方便，以后统一写在Nacos配置中心）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">test_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://www.baidu.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Query=url,</span> <span class="string">baidu</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="5-商品服务"><a href="#5-商品服务" class="headerlink" title="5.商品服务"></a>5.商品服务</h1><h2 id="三级分类"><a href="#三级分类" class="headerlink" title="三级分类"></a>三级分类</h2><h3 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h3><blockquote><p>需要实现类似<code>京东</code>的商品分类树形结构，<code>pms_category</code>表中通过<code>cat_id</code>和<code>parent_cid</code>建立层级关系。使用递归查询构建树形结构<br><img src="/../../../../img/Pasted%20image%2020231004185021.png"></p></blockquote><p>逻辑代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CategoryServiceImpl.java</span></span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> List&lt;CategoryEntity&gt; <span class="title function_">listWithTree</span><span class="params">()</span> &#123;  </span><br><span class="line">    List&lt;CategoryEntity&gt; entities = <span class="built_in">this</span>.baseMapper.selectList(<span class="literal">null</span>);  </span><br><span class="line">    List&lt;CategoryEntity&gt; levelOneMenus = entities.stream().filter(categoryEntity -&gt;  </span><br><span class="line">            categoryEntity.getParentCid().equals(<span class="number">0L</span>)  </span><br><span class="line">    ).map((item) -&gt; &#123;  </span><br><span class="line">        item.setChildren(getChildren(item, entities));  </span><br><span class="line">        <span class="keyword">return</span> item;  </span><br><span class="line">    &#125;).sorted((t1,t2)-&gt;&#123;  </span><br><span class="line">        <span class="keyword">return</span> (t1.getSort()==<span class="literal">null</span>?<span class="number">0</span>:t1.getSort())-(t2.getSort()==<span class="literal">null</span>?<span class="number">0</span>:t2.getSort());  </span><br><span class="line">    &#125;).collect(Collectors.toList());  </span><br><span class="line">    <span class="keyword">return</span> levelOneMenus;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> List&lt;CategoryEntity&gt; <span class="title function_">getChildren</span><span class="params">(CategoryEntity root,List&lt;CategoryEntity&gt; list)</span>&#123;  </span><br><span class="line">    List&lt;CategoryEntity&gt; children = list.stream().filter(categoryEntity -&gt;  </span><br><span class="line">            categoryEntity.getParentCid().equals(root.getCatId())  </span><br><span class="line">    ).map((item) -&gt; &#123;  </span><br><span class="line">        item.setChildren(getChildren(item, list));  </span><br><span class="line">        <span class="keyword">return</span> item;  </span><br><span class="line">    &#125;).sorted((t1,t2)-&gt;&#123;  </span><br><span class="line">        <span class="keyword">return</span> (t1.getSort()==<span class="literal">null</span>?<span class="number">0</span>:t1.getSort())-(t2.getSort()==<span class="literal">null</span>?<span class="number">0</span>:t2.getSort());  </span><br><span class="line">    &#125;).collect(Collectors.toList());  </span><br><span class="line">    <span class="keyword">return</span> children;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置网关"><a href="#配置网关" class="headerlink" title="配置网关"></a>配置网关</h3><p>先将后台管理的请求转发到网关<br>修改renren-fast-vue中static\config\index.js中的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">SITE_CONFIG</span>[<span class="string">&#x27;baseUrl&#x27;</span>] = <span class="string">&#x27;http://localhost:88/api&#x27;</span>;</span><br></pre></td></tr></table></figure><p>配置gateway的application.yml</p><blockquote><p>拦截所有<code>/api/**</code>的请求，并进行路径重写，重写为<code>/renren-fast/**</code><br>参考文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/3.0.1/reference/html/#the-rewritepath-gatewayfilter-factory">Spring Cloud Gateway</a></p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">test_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://www.baidu.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Query=url,</span> <span class="string">baidu</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">admin_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://renren-fast</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/api/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">RewritePath=/api/(?&lt;segment&gt;/?.*),</span> <span class="string">/renren-fast/$\&#123;segment&#125;</span></span><br></pre></td></tr></table></figure><p>成功显示验证码<br><img src="/../../../../img/Pasted%20image%2020231006155841.png"></p><h3 id="配置跨域"><a href="#配置跨域" class="headerlink" title="配置跨域"></a>配置跨域</h3><p><img src="/../../../../img/Pasted%20image%2020231006163056.png"></p><p>在gateway网关中配置跨域，添加config文件夹<br><a href="https://blog.csdn.net/weixin_45481406/article/details/127573858?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169658266316800213064076%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169658266316800213064076&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-127573858-null-null.142%5Ev94%5Einsert_down1&utm_term=springcloud%E7%BD%91%E5%85%B3%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9F&spm=1018.2226.3001.4187">Spring Cloud Gateway 解决跨域问题_springcloudgateway跨域配置-CSDN博客</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> &#123;  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> CorsWebFilter <span class="title function_">corsWebFilter</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();  </span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();  </span><br><span class="line">        <span class="comment">//1.配置跨域  </span></span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);  </span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);  </span><br><span class="line">        corsConfiguration.addAllowedOriginPattern(<span class="string">&quot;*&quot;</span>);  </span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="literal">true</span>);  </span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>,corsConfiguration);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsWebFilter</span>(source);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="菜单增删改查"><a href="#菜单增删改查" class="headerlink" title="菜单增删改查"></a>菜单增删改查</h3><p>配置网关路由，注意顺序，更具体的路由必须在前，否则会被<code>/api/**</code>拦截</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">product_route</span>  </span><br><span class="line">  <span class="attr">uri:</span> <span class="string">lb://gulimall-product</span>  </span><br><span class="line">  <span class="attr">predicates:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/api/product/**</span>  </span><br><span class="line">  <span class="attr">filters:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">RewritePath=/api/(?&lt;segment&gt;/?.*),</span> <span class="string">/$\&#123;segment&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">admin_route</span>  </span><br><span class="line">  <span class="attr">uri:</span> <span class="string">lb://renren-fast</span>  </span><br><span class="line">  <span class="attr">predicates:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/api/**</span>  </span><br><span class="line">  <span class="attr">filters:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">RewritePath=/api/(?&lt;segment&gt;/?.*),</span> <span class="string">/renren-fast/$\&#123;segment&#125;</span></span><br></pre></td></tr></table></figure><p>在gulimall-product中开启服务发现</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cloud:</span>  </span><br><span class="line">  <span class="attr">nacos:</span>  </span><br><span class="line">    <span class="attr">discovery:</span>  </span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span>  </span><br><span class="line">  </span><br><span class="line"><span class="attr">application:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">gulimall-product</span></span><br></pre></td></tr></table></figure><blockquote><p>删除</p></blockquote><p>开启逻辑删除，配置Mybatis-plus</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span>  </span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/**/*.xml</span>  </span><br><span class="line">  <span class="attr">global-config:</span>  </span><br><span class="line">    <span class="attr">db-config:</span>  </span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span>  </span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span>  </span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>如果逻辑删除字段的值需要和上述全局配置不同，可以在实体类上通过注解实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 是否显示[0-不显示（删除），1显示（删除）]  </span></span><br><span class="line"><span class="comment"> */</span><span class="meta">@TableLogic(value = &quot;1&quot;,delval = &quot;0&quot;)</span>  </span><br><span class="line"><span class="keyword">private</span> Integer showStatus;</span><br></pre></td></tr></table></figure><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="P16安装SASS"><a href="#P16安装SASS" class="headerlink" title="P16安装SASS"></a>P16安装SASS</h2><p>先找和本地node版本对应的node-sass的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -version</span><br></pre></td></tr></table></figure><p>修改前端package.json中node-sass版本至对应的版本</p><blockquote><p>本人node为14.17.1，node-sass为4.14.1</p></blockquote><p>单独安装node-sass</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i node-sass@4.14.1 --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</span><br></pre></td></tr></table></figure><p>若执行成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>若失败,先清除node-sass缓存，再查找其他原因，可以降低node版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm rebuild node-sass</span><br><span class="line">npm uninstall node-sass</span><br></pre></td></tr></table></figure><h2 id="P46验证码加载不出"><a href="#P46验证码加载不出" class="headerlink" title="P46验证码加载不出"></a>P46验证码加载不出</h2><p>首先renren-fast不要引入common依赖，而是根据renren-fast的springboot版本单独引入对应的<code>spring-cloud-alibaba</code>并进行依赖管理。然后引入<code>spring-cloud-starter-alibaba-nacos-discovery</code>和<code>spring-cloud-loadbalancer</code>(实际发现不引入也行？)<br><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">版本说明 · alibaba&#x2F;spring-cloud-alibaba Wiki (github.com)</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!--注册发现--&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SKU和SPU概念"><a href="#SKU和SPU概念" class="headerlink" title="SKU和SPU概念"></a>SKU和SPU概念</h2><blockquote><p>SPU:标准化产品单元(Standard Product Unit)，是商品信息聚合的最小单位，是一组可复用标准化信息的集合，主要也是为了在交易端对一组同类型商品做页面的聚合展示，解决的是一品多型号多规格等等多属性的问题；<br>例如：iPhone X 可以确定一个产品即为一个SPU。</p></blockquote><blockquote><p>SKU:最小的库存单位(StockKeeping Unit)，<code>sku</code>是库存存贮的最小单位，商品的进货、销售、售价、库存等最终都是打在<code>sku</code>身上的，最终的交易都决定在一个<code>sku</code>个体上；<br>例如：iPhone X 64G 银色 则是一个SKU。</p></blockquote><blockquote><p>可以理解为类和对象的关系，SPU是类&#x2F;模板，SKU是对象&#x2F;实例，有多种属性。一个SPU对应多个SKU。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Project </category>
          
          <category> 谷粒商城 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凤凰架构笔记</title>
      <link href="/posts/c1c1f0d5/"/>
      <url>/posts/c1c1f0d5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-架构师的视角"><a href="#1-架构师的视角" class="headerlink" title="1.架构师的视角"></a>1.架构师的视角</h1><h2 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h2><ul><li>A（atomicity原子性）：在同一项业务处理过程中，事务保证了对多个数据的修改，要么同时成功，要么同时被撤销。</li><li>C（consistency一致性)：事务必须是使数据库从一个一致性状态变到另一个一致性状态。</li><li>I （isolation隔离性）：在不同的业务处理过程中，事务保证了各自业务正在读、写的数据互相独立，不会彼此影响。</li><li>D（durability持久性)：事务应当保证所有成功被提交的数据修改都能够正确地被持久化，不丢失数据。</li></ul><blockquote><p><code>原子性</code>、<code>隔离性</code>、<code>持久性</code>都是为<code>一致性</code>服务的</p></blockquote><h3 id="如何保证原子性和持久性"><a href="#如何保证原子性和持久性" class="headerlink" title="如何保证原子性和持久性"></a>如何保证原子性和持久性</h3><blockquote><p>发生崩溃的情况</p></blockquote><ul><li><strong>未提交事务，写入后崩溃</strong>：程序还没修改完三个数据，但数据库已经将其中一个或两个数据的变动写入磁盘，此时出现崩溃，一旦重启之后，数据库必须要有办法得知崩溃前发生过一次不完整的购物操作，将已经修改过的数据从磁盘中恢复成没有改过的样子，以保证原子性。(undo log)</li><li><strong>已提交事务，写入前崩溃</strong>：程序已经修改完三个数据，但数据库还未将全部三个数据的变动都写入到磁盘，此时出现崩溃，一旦重启之后，数据库必须要有办法得知崩溃前发生过一次完整的购物操作，将还没来得及写入磁盘的那部分数据重新写入，以保证持久性。（redo log）</li></ul><blockquote><p>事务提交和写入时间分类</p></blockquote><ul><li><strong>FORCE</strong>：当事务提交后，要求变动数据必须同时完成写入则称为 FORCE，如果不强制变动数据必须同时完成写入则称为 NO-FORCE。现实中绝大多数数据库采用的都是 NO-FORCE 策略，因为只要有了日志，变动数据随时可以持久化，从优化磁盘 I&#x2F;O 性能考虑，没有必要强制数据写入立即进行。</li><li><strong>STEAL</strong>：在事务提交前，允许变动数据提前写入则称为 STEAL，不允许则称为 NO-STEAL。从优化磁盘 I&#x2F;O 性能考虑，允许数据提前写入，有利于利用空闲 I&#x2F;O 资源，也有利于节省数据库缓存区的内存。</li></ul><blockquote><p>恢复崩溃时的操作</p></blockquote><ul><li><strong>分析阶段</strong>（Analysis）：该阶段从最后一次检查点（Checkpoint，可理解为在这个点之前所有应该持久化的变动都已安全落盘）开始扫描日志，找出所有没有 End Record 的事务，组成待恢复的事务集合，这个集合至少会包括 Transaction Table 和 Dirty Page Table 两个组成部分。</li><li><strong>重做阶段</strong>（Redo）：该阶段依据分析阶段中产生的待恢复的事务集合来重演历史（Repeat History），具体操作为：找出所有包含 Commit Record 的日志，将这些日志修改的数据写入磁盘，写入完成后在日志中增加一条 End Record，然后移除出待恢复事务集合。</li><li><strong>回滚阶段</strong>（Undo）：该阶段处理经过分析、重做阶段后剩余的恢复事务集合，此时剩下的都是需要回滚的事务，它们被称为 Loser，根据 Undo Log 中的信息，将已经提前写入磁盘的信息重新改写回去，以达到回滚这些 Loser 事务的目的。</li></ul><p><img src="/../../../img/Pasted%20image%2020230922180552.png"></p><h3 id="如何保证隔离性"><a href="#如何保证隔离性" class="headerlink" title="如何保证隔离性"></a>如何保证隔离性</h3><blockquote><p>现代数据库的三种锁</p></blockquote><ul><li><p><strong>写锁</strong>（Write Lock，也叫作排他锁，eXclusive Lock，简写为 X-Lock）：如果数据有加写锁，就只有持有写锁的事务才能对数据进行写入操作，数据加持着写锁时，其他事务不能写入数据，也不能施加读锁。</p></li><li><p><strong>读锁</strong>（Read Lock，也叫作共享锁，Shared Lock，简写为 S-Lock）：多个事务可以对同一个数据添加多个读锁，数据被加上读锁后就不能再被加上写锁，所以其他事务不能对该数据进行写入，但仍然可以读取。对于持有读锁的事务，如果该数据只有它自己一个事务加了读锁，允许直接将其升级为写锁，然后写入数据。</p></li><li><p><strong>范围锁</strong>（Range Lock）：对于某个范围直接加排他锁，在这个范围内的数据不能被写入(不可新增或删除)。如下语句是典型的加范围锁的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> price <span class="operator">&lt;</span> <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>四种隔离级别</p></blockquote><ul><li>可串行化：对所有操作加写锁，读锁，范围锁。性能差，隔离级别最高。</li><li>可重复读（幻读）：对事务所涉及的数据加读锁和写锁，且一直持有至事务结束，但不再加范围锁。<blockquote><p>注意，这里的插入操作不需要加写锁。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> price <span class="operator">&lt;</span> <span class="number">100</span><span class="comment">/* 时间顺序：1，事务： T1 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> books(name,price) <span class="keyword">VALUES</span> (<span class="string">&#x27;深入理解Java虚拟机&#x27;</span>,<span class="number">90</span>)<span class="comment">/* 时间顺序：2，事务： T2 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> price <span class="operator">&lt;</span> <span class="number">100</span><span class="comment">/* 时间顺序：3，事务： T1 */</span></span><br></pre></td></tr></table></figure></li><li>读已提交（幻读，不可重复读）：对事务涉及的数据加的写锁会一直持续到事务结束，但加的读锁在查询操作完成后就马上会释放。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;   <span class="comment">/* 时间顺序：1，事务： T1 立刻释放读锁，因此之后可以进行update操作*/</span></span><br><span class="line"><span class="keyword">UPDATE</span> books <span class="keyword">SET</span> price <span class="operator">=</span> <span class="number">110</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="keyword">COMMIT</span>;<span class="comment">/* 时间顺序：2，事务： T2 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="keyword">COMMIT</span>;   <span class="comment">/* 时间顺序：3，事务： T1 */</span></span><br></pre></td></tr></table></figure></li><li>读未提交（幻读，脏读，不可重复读）：对事务涉及的数据只加写锁，会一直持续到事务结束，但完全不加读锁。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;   <span class="comment">/* 时间顺序：1，事务： T1 */</span></span><br><span class="line"><span class="comment">/* 注意没有COMMIT */</span></span><br><span class="line"><span class="keyword">UPDATE</span> books <span class="keyword">SET</span> price <span class="operator">=</span> <span class="number">90</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;<span class="comment">/* 时间顺序：2，事务： T2 */</span></span><br><span class="line"><span class="comment">/* 这条SELECT模拟购书的操作的逻辑 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">/* 时间顺序：3，事务： T1 这里不需要加读锁，因此可以在有写锁的情况下进行读操作*/</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h2><blockquote><p>在本节里，全局事务被限定为一种适用于单个服务使用多个数据源场景的事务解决方案。现在，我们对本章的<a href="http://icyfenix.cn/architect-perspective/general-architecture/transaction/">场景事例</a>做另外一种假设：如果书店的<code>用户</code>、<code>商家</code>、<code>仓库</code>分别处于不同的数据库中，其他条件仍与之前相同，那情况会发生什么变化呢？假如你平时以声明式事务来编码，那它与本地事务看起来可能没什么区别，都是标个<code>@Transactional</code>注解而已，但如果以编程式事务来实现的话，就能在写法上看出差异，伪代码如下所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyBook</span><span class="params">(PaymentBill bill)</span> &#123;</span><br><span class="line">    userTransaction.begin();</span><br><span class="line">    warehouseTransaction.begin();</span><br><span class="line">    businessTransaction.begin();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        userAccountService.pay(bill.getMoney());</span><br><span class="line">        warehouseService.deliver(bill.getItems());</span><br><span class="line">        businessAccountService.receipt(bill.getMoney());</span><br><span class="line">        userTransaction.commit();</span><br><span class="line">        warehouseTransaction.commit();</span><br><span class="line">        businessTransaction.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        userTransaction.rollback();</span><br><span class="line">        warehouseTransaction.rollback();</span><br><span class="line">        businessTransaction.rollback();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果businessTransaction.commit()执行出错，则被异常捕获，执行rollback方法，但是此时userTransaction和warehouseTransaction已经commit(),回滚已无济于事，事务的整个一致性被破坏。</p></blockquote><h3 id="两段式提交（2pc"><a href="#两段式提交（2pc" class="headerlink" title="两段式提交（2pc)"></a>两段式提交（2pc)</h3><ul><li><strong>准备阶段</strong>：又叫作投票阶段，在这一阶段，协调者询问事务的所有参与者是否准备好提交，参与者如果已经准备好提交则回复 Prepared，否则回复 Non-Prepared。这里所说的准备操作跟人类语言中通常理解的准备并不相同，对于数据库来说，准备操作是在重做日志中记录全部事务提交操作所要做的内容，它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record 而已，这意味着在做完数据持久化后并不立即释放隔离性，即仍继续持有锁，维持数据对其他非事务内观察者的隔离状态。(指事务操作已执行，但尚未commit)</li><li><strong>提交阶段</strong>：又叫作执行阶段，协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息，则先自己在本地持久化事务状态为 Commit，&lt;注意这个时间点可能会出现网络崩溃&gt;在此操作完成后向所有参与者发送 Commit 指令，所有参与者立即执行提交操作；否则，任意一个参与者回复了 Non-Prepared 消息，或任意一个参与者超时未回复，协调者将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作。对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条 Commit Record 而已，通常能够快速完成，只有收到 Abort 指令时，才需要根据回滚日志清理已提交的数据，这可能是相对重负载的操作。(如果所有参与者的事务都操作成功，也就是都准备好了，则一起commit，否则全部回滚（因为此时大家都尚未commit，可以执行rollback）)</li></ul><p><img src="/../../../img/Pasted%20image%2020230922192109.png"></p><blockquote><p>两段式提交的缺陷</p></blockquote><ul><li>单点问题，协调者宕机影响全部参与者。</li><li>性能问题，整个过程涉及到两次远程服务调用，三次数据持久化</li><li>一致性风险，协调者commit后，网络崩溃，参与者无法commit</li></ul><h3 id="三段式提交（3pc）"><a href="#三段式提交（3pc）" class="headerlink" title="三段式提交（3pc）"></a>三段式提交（3pc）</h3><p>三段式提交把原本的两段式提交的准备阶段再细分为两个阶段，分别称为 CanCommit、PreCommit，把提交阶段改称为 DoCommit 阶段。其中，新增的 CanCommit 是一个询问阶段，协调者让每个参与的数据库根据自身状态，评估该事务是否有可能顺利完成。将准备阶段一分为二的理由是这个阶段是重负载的操作，一旦协调者发出开始准备的消息，每个参与者都将马上开始写重做日志，它们所涉及的数据资源即被锁住，如果此时某一个参与者宣告无法完成提交，相当于大家都白做了一轮无用功。所以，增加一轮询问阶段，如果都得到了正面的响应，那事务能够成功提交的把握就比较大了，这也意味着因某个参与者提交时发生崩溃而导致大家全部回滚的风险相对变小。因此，在事务需要回滚的场景中，三段式的性能通常是要比两段式好很多的，但在事务能够正常提交的场景中，两者的性能都依然很差，甚至三段式因为多了一次询问，还要稍微更差一些。</p><ul><li>CanCommit阶段大幅减少了二段式中准备阶段参与者可能出错的情况</li><li>参与者超时自动提交机制，解决了二段式的<code>单点问题</code></li><li>如果协调者想发送Abort指令，但网络崩溃，参与者超时后会错误的进行Commit，同样导致数据不一致。</li></ul><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="CAP和ACID"><a href="#CAP和ACID" class="headerlink" title="CAP和ACID"></a>CAP和ACID</h3><blockquote><p>在分布式系统中，涉及共享数据问题时，以下三个特征最多同时满足两个。</p></blockquote><ul><li><p><strong>一致性</strong>（<strong>C</strong>onsistency）：代表数据在任何时刻、任何分布式节点中所看到的都是符合预期的。一致性在分布式研究中是有严肃定义、有多种细分类型的概念，以后讨论分布式共识算法时，我们还会再提到一致性，那种面向副本复制的一致性与这里面向数据库状态的一致性严格来说并不完全等同，具体差别我们将在后续分布式共识算法中再作探讨。</p></li><li><p><strong>可用性</strong>（<strong>A</strong>vailability）：代表系统不间断地提供服务的能力，理解可用性要先理解与其密切相关两个指标：可靠性（Reliability）和可维护性（Serviceability）。可靠性使用平均无故障时间（Mean Time Between Failure，MTBF）来度量；可维护性使用平均可修复时间（Mean Time To Repair，MTTR）来度量。可用性衡量系统可以正常使用的时间与总时间之比，其表征为：A&#x3D;MTBF&#x2F;（MTBF+MTTR），即可用性是由可靠性和可维护性计算得出的比例值，譬如 99.9999%可用，即代表平均年故障修复时间为 32 秒。</p></li><li><p><strong>分区容忍性</strong>（<strong>P</strong>artition Tolerance）：代表分布式环境中部分节点因网络原因而彼此失联后，即与其他节点形成“网络分区”时，系统仍能正确地提供服务的能力。</p></li></ul><h3 id="强一致性和弱一致性"><a href="#强一致性和弱一致性" class="headerlink" title="强一致性和弱一致性"></a>强一致性和弱一致性</h3><ul><li>强一致性（线性一致性）：<ul><li>复制是同步的</li><li>任何一次读都能读到某个数据的最近一次写的数据。</li><li>系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。（简言之，在任意时刻，所有节点中的数据是一样的。）</li></ul></li><li>弱一致性（最终一致性）：<ul><li>复制是异步的</li><li>数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性。</li><li>最终一致性就属于弱一致性。</li></ul></li><li>最终一致性：<ul><li>不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。</li><li>简单说，就是在一段时间后，节点间的数据会最终达到一致状态。</li></ul></li></ul><h3 id="柔性事务和刚性事务"><a href="#柔性事务和刚性事务" class="headerlink" title="柔性事务和刚性事务"></a>柔性事务和刚性事务</h3><ul><li>刚性事务：强一致性下的事务，常见于ACID</li><li>柔性事务：弱一致性下的事务，常见于BASE</li></ul><blockquote><p>BASE 分别是基本可用性（<strong>B</strong>asically <strong>A</strong>vailable）、柔性事务（<strong>S</strong>oft State）和最终一致性（<strong>E</strong>ventually Consistent）的缩写。</p></blockquote><h3 id="可靠事件队列"><a href="#可靠事件队列" class="headerlink" title="可靠事件队列"></a>可靠事件队列</h3><p><a href="http://icyfenix.cn/architect-perspective/general-architecture/transaction/distributed.html#%E5%8F%AF%E9%9D%A0%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97">分布式事务 | 凤凰架构 (icyfenix.cn)</a></p><h3 id="TCC事务"><a href="#TCC事务" class="headerlink" title="TCC事务"></a>TCC事务</h3><p><a href="http://icyfenix.cn/architect-perspective/general-architecture/transaction/distributed.html#%E5%8F%AF%E9%9D%A0%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97">分布式事务 | 凤凰架构 (icyfenix.cn)</a></p><h3 id="SAGA事务"><a href="#SAGA事务" class="headerlink" title="SAGA事务"></a>SAGA事务</h3><p><a href="http://icyfenix.cn/architect-perspective/general-architecture/transaction/distributed.html#%E5%8F%AF%E9%9D%A0%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97">分布式事务 | 凤凰架构 (icyfenix.cn)</a></p><h2 id="透明多级分流系统"><a href="#透明多级分流系统" class="headerlink" title="透明多级分流系统"></a>透明多级分流系统</h2><blockquote><p>Transparent Multilevel Cache，这一章主要是从客户端到服务端的多级缓存机制的概述。</p></blockquote><h3 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h3><h3 id="域名解析DNS系统"><a href="#域名解析DNS系统" class="headerlink" title="域名解析DNS系统"></a>域名解析DNS系统</h3><h3 id="传输链路"><a href="#传输链路" class="headerlink" title="传输链路"></a>传输链路</h3><blockquote><p>HTTP0.X、HTTP1.X、HTTP2.0的优化策略</p></blockquote><h3 id="内容分发网络"><a href="#内容分发网络" class="headerlink" title="内容分发网络"></a>内容分发网络</h3><p><img src="/../../../img/Pasted%20image%2020230923142842.png"></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><blockquote><p>调度后方的多台机器，以统一的接口对外提供服务，承担此职责的技术组件被称为“负载均衡”。</p></blockquote><ul><li>数据链路层：修改<code>数据帧</code>的目标MAC地址，服务器IP需要配置和均衡器的（虚拟）IP一致。</li></ul><p><img src="/../../../img/Pasted%20image%2020230923144216.png"></p><ul><li>网络层：方式一：IP隧道；方式二改变目标数据包</li></ul><p><img src="/../../../img/Pasted%20image%2020230923144936.png"></p><p><img src="/../../../img/Pasted%20image%2020230923144942.png"></p><hr><blockquote><p>以上四层的负载均衡都属于转发，四层之后的负载均衡模式只能代理</p></blockquote><blockquote><p>根据哪一方能感知，代理分为如下三类</p></blockquote><ul><li>正向代理（默认）：客户端可知，对服务端透明。代理服务器代替客户端与服务端通信。翻墙VPN使用了该类技术。</li></ul><p><img src="/../../../img/Pasted%20image%2020230923150821.png"></p><ul><li>反向代理（七层负载均衡属于反向代理）：服务端可知，对客户端透明。代理服务器代替服务端和客户端通信，而隐藏了真实服务端。</li></ul><p><img src="/../../../img/Pasted%20image%2020230923150807.png"></p><ul><li>透明代理：对双方都透明。</li></ul><blockquote><p>负载均衡策略</p></blockquote><ul><li>轮询均衡</li><li>权重轮询均衡</li><li>随机均衡</li><li>权重随机均衡</li><li>一致性哈希均衡</li><li>响应速度均衡</li><li>最小连接数均衡</li></ul><h3 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a>服务端缓存</h3><blockquote><p>缓存不是越多越好，需要考虑失效、一致性、更新、安全性等</p></blockquote><h4 id="进程内缓存"><a href="#进程内缓存" class="headerlink" title="进程内缓存"></a>进程内缓存</h4><blockquote><p>有Caffeine、ConcurrentLinkedHashMap、LinkedHashMap、Guava Cache、Ehcache 和 Infinispan Embedded</p></blockquote><h4 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h4><blockquote><p>有LRU,LFU,FIFO,TinyLFU,W-TinyLFU</p></blockquote><h4 id="缓存风险"><a href="#缓存风险" class="headerlink" title="缓存风险"></a>缓存风险</h4><ul><li>缓存穿透：查询不存在的数据<ul><li>对返回为空（不存在的数据）的key进行缓存一段时间</li><li>布隆过滤器</li></ul></li><li>缓存击穿：热点数据突然失效，大量请求访问数据库<ul><li>热点数据手动管理，计划更新</li><li>加锁同步，以请求该数据的key值为锁，使得只有第一个请求可以访问真实数据源，其它的暂时阻塞。</li></ul></li><li>缓存雪崩：大量缓存同时失效<ul><li>设置随机过期事件，避免同时大批量失效。</li><li>建设分布式缓存集群，提高可用性；透明多级缓存</li></ul></li><li>缓存污染：数据不一致<ul><li>缓存更新策略。</li></ul></li></ul><h2 id="架构安全性"><a href="#架构安全性" class="headerlink" title="架构安全性"></a>架构安全性</h2><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><blockquote><p>系统如何正确分辨用户的真实身份</p></blockquote><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><blockquote><p>系统如何控制一个用户该看到哪些数据、能操作哪些功能？</p></blockquote><ul><li><strong>确保授权的过程可靠</strong>：OAuth2</li><li><strong>确保授权的结果可控</strong>：RBAC</li></ul><h4 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h4><blockquote><p><strong>谁</strong>（User）拥有什么<strong>权限</strong>（Authority）去<strong>操作</strong>（Operation）哪些<strong>资源</strong>（Resource）</p></blockquote><p><img src="/../../../img/Pasted%20image%2020230923184422.png"></p><p><img src="/../../../img/Pasted%20image%2020230923184844.png"></p><h4 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h4><blockquote><p>用<code>令牌</code>代替<code>密码</code>，用以解决第三方应用</p></blockquote><blockquote><p>为什么要用<code>令牌</code>代替<code>密码</code></p></blockquote><ul><li>密码泄露：如果第三方应用被黑客攻破，那导致授权应用或其他应用的密码同时泄露</li><li>访问范围：拥有了密码相当于拥有了账号的整个权限，不利于细粒度的访问控制。比如之对外开放查看权限，增删改权限不开放</li><li>授权回收：收回权限意味着只能修改密码，这样会导致其他使用同样密码的应用失效。<code>令牌</code>可以设置有效期，过期失效。</li></ul><p><img src="/../../../img/Pasted%20image%2020230925123746.png"></p><p>四种角色</p><ul><li>授权服务器，负责颁发 Access Token，比如微信开放平台授权服务器。</li><li>资源所有者，你的应用的用户是资源的所有者，授权其他人访问他的资源。比如微信用户是资源所有者。</li><li>调用方，调用方请求获取 Access Token，经过用户授权后，微信开放平台为其颁发 Access Token。调用方可以携带 Access Token 到资源服务器访问用户的资源。比如调用方是上文说的网站A。</li><li>资源服务器，接受 Access Token，然后验证它的被赋予的权限项目，最后返回资源。比如微信开放平台资源服务器。</li></ul><p>四种授权方式</p><ul><li>授权码模式（Authorization Code）</li><li>隐式授权模式（Implicit）</li><li>密码模式（Resource Owner Password Credentials）</li><li>客户端模式（Client Credentials）</li></ul><h5 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h5><blockquote><p>微信扫码授权功能</p></blockquote><p>授权过程：</p><ol><li>第三方应用将资源所有者（用户）导向授权服务器的授权页面，并向授权服务器提供 ClientID 及用户同意授权后的回调 URI，这是一次客户端页面转向。</li><li>授权服务器根据 ClientID 确认第三方应用的身份，用户在授权服务器中决定是否同意向该身份的应用进行授权，用户认证的过程未定义在此步骤中，在此之前应该已经完成。</li><li>如果用户同意授权，授权服务器将转向第三方应用在第 1 步调用中提供的回调 URI，并附带上一个授权码和获取令牌的地址作为参数，这是第二次客户端页面转向。</li><li>第三方应用通过回调地址收到授权码，然后将授权码与自己的 ClientSecret 一起作为参数，通过服务器向授权服务器提供的获取令牌的服务地址发起请求，换取令牌。该服务器的地址应与注册时提供的域名处于同一个域中。</li><li>授权服务器核对授权码和 ClientSecret，确认无误后，向第三方应用授予令牌。令牌可以是一个或者两个，其中必定要有的是访问令牌（Access Token），可选的是刷新令牌（Refresh Token）。访问令牌用于到资源服务器获取资源，有效期较短，刷新令牌用于在访问令牌失效后重新获取，有效期较长。</li><li>资源服务器根据访问令牌所允许的权限，向第三方应用提供资源。</li></ol><p><img src="/../../../img/Pasted%20image%2020230925125453.png"></p><p>思考的问题：</p><ol><li>第三方应用在授权服务器注册的时候需要提供一个回调地址URI，这个URI必须要和步骤1中的一致。</li><li>其他应用假冒第三方应用骗取授权<blockquote><p>其他应用没有ClientSecret换取不到令牌。令牌需要ClientID,ClientSecret(第三方应用私有)，授权码才能换取令牌。</p></blockquote></li><li>为什么先发授权码，再用授权码换取令牌<blockquote><p>授权码相当于临时令牌是给浏览器的，但授权码是暴露的。因此需要借助第三方应用的ClientSecret再去换取令牌</p></blockquote></li></ol><h5 id="隐式授权模式"><a href="#隐式授权模式" class="headerlink" title="隐式授权模式"></a>隐式授权模式</h5><blockquote><p>省略掉了通过授权码换取令牌的步骤，需要在注册时提供回调域名，此时会要求该域名与接受令牌的服务处于同一个域内。此外，同样基于安全考虑，在隐式模式中明确禁止发放刷新令牌。</p></blockquote><p><img src="/../../../img/Pasted%20image%2020230925143756.png"></p><h5 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h5><p><img src="/../../../img/Pasted%20image%2020230925143837.png"></p><blockquote><p>第三方通过用户名和密码换取令牌，但无法保障第三方不会非法保存用户的密码。</p></blockquote><h5 id="客户模式"><a href="#客户模式" class="headerlink" title="客户模式"></a>客户模式</h5><blockquote><p>该模式不需要用户同意授权，比如超时订单自动取消。<br><img src="/../../../img/Pasted%20image%2020230925144001.png"></p></blockquote><h3 id="凭证"><a href="#凭证" class="headerlink" title="凭证"></a>凭证</h3><blockquote><p>系统如何保证它与用户之间的承诺是双方当时真实意图的体现，是准确、完整且不可抵赖的？</p></blockquote><p>无状态和有状态</p><ul><li><p>无状态：各个请求对于服务器来说统一无差别处理,请求自身携带了所有服务端所需要的所有参数(服务端自身不存储跟请求相关的任何数据,不包括数据库存储信息</p></li><li><p>有状态：与之相反,有状态服务在服务端保留之前请求的信息,用以处理当前请求,比如session等</p></li></ul><h4 id="Cookie-Session"><a href="#Cookie-Session" class="headerlink" title="Cookie-Session"></a>Cookie-Session</h4><p>特点：</p><ul><li>存储在服务器，是有状态的。</li></ul><p>缺点：</p><ul><li>在分布式的情况下，水平拓展困难，根据CAP理论，无法同时满足一致性，可用性，分区容忍性</li></ul><h4 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h4><p>特点：</p><ul><li>是服务端发送给客户端的，保存在客户端，每次请求随请求发送到服务器</li><li>是无状态的</li><li>由三个部分构成：</li></ul><ol><li><p>令牌头：可以被解密</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>负载：可以被解密。一般存放用户非敏感信息，过期时间等。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;icyfenix&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authorities&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;ROLE_USER&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;ROLE_ADMIN&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;ALL&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1584948947</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;jti&quot;</span><span class="punctuation">:</span> <span class="string">&quot;9d77586a-3f4f-4cbb-9924-fe2f77dfa33d&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;client_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bookstore_frontend&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>签名：由于加了密钥进行加密，一般不能被破密。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> + base64UrlEncode(payload) <span class="punctuation">,</span> secret)</span><br></pre></td></tr></table></figure></li></ol><p>缺点：</p><ul><li><strong>令牌难以主动失效</strong></li><li><strong>相对更容易遭受重放攻击</strong></li><li><strong>相对更容易遭受重放攻击</strong></li><li><strong>必须考虑令牌在客户端如何存储</strong></li><li><strong>无状态也不总是好的</strong></li></ul><h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><p><a href="https://www.jianshu.com/p/2e20b11eb6e0">加密、摘要、签名、证书，一次说明白! - 简书 (jianshu.com)</a></p><p>安全风险类别：</p><ul><li>窃听风险：现代计算机网络建立在 TCP&#x2F;IP 协议族提供传输能力上，数据在传输线路上的每个环节都可能被窃听，从而导致敏感数据泄露；</li><li>纂改风险：数据在传输过程中可能被篡改，例如中间人攻击。攻击者可以和通信双方分别建立独立的连接，使得通信双方误以为它们正在进行一个私密连接，但察觉不到数据被篡改；(中间商)</li><li>伪装风险：攻击者可以伪装成合法的身份。</li></ul><p>实现传输安全：</p><ul><li>加密 —— 防窃听：将明文转换为密文，只有期望的接收方有能力将密文解密为明文，即使密文被攻击者窃取也无法理解数据的内容；</li><li>验证完整性 —— 防止篡改：对原始数据计算摘要，并将数据和摘要一起交付给通信对方。接收方收到后也对数据计算摘要，并比较是否和接受的摘要一致，借此判断接收的数据是否被篡改。不过，因为收到的摘要也可能被篡改，所以需要使用更安全的手段：数字签名；</li><li>认证数据来源 —— 防止伪装： 数字签名能够验证数据完整性，同时也能认证数据来源，防止伪装。</li></ul><p>摘要：摘要算法的原理是根据一定的运算规则提取原始数据中的信息，被提取的信息就是原始数据的消息摘要，也称为数据指纹。</p><ul><li>一致性： 相同数据多次计算的摘要是相同的，不同的数据（在不考虑碰撞时）的摘要是不同的；</li><li>不可逆性： 只能正向提取原始数据的摘要，无法从摘要反推出原始数据；</li><li>高效性： 摘要的生成过程高效快速；</li></ul><p>加密：加密（Encryption）是将明文（Plaintext）转换为密文（Ciphertext）的过程，只有期望的接收方有能力将密文解密为明文，即使密文被攻击者窃取也无法理解数据的内容。</p><ul><li>对称加密：加密和解密使用相同的密钥</li><li>非对称加密：加密和解密使用不同的密钥<br>1、密钥管理： 对称加密算法中需要将密钥发送给通信对方，存在密钥泄漏风险；非对称加密公钥是公开的，私钥是保密的，防止了私钥外传；</li></ul><p>2、密钥功能： 公钥加密的数据，只可使用私钥对其解密。反之，私钥加密的数据，只可使用公钥对其解密（注意：公钥加密的数据无法使用公钥解密，因为公钥是公开的，如果公钥可以解密的话，就失去了加密的安全性）；</p><p>3、计算性能： 非对称加密算法的计算效率低，因此实际中往往采用两种算法结合的复合算法：先使用非对称加密建立安全信道传输对称密钥，再使用该密钥进行对称加密；</p><p>4、认证功能： 非对称加密算法中，私钥只有一方持有，具备认证性和抗抵赖性（第 3 节 数字签名算法 应用了此特性）。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><blockquote><p>系统如何确保提交到每项服务中的数据是合乎规则的，不会对系统稳定性、数据一致性、正确性产生风险？</p></blockquote><h1 id="2-分布式的基石"><a href="#2-分布式的基石" class="headerlink" title="2.分布式的基石"></a>2.分布式的基石</h1><h2 id="分布式共识算法"><a href="#分布式共识算法" class="headerlink" title="分布式共识算法"></a>分布式共识算法</h2><h4 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h4><p>算法中的三类节点（任何节点都可以充当一下三个角色之一）</p><ul><li><strong>提案节点</strong>：称为 Proposer，提出对某个值进行设置操作的节点，设置值这个行为就被称之为<strong>提案</strong>（Proposal），值一旦设置成功，就是不会丢失也不可变的。请注意，Paxos 是典型的基于操作转移模型而非状态转移模型来设计的算法，这里的“设置值”不要类比成程序中变量赋值操作，应该类比成日志记录操作，在后面介绍的 Raft 算法中就直接把“提案”叫作“日志”了。</li><li><strong>决策节点</strong>：称为 Acceptor，是应答提案的节点，决定该提案是否可被投票、是否可被接受。提案一旦得到过半数决策节点的接受，即称该提案被<strong>批准</strong>（Accept），提案被批准即意味着该值不能再被更改，也不会丢失，且最终所有节点都会接受该它。（奇数个）</li><li><strong>记录节点</strong>：被称为 Learner，不参与提案，也不参与决策，只是单纯地从提案、决策节点中学习已经达成共识的提案，譬如少数派节点从网络分区中恢复时，将会进入这种状态。</li></ul><p><strong>Prepare</strong>阶段：提案节点广播新的提案ID(n)，决策节点收到后，做出”两个承诺“和”一个应答“，如果自己没有接收其他人的提案，则返回Promise(n,null)，如果已经接受了编号更大的提案，则返回Promise(acceptedID,acceptValue)<br><strong>Accept</strong>阶段：在该阶段，提案节点会根据决策节点的Promise来决定行为。</p><ul><li>如果上一阶段超过半数的机器回复说接受提案，那么Proposer就正式通知所有机器去生效这个操作；</li><li>如果上一阶段超过半数的机器回复说他们已经先接受了其他编号更大的提案，那么Proposer会更新一个更大的编号去重试（随机延时）；</li><li>如果上一阶段的机器回复说他们已经生效了其他编号的提案，那么Proposer就也只能接受这个其他人的提案，并告知所有机器直接接受这个新的提案；</li><li>如果上一阶段都没收到半数的机器回复，那么提案取消。</li></ul><p><img src="/../../../img/Pasted%20image%2020230925210751.png"><br><a href="https://zhuanlan.zhihu.com/p/489796705">分布式共识算法之Paxos详解 - 知乎 (zhihu.com)</a></p><h4 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi Paxos"></a>Multi Paxos</h4><blockquote><p>Basic-Paxos存在“活锁”现象，如下图，则所有提案节点会不断增大自己的编号，导致陷入持续等待。</p></blockquote><p><img src="/../../../img/Pasted%20image%2020230925212641.png"></p><p>为了解决这个问题，提出了Multi-Paxos算法<br>Multi Paxos 对 Basic Paxos 的核心改进是增加了“选主”的过程，提案节点会通过定时轮询（心跳），确定当前网络中的所有节点里是否存在有一个主提案节点，一旦没有发现主节点存在，节点就会在心跳超时后使用 Basic Paxos 中定义的准备、批准的两轮网络交互过程，向所有其他节点广播自己希望竞选主节点的请求，希望整个分布式系统对“由我作为主节点”这件事情协商达成一致共识，如果得到了决策节点中多数派的批准，便宣告竞选成功。当选主完成之后，除非主节点失联之后发起重新竞选，否则从此往后，就只有主节点本身才能够提出提案。<br><img src="/../../../img/Pasted%20image%2020230925212755.png"></p><p><img src="/../../../img/Pasted%20image%2020230925212759.png"></p><h4 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h4><p>强一致性协议：Paxos、Raft、ZAB<br>最终一致性：DNS、Gossip</p><p>Gossip过程</p><ul><li><p>如果有某一项信息需要在整个网络中所有节点中传播，那从信息源开始，选择一个固定的传播周期（譬如 1 秒），随机选择它相连接的 k 个节点（称为 Fan-Out）来传播消息。</p></li><li><p>每一个节点收到消息后，如果这个消息是它之前没有收到过的，将在下一个周期内，选择除了发送消息给它的那个节点外的其他相邻 k 个节点发送相同的消息，直到最终网络中所有节点都收到了消息，尽管这个过程需要一定时间，但是理论上最终网络的所有节点都会拥有相同的消息。<br><img src="/../../../img/gossip.0eb19e80.gif"></p></li></ul><h2 id="从类库到服务"><a href="#从类库到服务" class="headerlink" title="从类库到服务"></a>从类库到服务</h2><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><hr><p>远程服务调用三要素：全限定名、端口号、服务标识<br>相关的组件：ZooKeeper、Eureka、Nacos</p><p>服务发现的步骤</p><ul><li><strong>服务的注册</strong>（Service Registration）：当服务启动的时候，它应该通过某些形式（如调用 API、产生事件消息、在 ZooKeeper&#x2F;Etcd 的指定位置记录、存入数据库，等等）将自己的坐标信息通知到<code>服务注册中心</code>，这个过程可能由应用程序本身来完成，称为自注册模式，譬如 Spring Cloud 的@EnableEurekaClient 注解；也可能由容器编排框架或第三方注册工具来完成，称为第三方注册模式，譬如 Kubernetes 和 Registrator。</li><li><strong>服务的维护</strong>（Service Maintaining）：尽管服务发现框架通常都有提供下线机制，但并没有什么办法保证每次服务都能<a href="https://whatis.techtarget.com/definition/graceful-shutdown-and-hard-shutdown">优雅地下线</a>（Graceful Shutdown）而不是由于宕机、断网等原因突然失联。所以服务发现框架必须要自己去保证所维护的服务列表的正确性，以避免告知消费者服务的坐标后，得到的服务却不能使用的尴尬情况。现在的服务发现框架，往往都能支持多种协议（HTTP、TCP 等）、多种方式（长连接、心跳、探针、进程状态等）去监控服务是否健康存活，将不健康的服务自动从服务注册表中剔除。</li><li><strong>服务的发现</strong>（Service Discovery）：这里的发现是特指狭义上消费者从服务发现框架中，把一个符号（譬如 Eureka 中的 ServiceID、Nacos 中的服务名、或者通用的 FQDN）转换为服务实际坐标的过程，这个过程现在一般是通过 HTTP API 请求或者通过 DNS Lookup 操作来完成，也还有一些相对少用的方式，譬如 Kubernetes 也支持注入环境变量来做服务发现。</li></ul><h4 id="注册中心实现"><a href="#注册中心实现" class="headerlink" title="注册中心实现"></a>注册中心实现</h4><hr><ul><li>在分布式 K&#x2F;V 存储框架上自己开发的服务发现，这类的代表是 ZooKeeper、Doozerd、Etcd。</li><li>以基础设施（主要是指 DNS 服务器）来实现服务发现，这类的代表是 SkyDNS、CoreDNS。</li><li>专门用于服务发现的框架和工具，这类的代表是 Eureka、Consul 和 Nacos。</li></ul><h3 id="网关路由"><a href="#网关路由" class="headerlink" title="网关路由"></a>网关路由</h3><p>网关 &#x3D; 路由器（基础职能） + 过滤器（可选职能）</p><p>网络IO模型<br>两类五种</p><p>两类是指同步 I&#x2F;O与异步 I&#x2F;O，五种是指在同步 IO 中又分有划分出阻塞 I&#x2F;O、非阻塞 I&#x2F;O、多路复用 I&#x2F;O和信号驱动 I&#x2F;O四种细分模型。</p><ul><li><strong>异步 I&#x2F;O</strong>（Asynchronous I&#x2F;O）：好比你在美团外卖订了个盒饭，付款之后你自己该干嘛还干嘛去，饭做好了骑手自然会到门口打电话通知你。异步 I&#x2F;O 中数据到达缓冲区后，不需要由调用进程主动进行从缓冲区复制数据的操作，而是复制完成后由操作系统向线程发送信号，所以它一定是非阻塞的。</li><li><strong>同步 I&#x2F;O</strong>（Synchronous I&#x2F;O）：好比你自己去饭堂打饭，这时可能有如下情形发生：<ul><li><strong>阻塞 I&#x2F;O</strong>（Blocking I&#x2F;O）：你去到饭堂，发现饭还没做好，你也干不了别的，只能打个瞌睡（线程休眠），直到饭做好，这就是被阻塞了。阻塞 I&#x2F;O 是最直观的 I&#x2F;O 模型，逻辑清晰，也比较节省 CPU 资源，但缺点就是线程休眠所带来的上下文切换，这是一种需要切换到内核态的重负载操作，不应当频繁进行。</li><li><strong>非阻塞 I&#x2F;O</strong>（Non-Blocking I&#x2F;O）：你去到饭堂，发现饭还没做好，你就回去了，然后每隔 3 分钟来一次饭堂看饭做好了没，直到饭做好。非阻塞 I&#x2F;O 能够避免线程休眠，对于一些很快就能返回结果的请求，非阻塞 I&#x2F;O 可以节省切换上下文切换的消耗，但是对于较长时间才能返回的请求，非阻塞 I&#x2F;O 反而白白浪费了 CPU 资源，所以目前并不常用。</li><li><strong>多路复用 I&#x2F;O</strong>（Multiplexing I&#x2F;O）：多路复用 I&#x2F;O 本质上是阻塞 I&#x2F;O 的一种，但是它的好处是可以在同一条阻塞线程上处理多个不同端口的监听。类比的情景是你名字叫雷锋，代表整个宿舍去饭堂打饭，去到饭堂，发现饭还没做好，还是继续打瞌睡，但哪个舍友的饭好了，你就马上把那份饭送回去，然后继续打着瞌睡哼着歌等待其他的饭做好。多路复用 I&#x2F;O 是目前的高并发网络应用的主流，它下面还可以细分 select、epoll、kqueue 等不同实现，这里就不作展开了。</li><li><strong>信号驱动 I&#x2F;O</strong>（Signal-Driven I&#x2F;O）：你去到饭堂，发现饭还没做好，但你跟厨师熟，跟他说饭做好了叫你，然后回去该干嘛干嘛，等收到厨师通知后，你把饭从饭堂拿回宿舍。这里厨师的通知就是那个“信号”，信号驱动 I&#x2F;O 与异步 I&#x2F;O 的区别是“从缓冲区获取数据”这个步骤的处理，前者收到的通知是可以开始进行复制操作了，即要你自己从饭堂拿回宿舍，在复制完成之前线程处于阻塞状态，所以它仍属于同步 I&#x2F;O 操作，而后者收到的通知是复制操作已经完成，即外卖小哥已经把饭送到了。</li></ul></li></ul><h3 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h3><p><strong>案例场景：</strong></p><p>假设你身处广东，要上 Fenix’s Bookstore 购买一本书，在程序业务逻辑里，购书其中一个关键步骤是调用商品出库服务来完成货物准备，在代码中该服务的调用请求为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PATCH https://warehouse:8080/restful/stockpile/3</span><br><span class="line"></span><br><span class="line">&#123;amount: -1&#125;</span><br></pre></td></tr></table></figure><p>又假设 Fenix’s Bookstore 是个大书店，在北京、武汉、广州的机房均部署有服务集群，你的购物请求从浏览器发出后，服务端按顺序发生了如下事件：</p><ol><li><p>首先是将<code>warehouse</code>这个服务名称转换为恰当的服务地址，“恰当”是个宽泛的描述，一种典型的“恰当”便是因调用请求来自广东，优先分配给传输距离最短的广州机房来应答。其实按常理来说这次出库服务的调用应该是集群内的流量，而不是用户浏览器直接发出的请求，所以尽管结果没有不同，但更接近实际的的情况是用户访问首页时已经被 DNS 服务器分配到了广州机房，请求出库服务时，应优先选择同机房的服务进行调用，此时请求变为：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATCH https://guangzhou-ip-wan:8080/restful/stockpile/3</span><br></pre></td></tr></table></figure></li><li><p>广州机房的服务网关将该请求与配置中的特征进行比对，由 URL 中的<code>/restful/stockpile/**</code>得知该请求访问的是商品出库服务，因此，将请求的 IP 地址转换为内网中 warehouse 服务集群的入口地址：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATCH https://warehouse-gz-lan:8080/restful/stockpile/3</span><br></pre></td></tr></table></figure></li><li><p>集群中部署有多个 warehouse 服务，收到调用请求后，负载均衡器要在多个服务中根据某种标准——可能是随机挑选，也可能是按顺序轮询，抑或是选择此前调用次数最少那个，等等。根据均衡策略找出要响应本次调用的服务，称其为<code>warehouse-gz-lan-node1</code>。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATCH https://warehouse-gz-lan-node1:8080/restful/stockpile/3</span><br></pre></td></tr></table></figure></li><li><p>如果访问<code>warehouse-gz-lan-node1</code>服务，没有返回需要的结果，而是抛出 500 错。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 500 Internal Server Error</span><br></pre></td></tr></table></figure></li><li><p>根据预置的<a href="http://icyfenix.cn/distribution/traffic-management/failure.html">故障转移</a>（Failover）策略，重试将调用分配给能够提供该服务的其他节点，称其为<code>warehouse-gz-lan-node2</code>。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATCH https://warehouse-gz-lan-node2:8080/restful/stockpile/3</span><br></pre></td></tr></table></figure></li><li><p><code>warehouse-gz-lan-node2</code>服务返回商品出库成功。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure></li></ol><p>以上过程从整体上看，步骤 1、2、3、5，分别对应了<strong>服务发现</strong>、<strong>网关路由</strong>、<strong>负载均衡</strong>和<strong>服务容错</strong></p><h4 id="客户端负载均衡器"><a href="#客户端负载均衡器" class="headerlink" title="客户端负载均衡器"></a>客户端负载均衡器</h4><p>访问请求是由集群内部的某个服务发起，由集群内部的另一个服务进行响应的。一种全新的、独立位于每个服务前端的、分散式的负载均衡方式正逐渐变得流行起来，这就是本节我们要讨论的主角：客户端负载均衡器。<br><img src="/../../../img/Pasted%20image%2020230927092158.png"></p><ul><li>客户端均衡器是和服务实例一一对应的，与服务实例在同一个进程之内。</li><li>均衡器与服务之间信息交换是进程内的方法调用，不存在任何额外的网络开销。</li></ul><ul><li>不依赖集群边缘的设施，所有内部流量都仅在服务集群的内部循环，避免了出现前文那样，集群内部流量要“绕场一周”的尴尬局面。</li><li>分散式的均衡器意味着天然避免了集中式的单点问题，它的带宽资源将不会像集中式均衡器那样敏感，这在以七层均衡器为主流、不能通过 IP 隧道和三角传输这样方式节省带宽的微服务环境中显得更具优势。</li><li>客户端均衡器要更加灵活，能够针对每一个服务实例单独设置均衡策略等参数，访问某个服务，是不是需要具备亲和性，选择服务的策略是随机、轮询、加权还是最小连接等等，都可以单独设置而不影响其它服务。</li></ul><p>缺点：</p><ul><li>同一个进程，意味着难以进行技术异构，使用同一语言开发。</li><li>共用一个进程，均衡器的稳定性会直接影响整个服务进程的稳定性，同样消耗资源。</li><li>内部网络安全性</li><li>服务集群的拓扑关系动态变化，则客户端负载均衡器需要一直轮询服务注册中心。</li></ul><h4 id="代理负载均衡器"><a href="#代理负载均衡器" class="headerlink" title="代理负载均衡器"></a>代理负载均衡器</h4><p>使用<code>边车代理</code>模式，不是进程内通信，通过网络进行</p><p><img src="/../../../img/Pasted%20image%2020230927092651.png"><br>优点：</p><ul><li>支持了技术异构，独立于服务进程的均衡器也不会由于自身的稳定性影响到服务进程的稳定。</li><li>在服务拓扑感知方面代理均衡器也要更有优势。由于边车代理接受控制平面的统一管理，当服务节点拓扑关系发生变化时，控制平面就会主动向边车代理发送更新服务清单的控制指令，这避免了此前客户端均衡器必须长期主动轮询服务注册中心所造成的浪费。</li><li>在安全性、可观测性上，由于边车代理都是一致的实现，有利于在服务间建立双向 TLS 通信，也有利于对整个调用链路给出更详细的统计信息。</li></ul><h4 id="地域与区域"><a href="#地域与区域" class="headerlink" title="地域与区域"></a>地域与区域</h4><ul><li>Region：<strong>地域</strong>，如华北，华东，华南。大型系统就是通过不同地域的机房来缩短用户与服务器之间的物理距离。不同地域之间通过公众互联网连接，而不是内网，服务发现、负载均衡器默认不支持跨地域的服务发现和负载均衡。</li><li>Zone：<strong>区域</strong>，位于同一<strong>地域</strong>，如在华东的上海、杭州、苏州的不同机房，使用不同的电力系统和网络系统。同一个区域使用内网连接。</li></ul><h2 id="流量治理"><a href="#流量治理" class="headerlink" title="流量治理"></a>流量治理</h2><blockquote><p>容错性设计是微服务中的核心概念，通过服务容错和流量控制等解决方案来尽可能避免。</p></blockquote><h3 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h3><h4 id="容错策略"><a href="#容错策略" class="headerlink" title="容错策略"></a>容错策略</h4><ul><li>故障转移：服务有多个副本，失败则切换到其他副本尝试，但有次数上限，不会无限制重试。</li><li>快速失败：非幂等性服务，需要避免重复调用导致脏数据，如扣款。因此直接返回失败。</li><li>安全失败：服务有主次之分，如拓展点、事件、AOP注入的日志、调试、审计等功能，假如这些不影响主业务的服务失败了，则主业务应当正确返回，次服务记录一次出错日志即可。</li><li>沉默失败：若大量服务超时，会导致线程堆积。这种情况就应该先隔离该服务，避免对其他服务的影响。</li><li>故障恢复：一般是快速失败+故障恢复。它是指当服务调用出错了以后，将该次调用失败的信息存入一个消息队列中，然后由系统自动开始异步重试调用。很显然也是幂等性服务，由于是后台异步重试，适合实时性不高的主路逻辑或旁路逻辑。</li><li>并行调用：获得最大成功率，双重保险策略。向多个服务副本发送请求，任何一个返回成功即可。（感觉这个也需要幂等服务）</li><li>广播调用：与并行调用相对，指的是等所有请求都成功，才返回。适用于“刷新分布式缓存”。</li></ul><table><thead><tr><th>容错策略</th><th>优点</th><th>缺点</th><th>应用场景</th></tr></thead><tbody><tr><td><strong>故障转移</strong></td><td>系统自动处理，调用者对失败的信息不可见</td><td>增加调用时间，额外的资源开销</td><td>调用幂等服务  <br>对调用时间不敏感的场景</td></tr><tr><td><strong>快速失败</strong></td><td>调用者有对失败的处理完全控制权  <br>不依赖服务的幂等性</td><td>调用者必须正确处理失败逻辑，如果一味只是对外抛异常，容易引起雪崩</td><td>调用非幂等的服务  <br>超时阈值较低的场景</td></tr><tr><td><strong>安全失败</strong></td><td>不影响主路逻辑</td><td>只适用于旁路调用</td><td>调用链中的旁路服务</td></tr><tr><td><strong>沉默失败</strong></td><td>控制错误不影响全局</td><td>出错的地方将在一段时间内不可用</td><td>频繁超时的服务</td></tr><tr><td><strong>故障恢复</strong></td><td>调用失败后自动重试，也不影响主路逻辑</td><td>重试任务可能产生堆积，重试仍然可能失败</td><td>调用链中的旁路服务  <br>对实时性要求不高的主路逻辑也可以使用</td></tr><tr><td><strong>并行调用</strong></td><td>尽可能在最短时间内获得最高的成功率</td><td>额外消耗机器资源，大部分调用可能都是无用功</td><td>资源充足且对失败容忍度低的场景</td></tr><tr><td><strong>广播调用</strong></td><td>支持同时对批量的服务提供者发起调用</td><td>资源消耗大，失败概率高</td><td>只适用于批量操作的场景</td></tr></tbody></table><h4 id="容错设计模式"><a href="#容错设计模式" class="headerlink" title="容错设计模式"></a>容错设计模式</h4><hr><p><strong>断路器模式</strong>：设置一个计数器，当服务失败次数达到阈值时，拒绝后续所有服务，直接返回失败，以避免雪崩效应。（<code>服务熔断</code>）<br><img src="/../../../img/Pasted%20image%2020230929101833.png"></p><p>断路器是有限状态机：</p><ul><li>Closed：关闭状态，意味着所有服务会被正常执行和返回。是<strong>初始状态</strong></li><li>Open：开启状态，拦截服务，直接返回失败，实现快速失败。</li><li>Half Open：中间状态，表示自动故障修复能力，当断路器处于<code>Open</code>状态一段时间后，将由下一次请求将其触发为<code>Half Open</code>状态，如果调用成功则恢复至<code>Closed</code>状态，否则继续保持<code>Open</code></li></ul><p><img src="/../../../img/Pasted%20image%2020230929102237.png"></p><p>阈值说明：</p><ul><li>一段时间内（10s），请求数量达到设定阈值（如20个），必须达到某个值，不然无需断路器介入。</li><li>一段时间内（10s），i请求的故障率达到设定阈值（50%），故障率较高，则说明需要断路器。</li></ul><p><strong>舱壁隔离模式</strong><br>舱壁隔离模式是常用的实现服务隔离的设计模式，舱壁这个词是来自造船业的舶来品，它原本的意思是设计舰船时，要在每个区域设计独立的水密舱室，一旦某个舱室进水，也只是影响这个舱室中的货物，而不至于让整艘舰艇沉没。这种思想就很符合容错策略中<code>失败静默</code>策略。</p><p>若系统中服务A发送了超时，由于目前主流的网络访问大多是基于 TPR 并发模型（Thread per Request）来实现的，因此该请求会一直占用该线程。一旦达到例如Tomcat的最大全局线程数量，则所有其他服务也会因为没有空余的线程服务而导致不可用，产生雪崩。</p><p>因此，可以为每个服务单独的设置线程池，如每个服务设置5个最大线程数，这样该服务超时，最多阻塞5条线程数，不会导致别的服务也没法用。但局部线程池会增大CPU的开销，导致增加3-10ms的请求处理时间。可以进一步采用信号量机制取代局部线程池，为每个服务设置一个线程安全的计数器即可。</p><p><strong>重试模式</strong><br><code>故障转移</code>和<code>故障恢复</code>策略都需要对服务进行重复调用，差别是这些重复调用有可能是同步的，也可能是后台异步进行；有可能会重复调用同一个服务，也可能会调用到服务的其他副本。无论具体是通过怎样的方式调用、调用的服务实例是否相同，都可以归结为重试设计模式的应用范畴。适用于有可能自己恢复的临时性失灵，网络抖动，临时过载等。</p><ul><li>仅主路逻辑的关键服务进行同步重试。</li><li>仅对瞬时故障到的失败（可根据状态码判断），即可自愈的服务。</li><li>仅对幂等性服务重试。</li><li>必须有终止条件。<ul><li>超时终止，避免无限期等待</li><li>次数终止，最多重试2-5次，不可以无限次重试。</li></ul></li></ul><h2 id="可靠通讯"><a href="#可靠通讯" class="headerlink" title="可靠通讯"></a>可靠通讯</h2><h3 id="零信任网络"><a href="#零信任网络" class="headerlink" title="零信任网络"></a>零信任网络</h3><p>表 9-1 传统网络安全模型与云原生时代零信任模型对比</p><table><thead><tr><th>传统、边界安全模型</th><th>云原生、零信任安全模型</th><th>具体需求</th></tr></thead><tbody><tr><td>基于防火墙等设施，认为边界内可信</td><td>服务到服务通信需认证，环境内的服务之间默认没有信任</td><td>保护网络边界（仍然有效）；服务之间默认没有互信</td></tr><tr><td>用于特定的 IP 和硬件（机器）</td><td>资源利用率、重用、共享更好，包括 IP 和硬件</td><td>受信任的机器运行来源已知的代码</td></tr><tr><td>基于 IP 的身份</td><td>基于服务的身份</td><td>同上</td></tr><tr><td>服务运行在已知的、可预期的服务器上</td><td>服务可运行在环境中的任何地方，包括私有云&#x2F;公有云混合部署</td><td>同上</td></tr><tr><td>安全相关的需求由应用来实现，每个应用单独实现</td><td>由基础设施来实现，基础设施中集成了共享的安全性要求。</td><td>集中策略实施点（Choke Points），一致地应用到所有服务</td></tr><tr><td>对服务如何构建、评审、实施的安全需求的约束力较弱</td><td>安全相关的需求一致地应用到所有服务</td><td>同上</td></tr><tr><td>安全组件的可观测性较弱</td><td>有安全策略及其是否生效的全局视图</td><td>同上</td></tr><tr><td>发布不标准，发布频率较低</td><td>标准化的构建和发布流程，每个微服务变更独立，变更更频繁</td><td>简单、自动、标准化的变更发布流程</td></tr><tr><td>工作负载通常作为虚拟机部署或部署到物理主机，并使用物理机或管理程序进行隔离</td><td>封装的工作负载及其进程在共享的操作系统中运行，并有管理平台提供的某种机制来进行隔离</td><td>在共享的操作系统的工作负载之间进行隔离</td></tr></tbody></table><h3 id="服务安全"><a href="#服务安全" class="headerlink" title="服务安全"></a>服务安全</h3><h4 id="建立信任"><a href="#建立信任" class="headerlink" title="建立信任"></a>建立信任</h4><p>零信任网络不存在默认的信任关系，只可通过权威公证人：公开密钥基础设施PKI。通过PKI构建传输安全层（TLS）。在零信任网络安全中，常常使用双向TSL认证。</p><ul><li><p><strong>单向 TLS 认证</strong>：只需要服务端提供证书，客户端通过服务端证书验证服务器的身份，但服务器并不验证客户端的身份。单向 TLS 用于公开的服务，即任何客户端都被允许连接到服务进行访问，它保护的重点是客户端免遭冒牌服务器的欺骗。</p></li><li><p><strong>双向 TLS 认证</strong>：客户端、服务端双方都要提供证书，双方各自通过对方提供的证书来验证对方的身份。双向 TLS 用于私密的服务，即服务只允许特定身份的客户端访问，它除了保护客户端不连接到冒牌服务器外，也保护服务端不遭到非法用户的越权访问。</p></li></ul><h4 id="认证-1"><a href="#认证-1" class="headerlink" title="认证"></a>认证</h4><p>参考Spring Security</p><h4 id="授权-1"><a href="#授权-1" class="headerlink" title="授权"></a>授权</h4><blockquote><p>谁拥有什么权限，RBAC模型</p></blockquote><p>在Spring Security中可以通过两种方式配置，一种是在配置类中，另一种是通过注解标明到方法体上</p><h2 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h2><blockquote><p>学术界一般会将可观测性分解为三个更具体方向进行研究，分别是：事件日志、链路追踪和聚合度量</p></blockquote><p><img src="/../../../img/Pasted%20image%2020230929121530.png"></p><ul><li>日志（Logging）：记录事件，分析出程序的行为，譬如曾经调用过什么方法，曾经操作过哪些数据，等等。</li><li>追踪（Tracing）：全链路追踪，追踪的主要目的是排查故障，如分析调用链的哪一部分、哪个方法出现错误或阻塞，输入输出是否符合预期。</li><li>度量（Metrics）：对系统中某一类信息的统计聚合。度量的主要目的是监控（Monitoring）和预警（Alert），如某些度量指标达到风险阈值时触发事件，以便自动处理或者提醒管理员介入。</li></ul><h3 id="事件日志"><a href="#事件日志" class="headerlink" title="事件日志"></a>事件日志</h3><ul><li><strong>避免打印敏感信息</strong>。</li><li><strong>避免引用慢操作</strong>。</li><li><strong>避免打印追踪诊断信息</strong></li><li><strong>避免误导他人</strong></li><li><strong>记录请求时的TraceID</strong></li><li><strong>系统运行过程中的关键事件</strong></li><li><strong>启动时输出配置信息</strong></li></ul><table><thead><tr><th>数据项</th><th>值</th></tr></thead><tbody><tr><td>IP</td><td>14.123.255.234</td></tr><tr><td>Username</td><td>null</td></tr><tr><td>Datetime</td><td>19&#x2F;Feb&#x2F;2020:00:12:11 +0800</td></tr><tr><td>Method</td><td>GET</td></tr><tr><td>URL</td><td>&#x2F;index.html</td></tr><tr><td>Protocol</td><td>HTTP&#x2F;1.1</td></tr><tr><td>Status</td><td>200</td></tr><tr><td>Size</td><td>1314</td></tr><tr><td>Refer</td><td><a href="https://icyfenix.cn/">https://icyfenix.cn</a></td></tr><tr><td>Agent</td><td>Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;80.0.3987.163 Safari&#x2F;537.36</td></tr></tbody></table><h3 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h3><h3 id="聚合度量"><a href="#聚合度量" class="headerlink" title="聚合度量"></a>聚合度量</h3><h4 id="指标收集"><a href="#指标收集" class="headerlink" title="指标收集"></a>指标收集</h4><ul><li><strong>计数度量器</strong>（Counter）：这是最好理解也是最常用的指标形式，计数器就是对有相同量纲、可加减数值的合计量，譬如业务指标像销售额、货物库存量、职工人数等等；技术指标像服务调用次数、网站访问人数等都属于计数器指标。</li><li><strong>瞬态度量器</strong>（Gauge）：瞬态度量器比计数器更简单，它就表示某个指标在某个时点的数值，连加减统计都不需要。譬如当前 Java 虚拟机堆内存的使用量，这就是一个瞬态度量器；又譬如，网站访问人数是计数器，而网站在线人数则是瞬态度量器。</li><li><strong>吞吐率度量器</strong>（Meter）：吞吐率度量器顾名思义是用于统计单位时间的吞吐量，即单位时间内某个事件的发生次数。譬如交易系统中常以 TPS 衡量事务吞吐率，即每秒发生了多少笔事务交易；又譬如港口的货运吞吐率常以“吨&#x2F;每天”为单位计算，10 万吨&#x2F;天的港口通常要比 1 万吨&#x2F;天的港口的货运规模更大。</li><li><strong>直方图度量器</strong>（Histogram）：直方图是常见的二维统计图，它的两个坐标分别是统计样本和该样本对应的某个属性的度量，以长条图的形式表示具体数值。譬如经济报告中要衡量某个地区历年的 GDP 变化情况，常会以 GDP 为纵坐标，时间为横坐标构成直方图来呈现。</li><li><strong>采样点分位图度量器</strong>（Quantile Summary）：分位图是统计学中通过比较各分位数的分布情况的工具，用于验证实际值与理论值的差距，评估理论值与实际值之间的拟合度。譬如，我们说“高考成绩一般符合正态分布”，这句话的意思是：高考成绩高低分的人数都较少，中等成绩的较多，将人数按不同分数段统计，得出的统计结果一般能够与正态分布的曲线较好地拟合。</li><li>除了以上常见的度量器之外，还有 Timer、Set、Fast Compass、Cluster Histogram 等其他各种度量器，采用不同的度量系统，支持度量器类型的范围肯定会有差别，譬如 Prometheus 支持了上面提到五种度量器中的 Counter、Gauge、Histogram 和 Summary 四种。</li></ul><p>表 10-2 常用 Exporter</p><table><thead><tr><th>范围</th><th>常用 Exporter</th></tr></thead><tbody><tr><td>数据库</td><td>MySQL Exporter、Redis Exporter、MongoDB Exporter、MSSQL Exporter 等</td></tr><tr><td>硬件</td><td>Apcupsd Exporter，IoT Edison Exporter， IPMI Exporter、Node Exporter 等</td></tr><tr><td>消息队列</td><td>Beanstalkd Exporter、Kafka Exporter、NSQ Exporter、RabbitMQ Exporter 等</td></tr><tr><td>存储</td><td>Ceph Exporter、Gluster Exporter、HDFS Exporter、ScaleIO Exporter 等</td></tr><tr><td>HTTP 服务</td><td>Apache Exporter、HAProxy Exporter、Nginx Exporter 等</td></tr><tr><td>API 服务</td><td>AWS ECS Exporter， Docker Cloud Exporter、Docker Hub Exporter、GitHub Exporter 等</td></tr><tr><td>日志</td><td>Fluentd Exporter、Grok Exporter 等</td></tr><tr><td>监控系统</td><td>Collectd Exporter、Graphite Exporter、InfluxDB Exporter、Nagios Exporter、SNMP Exporter 等</td></tr><tr><td>其它</td><td>Blockbox Exporter、JIRA Exporter、Jenkins Exporter， Confluence Exporter 等</td></tr></tbody></table><h4 id="存储查询"><a href="#存储查询" class="headerlink" title="存储查询"></a>存储查询</h4><blockquote><p>避免日志过于庞大，引入<code>时序数据库</code>。</p></blockquote><ul><li>以<a href="https://en.wikipedia.org/wiki/Log-structured_merge-tree">日志结构的合并树</a>（Log Structured Merge Tree，LSM-Tree）代替传统关系型数据库中的<a href="https://en.wikipedia.org/wiki/B%2B_tree">B+Tree</a>作为存储结构，LSM 适合的应用场景就是写多读少，且几乎不删改的数据。</li><li>设置激进的数据保留策略，譬如根据过期时间（TTL）自动删除相关数据以节省存储空间，同时提高查询性能。对于普通数据库来说，数据会存储一段时间后就会被自动删除这种事情是不可想象的。</li><li>对数据进行再采样（Resampling）以节省空间，譬如最近几天的数据可能需要精确到秒，而查询一个月前的数据时，只需要精确到天，查询一年前的数据时，只要精确到周就够了，这样将数据重新采样汇总就可以极大节省存储空间。</li></ul><h4 id="监控预警"><a href="#监控预警" class="headerlink" title="监控预警"></a>监控预警</h4>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 微服务和分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 软件架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vite</title>
      <link href="/posts/feaf56e8/"/>
      <url>/posts/feaf56e8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><blockquote><p>Vite是一种新型前端构建工具(类似webpack)，能够显著提升前端开发体验。它主要由两部分组成：</p></blockquote><ul><li>一个开发服务器，它基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的 模块热更新（HMR）。</li><li>一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。</li></ul><h2 id="搭建第一个Vite项目"><a href="#搭建第一个Vite项目" class="headerlink" title="搭建第一个Vite项目"></a>搭建第一个Vite项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm create vite@latest</span><br><span class="line">npm create vite@latest my-vue-app -- --template &lt;template_name&gt;</span><br><span class="line"></span><br><span class="line">yarn create vite</span><br><span class="line">yarn create vite my-vue-app --template &lt;template_name&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">template_name可以是</span></span><br><span class="line">vanilla，vanilla-ts, vue, vue-ts，react，react-ts，react-swc，react-swc-ts，preact，preact-ts，lit，lit-ts，svelte，svelte-ts，solid，solid-ts，qwik，qwik-ts</span><br></pre></td></tr></table></figure><h1 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vue</span>()],</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="comment">// https://cn.vitejs.dev/config/#resolve-alias</span></span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="comment">// 设置路径</span></span><br><span class="line">      <span class="string">&#x27;~&#x27;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./&#x27;</span>),</span><br><span class="line">      <span class="comment">// 设置别名</span></span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./src&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// https://cn.vitejs.dev/config/#resolve-extensions</span></span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.mjs&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.jsx&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>WebStorm路径标红解决方案<br>在tsconfig.json中添加如下代码</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;baseUrl&quot;: &quot;.&quot;,  </span><br><span class="line">&quot;paths&quot;: &#123;  </span><br><span class="line">  &quot;@/*&quot;: [&quot;src/*&quot;]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156/"/>
      <url>/posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2016-2019 人人开源 All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://www.renren.io</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 版权所有，侵权必究！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.leggasai.common.utils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mark sunlightcs@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RRException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RRException</span><span class="params">(String msg)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(msg);</span><br><span class="line"><span class="built_in">this</span>.msg = msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RRException</span><span class="params">(String msg, Throwable e)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(msg, e);</span><br><span class="line"><span class="built_in">this</span>.msg = msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RRException</span><span class="params">(String msg, <span class="type">int</span> code)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(msg);</span><br><span class="line"><span class="built_in">this</span>.msg = msg;</span><br><span class="line"><span class="built_in">this</span>.code = code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RRException</span><span class="params">(String msg, <span class="type">int</span> code, Throwable e)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(msg, e);</span><br><span class="line"><span class="built_in">this</span>.msg = msg;</span><br><span class="line"><span class="built_in">this</span>.code = code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.msg = msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.code = code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = hello;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ</title>
      <link href="/posts/69e6bbe1/"/>
      <url>/posts/69e6bbe1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-元素概念"><a href="#1-元素概念" class="headerlink" title="1.元素概念"></a>1.元素概念</h1><p><img src="/../../../img/Pasted%20image%2020230919203517.png"></p><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><blockquote><p>分布式系统架构思想下，将复杂系统拆分为多个独立的子模块，例如微服务模块。此时就需要考虑子模块间的远程通信，典型的通信模式分为以下两种，一种是同步的RPC远程调用；一种是基于中间件代理的异步通信方式。</p></blockquote><h3 id="同步RPC调用模型"><a href="#同步RPC调用模型" class="headerlink" title="同步RPC调用模型"></a>同步RPC调用模型</h3><p><img src="/../../../img/Pasted%20image%2020230919203701.png"></p><blockquote><p>同步RPC调用模型下，不同系统之间直接进行调用通信，每个请求直接从调用方发送到被调用方，然后要求被调用方立即返回响应结果给调用方，以确定本次调用结果是否成功。 <strong>注意</strong> 此处的同步并不代表RPC的编程接口方式，RPC也可以有异步非阻塞调用的编程方式，但本质上仍然是需要在指定时间内得到目标端的直接响应</p></blockquote><h3 id="异步通信模型"><a href="#异步通信模型" class="headerlink" title="异步通信模型"></a>异步通信模型</h3><p><img src="/../../../img/Pasted%20image%2020230919203730.png"></p><blockquote><p>异步消息通信模式下，各子系统之间无需强耦合直接连接，调用方只需要将请求转化成异步事件（消息）发送给中间代理，发送成功即可认为该异步链路调用完成，剩下的工作中间代理会负责将事件可靠通知到下游的调用系统，确保任务执行完成。该中间代理一般就是消息中间件。</p></blockquote><blockquote><p>异步通信的优势如下：</p></blockquote><ul><li><p>系统拓扑简单。由于调用方和被调用方统一和中间代理通信，系统是星型结构，易于维护和管理。</p></li><li><p>上下游耦合性弱。上下游系统之间弱耦合，结构更灵活，由中间代理负责缓冲和异步恢复。 上下游系统间可以独立升级和变更，不会互相影响。</p></li><li><p>容量削峰填谷。基于消息的中间代理往往具备很强的流量缓冲和整形能力，业务流量高峰到来时不会击垮下游。</p></li></ul><h2 id="消息传输模型介绍"><a href="#消息传输模型介绍" class="headerlink" title="消息传输模型介绍"></a>消息传输模型介绍</h2><blockquote><p>主流的消息中间件的传输模型主要为点对点模型和发布订阅模型。</p></blockquote><h3 id="点对点模型"><a href="#点对点模型" class="headerlink" title="点对点模型"></a>点对点模型</h3><p><img src="/../../../img/Pasted%20image%2020230919203903.png"><br>点对点模型也叫队列模型，具有如下特点：</p><ul><li><p>消费匿名：消息上下游沟通的唯一的身份就是队列，下游消费者从队列获取消息无法申明独立身份。</p></li><li><p>一对一通信：基于消费匿名特点，下游消费者即使有多个，但都没有自己独立的身份，因此共享队列中的消息，每一条消息都只会被唯一一个消费者处理。因此点对点模型只能实现一对一通信。</p></li></ul><h3 id="发布订阅模型"><a href="#发布订阅模型" class="headerlink" title="发布订阅模型"></a>发布订阅模型</h3><p><img src="/../../../img/Pasted%20image%2020230919203925.png"><br>发布订阅模型具有如下特点：</p><ul><li><p>消费独立：相比队列模型的匿名消费方式，发布订阅模型中消费方都会具备的身份，一般叫做订阅组（订阅关系），不同订阅组之间相互独立不会相互影响。</p></li><li><p>一对多通信：基于独立身份的设计，同一个主题内的消息可以被多个订阅组处理，每个订阅组都可以拿到全量消息。因此发布订阅模型可以实现一对多通信。</p></li></ul><p>传输模型对比</p><p>点对点模型和发布订阅模型各有优势，点对点模型更为简单，而发布订阅模型的扩展性更高。 Apache RocketMQ 使用的传输模型为发布订阅模型，因此也具有发布订阅模型的特点。</p><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/posts/6f2612a2/"/>
      <url>/posts/6f2612a2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-常用注解"><a href="#1-常用注解" class="headerlink" title="1.常用注解"></a>1.常用注解</h1><h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><blockquote><p>Spring的@Bean注解用于告诉方法，产生一个<code>Bean</code>对象，然后这个<code>Bean</code>对象交给<code>Spring</code>管理。产生这个<code>Bean</code>对象的方法<code>Spring</code>只会调用一次，随后这个<code>Spring</code>将会将这个<code>Bean</code>对象放在自己的<code>IOC容器</code>中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue Router</title>
      <link href="/posts/49bed910/"/>
      <url>/posts/49bed910/</url>
      
        <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><blockquote><p>用 Vue + Vue Router 创建单页应用非常简单：通过 Vue.js，我们已经用组件组成了我们的应用。当加入 Vue Router 时，我们需要做的就是将我们的组件映射到路由上，让 Vue Router 知道在哪里渲染它们。下面是一个基本的例子：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue@3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue-router@4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello App!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用 router-link 组件进行导航 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过传递 `to` 来指定链接 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--`&lt;router-link&gt;` 将呈现一个带有正确 `href` 属性的 `&lt;a&gt;` 标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Go to Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>Go to About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由出口 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-动态路由匹配"><a href="#2-动态路由匹配" class="headerlink" title="2.动态路由匹配"></a>2.动态路由匹配</h1><table><thead><tr><th>匹配模式</th><th>匹配路径</th><th>$route.params</th></tr></thead><tbody><tr><td>&#x2F;users&#x2F;:username</td><td>&#x2F;users&#x2F;eduardo</td><td><code>&#123; username: &#39;eduardo&#39; &#125;</code></td></tr><tr><td>&#x2F;users&#x2F;:username&#x2F;posts&#x2F;:postId</td><td>&#x2F;users&#x2F;eduardo&#x2F;posts&#x2F;123</td><td><code>&#123; username: &#39;eduardo&#39;, postId: &#39;123&#39; &#125;</code></td></tr></tbody></table><h2 id="响应路由参数变化"><a href="#响应路由参数变化" class="headerlink" title="响应路由参数变化"></a>响应路由参数变化</h2><blockquote><p>使用带有参数的路由时需要注意的是，当用户从 &#x2F;users&#x2F;johnny 导航到 &#x2F;users&#x2F;jolyne 时，相同的组件实例将被重复使用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会被调用。</p></blockquote><blockquote><p>方式一：使用watch监控参数<br>方式二：使用导航守卫<strong>beforeRouteUpdate</strong></p></blockquote><h2 id="捕获所有路由（用于404）"><a href="#捕获所有路由（用于404）" class="headerlink" title="捕获所有路由（用于404）"></a>捕获所有路由（用于404）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// 将匹配所有内容并将其放在 `$route.params.pathMatch` 下</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/:pathMatch(.*)*&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;NotFound&#x27;</span>, <span class="attr">component</span>: <span class="title class_">NotFound</span> &#125;,</span><br><span class="line">  <span class="comment">// 将匹配以 `/user-` 开头的所有内容，并将其放在 `$route.params.afterUser` 下</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/user-:afterUser(.*)&#x27;</span>, <span class="attr">component</span>: <span class="title class_">UserGeneric</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="在参数中自定义正则"><a href="#在参数中自定义正则" class="headerlink" title="在参数中自定义正则"></a>在参数中自定义正则</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// /:orderId -&gt; 仅匹配数字</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/:orderId(\\d+)&#x27;</span> &#125;,</span><br><span class="line">  <span class="comment">// /:productName -&gt; 匹配其他任何内容</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/:productName&#x27;</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>确保**转义反斜杠( <code>\</code> )**，就像我们对 <code>\d</code> (变成<code>\\d</code>)所做的那样，在 JavaScript 中实际传递字符串中的反斜杠字符。</p></blockquote><h2 id="可重复的参数"><a href="#可重复的参数" class="headerlink" title="可重复的参数"></a>可重复的参数</h2><blockquote><p>如果你需要匹配具有多个部分的路由，如 &#x2F;first&#x2F;second&#x2F;third，你应该用 *（0 个或多个）和 +（1 个或多个）将参数标记为可重复：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// /:chapters -&gt;  匹配 /one, /one/two, /one/two/three, 等</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/:chapters+&#x27;</span> &#125;,</span><br><span class="line">  <span class="comment">// /:chapters -&gt; 匹配 /, /one, /one/two, /one/two/three, 等</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/:chapters*&#x27;</span> &#125;,</span><br><span class="line">]</span><br><span class="line"><span class="comment">//这些也可以通过在右括号后添加它们与自定义正则结合使用：</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// 仅匹配数字</span></span><br><span class="line">  <span class="comment">// 匹配 /1, /1/2, 等</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/:chapters(\\d+)+&#x27;</span> &#125;,</span><br><span class="line">  <span class="comment">// 匹配 /, /1, /1/2, 等</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/:chapters(\\d+)*&#x27;</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="Sensitive-与-strict-路由配置"><a href="#Sensitive-与-strict-路由配置" class="headerlink" title="Sensitive 与 strict 路由配置"></a>Sensitive 与 strict 路由配置</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 将匹配 /users/posva 而非：</span></span><br><span class="line">    <span class="comment">// - /users/posva/ 当 strict: true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// - /Users/posva 当 sensitive: true</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/users/:id&#x27;</span>, <span class="attr">sensitive</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    <span class="comment">// 将匹配 /users, /Users, 以及 /users/42 而非 /users/ 或 /users/42/</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/users/:id?&#x27;</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">strict</span>: <span class="literal">true</span>, <span class="comment">// applies to all routes</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><blockquote><p>你也可以通过使用 ? 修饰符(0 个或 1 个)将一个参数标记为可选：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// 匹配 /users 和 /users/posva</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/users/:userId?&#x27;</span> &#125;,</span><br><span class="line">  <span class="comment">// 匹配 /users 和 /users/42</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/users/:userId(\\d+)?&#x27;</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="3-嵌套路由"><a href="#3-嵌套路由" class="headerlink" title="3.嵌套路由"></a>3.嵌套路由</h1><blockquote><p>这里的 <code>&lt;router-view&gt;</code> 是一个顶层的 <code>router-view</code>。它渲染顶层路由匹配的组件。同样地，一个被渲染的组件也可以包含自己嵌套的 <code>&lt;router-view&gt;</code>。例如，如果我们在 <code>User</code> 组件的模板内添加一个 <code>&lt;router-view&gt;</code>：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">User</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 当 /user/:id/profile 匹配成功</span></span><br><span class="line">        <span class="comment">// UserProfile 将被渲染到 User 的 &lt;router-view&gt; 内部</span></span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;profile&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">UserProfile</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 当 /user/:id/posts 匹配成功</span></span><br><span class="line">        <span class="comment">// UserPosts 将被渲染到 User 的 &lt;router-view&gt; 内部</span></span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;posts&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">UserPosts</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>这里子路由中一定不要加&#x2F;，如&#x2F;profile</p></blockquote><h1 id="4-编程式导航"><a href="#4-编程式导航" class="headerlink" title="4.编程式导航"></a>4.编程式导航</h1><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td><td><code>router.push(...)</code></td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串路径</span></span><br><span class="line">router.<span class="title function_">push</span>(<span class="string">&#x27;/users/eduardo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有路径的对象,路由的index中需要用占位符 /users/:username</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/users/eduardo&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由，并加上参数，让路由建立 url</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">username</span>: <span class="string">&#x27;eduardo&#x27;</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数，结果是 /register?plan=private</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/register&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">&#x27;private&#x27;</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带 hash，结果是 /about#team</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">hash</span>: <span class="string">&#x27;#team&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path ：</p></blockquote><blockquote><p>当指定 <code>params</code> 时，可提供 <code>string</code> 或 <code>number</code> 参数（或者对于<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#repeatable-params">可重复的参数</a>可提供一个数组）。<strong>任何其他类型（如 <code>undefined</code>、<code>false</code> 等）都将被自动字符串化</strong>。对于<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#repeatable-params">可选参数</a>，你可以提供一个空字符串（<code>&quot;&quot;</code>）来跳过它。</p></blockquote><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><blockquote><p>它的作用类似于 <code>router.push</code>，唯一不同的是，它在导航时不会向 history 添加新记录，正如它的名字所暗示的那样——它取代了当前的条目。此时点击浏览器的返回按钮，不可以返回到先前的网页，因为被替换了</p></blockquote><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td><td><code>router.replace(...)</code></td></tr></tbody></table><p>也可以直接在传递给 <code>router.push</code> 的 <code>routeLocation</code> 中增加一个属性 <code>replace: true</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">replace</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">router.<span class="title function_">replace</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure><h2 id="前进"><a href="#前进" class="headerlink" title="前进"></a>前进</h2><blockquote><p>该方法采用一个整数作为参数，表示在历史堆栈中前进或后退多少步，类似于 <code>window.history.go(n)</code>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向前移动一条记录，与 router.forward() 相同</span></span><br><span class="line">router.<span class="title function_">go</span>(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 返回一条记录，与 router.back() 相同</span></span><br><span class="line">router.<span class="title function_">go</span>(-<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 前进 3 条记录</span></span><br><span class="line">router.<span class="title function_">go</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 如果没有那么多记录，静默失败</span></span><br><span class="line">router.<span class="title function_">go</span>(-<span class="number">100</span>)</span><br><span class="line">router.<span class="title function_">go</span>(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h1 id="5-命名视图"><a href="#5-命名视图" class="headerlink" title="5.命名视图"></a>5.命名视图</h1><blockquote><p>有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar</code> (侧导航) 和 <code>main</code> (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code>。其实就是一个组件里展示多个路由组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view left-sidebar&quot;</span> <span class="attr">name</span>=<span class="string">&quot;LeftSidebar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view main-content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view right-sidebar&quot;</span> <span class="attr">name</span>=<span class="string">&quot;RightSidebar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 <code>components</code> 配置 (带上 <strong>s</strong>)：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">components</span>: &#123;</span><br><span class="line">        <span class="attr">default</span>: <span class="title class_">Home</span>,</span><br><span class="line">        <span class="comment">// LeftSidebar: LeftSidebar 的缩写</span></span><br><span class="line">        <span class="title class_">LeftSidebar</span>,</span><br><span class="line">        <span class="comment">// 它们与 `&lt;router-view&gt;` 上的 `name` 属性匹配</span></span><br><span class="line">        <span class="title class_">RightSidebar</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="6-重定向"><a href="#6-重定向" class="headerlink" title="6.重定向"></a>6.重定向</h1><blockquote><p>重定向也是通过 <code>routes</code> 配置来完成，下面例子是从 &#96;&#96; 重定向到 <code>/index</code>：这样用户打开首页时，就会自动跳转到<code>/index</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [&#123; <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/index&#x27;</span> &#125;]</span><br></pre></td></tr></table></figure><blockquote><p>重定向的目标也可以是一个命名的路由：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [&#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">redirect</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;homepage&#x27;</span> &#125; &#125;]</span><br></pre></td></tr></table></figure><blockquote><p>甚至是一个方法，动态返回重定向目标：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// /search/screens -&gt; /search?q=screens</span></span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/search/:searchText&#x27;</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="function"><span class="params">to</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 方法接收目标路由作为参数</span></span><br><span class="line">      <span class="comment">// return 重定向的字符串路径/路径对象</span></span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">path</span>: <span class="string">&#x27;/search&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">q</span>: to.<span class="property">params</span>.<span class="property">searchText</span> &#125; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/search&#x27;</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="相对重定向"><a href="#相对重定向" class="headerlink" title="相对重定向"></a>相对重定向</h2><blockquote><p>也可以重定向到相对位置：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 将总是把/users/123/posts重定向到/users/123/profile。</span></span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/users/:id/posts&#x27;</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="function"><span class="params">to</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 该函数接收目标路由作为参数</span></span><br><span class="line">      <span class="comment">// 相对位置不以`/`开头</span></span><br><span class="line">      <span class="comment">// 或 &#123; path: &#x27;profile&#x27;&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;profile&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><blockquote><p>重定向是指当用户访问 &#x2F;home 时，URL 会被 &#x2F; 替换，然后匹配成 &#x2F;。那么什么是别名呢？将 &#x2F; 别名为 &#x2F;home，意味着当用户访问 &#x2F;home 时，URL 仍然是 &#x2F;home，但会被匹配为用户正在访问 &#x2F;。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [&#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Homepage</span>, <span class="attr">alias</span>: <span class="string">&#x27;/home&#x27;</span> &#125;]</span><br></pre></td></tr></table></figure><blockquote><p>通过别名，你可以自由地将 UI 结构映射到一个任意的 URL，而不受配置的嵌套结构的限制。使别名以 <code>/</code> 开头，以使嵌套路径中的路径成为绝对路径。你甚至可以将两者结合起来，用一个数组提供多个别名：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/users&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">UsersLayout</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      <span class="comment">// 为这 3 个 URL 呈现 UserList</span></span><br><span class="line">      <span class="comment">// - /users</span></span><br><span class="line">      <span class="comment">// - /users/list</span></span><br><span class="line">      <span class="comment">// - /people</span></span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">component</span>: <span class="title class_">UserList</span>, <span class="attr">alias</span>: [<span class="string">&#x27;/people&#x27;</span>, <span class="string">&#x27;list&#x27;</span>] &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="7-路由组件传参"><a href="#7-路由组件传参" class="headerlink" title="7.路由组件传参"></a>7.路由组件传参</h1><blockquote><p>在你的组件中使用 <code>$route</code> 会与路由紧密耦合，这限制了组件的灵活性，因为它只能用于特定的 URL。虽然这不一定是件坏事，但我们可以通过 <code>props</code> 配置来解除这种行为：</p></blockquote><p>我们可以将下面的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> routes = [&#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">User</span> &#125;]</span><br></pre></td></tr></table></figure><p>替换成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="comment">// 请确保添加一个与路由参数完全相同的 prop 名</span></span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;id&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> routes = [&#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">User</span>, <span class="attr">props</span>: <span class="literal">true</span> &#125;]</span><br></pre></td></tr></table></figure><h2 id="布尔模式"><a href="#布尔模式" class="headerlink" title="布尔模式"></a>布尔模式</h2><blockquote><p>当 props 设置为 true 时，route.params 将被设置为组件的 props。</p></blockquote><h2 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h2><blockquote><p>对于有命名视图的路由，你必须为每个命名视图定义 props 配置：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>,</span><br><span class="line">    <span class="attr">components</span>: &#123; <span class="attr">default</span>: <span class="title class_">User</span>, <span class="attr">sidebar</span>: <span class="title class_">Sidebar</span> &#125;,</span><br><span class="line">    <span class="attr">props</span>: &#123; <span class="attr">default</span>: <span class="literal">true</span>, <span class="attr">sidebar</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="对象模式"><a href="#对象模式" class="headerlink" title="对象模式"></a>对象模式</h2><blockquote><p>当 props 是一个对象时，它将原样设置为组件 props。当 props 是静态的时候很有用。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/users&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">User</span>,</span><br><span class="line">    <span class="attr">props</span>:&#123;<span class="attr">name</span>:<span class="string">&quot;jyc&quot;</span>,<span class="attr">age</span>:<span class="string">&quot;16&quot;</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//User组件声明属性</span></span><br><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>([<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="函数模式"><a href="#函数模式" class="headerlink" title="函数模式"></a>函数模式</h2><blockquote><p>你可以创建一个返回 props 的函数。这允许你将参数转换为其他类型，将静态值与基于路由的值相结合等等。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/users/:id&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">User</span>,</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;user&#x27;</span>,</span><br><span class="line"><span class="attr">props</span>: <span class="function"><span class="params">route</span>=&gt;</span>(&#123;<span class="attr">name</span>:route.<span class="property">query</span>.<span class="property">name</span>,<span class="attr">age</span>:route.<span class="property">query</span>.<span class="property">age</span>&#125;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//User组件</span></span><br><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>([<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">name</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">age</span>);</span><br></pre></td></tr></table></figure><blockquote><p>URL <code>/users/1?name=jyc&amp;age=16</code> 将传递 <code>&#123;name: &#39;jyc&#39;,age:&#39;16&#39;&#125;</code> 作为 props 传给 <code>User</code> 组件。</p></blockquote><h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><p>（todo)</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pinia</title>
      <link href="/posts/74dce755/"/>
      <url>/posts/74dce755/</url>
      
        <content type="html"><![CDATA[<h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add pinia</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者使用 npm</span></span><br><span class="line">npm install pinia</span><br></pre></td></tr></table></figure><blockquote><p>在vue项目中，一般会在src下建立&#x2F;store文件夹，用以存放全局状态文件。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/store/index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;createPinia&#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span>;  </span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createPinia</span>();  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line">app.<span class="title function_">use</span>(store)</span><br><span class="line"><span class="comment">//------------------------------------------------</span></span><br><span class="line"><span class="comment">//或直接在main.ts中引入</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">createPinia</span>())</span><br></pre></td></tr></table></figure><h1 id="2-核心概念"><a href="#2-核心概念" class="headerlink" title="2.核心概念"></a>2.核心概念</h1><h2 id="1-State"><a href="#1-State" class="headerlink" title="1.State"></a>1.State</h2><blockquote><p>大多数时候，state 是 store 的核心部分。 我们通常从定义应用程序的状态开始。 在 Pinia 中，状态被定义为返回初始状态的函数。 Pinia 在服务器端和客户端都可以工作。(其实也就是全局共享的数据，如登录用户信息)</p></blockquote><h3 id="定义State"><a href="#定义State" class="headerlink" title="定义State"></a>定义State</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">const</span> useStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;storeId&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 推荐使用 完整类型推断的箭头函数</span></span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 所有这些属性都将自动推断其类型</span></span><br><span class="line">      <span class="attr">counter</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Eduardo&#x27;</span>,</span><br><span class="line">      <span class="attr">isAdmin</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">const</span> useStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;storeId&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 推荐使用 完整类型推断的箭头函数</span></span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">      <span class="comment">// 所有这些属性都将自动推断其类型</span></span><br><span class="line">      <span class="attr">counter</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Eduardo&#x27;</span>,</span><br><span class="line">      <span class="attr">isAdmin</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>当你在箭头函数中使用大括号 {} 包围代码块时，你必须显式使用 return 语句来指定返回值。这是因为大括号 {} 可以包含多个语句，因此你需要明确指定哪个语句的结果应该作为函数的返回值。<br>所以，如果你写成 f: () &#x3D;&gt; { return {} }，这与 f: () &#x3D;&gt; ({}) 是等价的，都表示函数 f 返回一个空对象。在这种情况下，大括号 {} 包含了一个 return 语句，指定了返回值为空对象。如果你省略大括号，那么箭头函数将默认将后面的表达式作为返回值。</p></blockquote><h3 id="访问State"><a href="#访问State" class="headerlink" title="访问State"></a>访问State</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useStore&#125; <span class="keyword">from</span> <span class="string">&#x27;../store/module/user&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"><span class="comment">//访问状态中的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(store.<span class="property">counter</span>)</span><br><span class="line"><span class="comment">//重置到初始状态</span></span><br><span class="line">store.$reset()</span><br></pre></td></tr></table></figure><blockquote><p>注意store类型是一个reactive包裹的响应式对象</p></blockquote><blockquote><p><strong>为了从 Store 中提取属性同时保持其响应式，您需要使用storeToRefs()或者使用计算属性。 它将为任何响应式属性创建 refs。 当您仅使用 store 中的状态但不调用任何操作时，这很有用：</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; storeToRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">    <span class="comment">// `name` 和 `doubleCount` 是响应式引用</span></span><br><span class="line">    <span class="comment">// 这也会为插件添加的属性创建引用</span></span><br><span class="line">    <span class="comment">// 但跳过任何 action 或 非响应式（不是 ref/reactive）的属性</span></span><br><span class="line">    <span class="keyword">const</span> &#123; name, doubleCount &#125; = <span class="title function_">storeToRefs</span>(store)</span><br><span class="line"><span class="comment">//doubleValue: computed(() =&gt; store.doubleCount),</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name,</span><br><span class="line">      doubleCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="修改状态"><a href="#修改状态" class="headerlink" title="修改状态"></a>修改状态</h3><h4 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="property">counter</span>++;</span><br></pre></td></tr></table></figure><h4 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要重新赋一个新的值，不利于数组，集合的增删修改</span></span><br><span class="line">store.$patch(&#123;</span><br><span class="line">  <span class="attr">counter</span>: store.<span class="property">counter</span> + <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Abalam&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数形式，对state进行修改</span></span><br><span class="line">store.$patch(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  state.<span class="property">items</span>.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;shoes&#x27;</span>, <span class="attr">quantity</span>: <span class="number">1</span> &#125;)</span><br><span class="line">  state.<span class="property">hasChanged</span> = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接修改state</span></span><br><span class="line">store.<span class="property">$state</span> = &#123; <span class="attr">counter</span>: <span class="number">666</span>, <span class="attr">name</span>: <span class="string">&#x27;Paimon&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="订阅状态"><a href="#订阅状态" class="headerlink" title="订阅状态"></a>订阅状态</h3><blockquote><p>订阅状态的变化，每当状态被修改或改变时，都会触发回调函数</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cartStore.$subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// import &#123; MutationType &#125; from &#x27;pinia&#x27;</span></span><br><span class="line">  mutation.<span class="property">type</span> <span class="comment">// &#x27;direct&#x27; 方式1| &#x27;patch object&#x27; 方式2(1)| &#x27;patch function&#x27; 方式2(2)</span></span><br><span class="line">  <span class="comment">// 与 cartStore.$id 相同</span></span><br><span class="line">  mutation.<span class="property">storeId</span> <span class="comment">// &#x27;cart&#x27;</span></span><br><span class="line">  <span class="comment">// 仅适用于 mutation.type === &#x27;patch object&#x27;</span></span><br><span class="line">  mutation.<span class="property">payload</span> <span class="comment">// 补丁对象传递给 to cartStore.$patch()</span></span><br><span class="line">  <span class="comment">// 每当它发生变化时，将整个状态持久化到本地存储</span></span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;cart&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(state))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-Getters"><a href="#2-Getters" class="headerlink" title="2.Getters"></a>2.Getters</h2><blockquote><p>Getter 完全等同于 Store 状态的 <strong>计算值</strong>。 它们可以用 defineStore() 中的 getters 属性定义。 他们接收“状态”作为第一个参数以鼓励箭头函数的使用：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;main&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">counter</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="comment">// 自动将返回类型推断为数字</span></span><br><span class="line">    <span class="title function_">doubleCount</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">counter</span> * <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 返回类型必须明确设置</span></span><br><span class="line">    <span class="title function_">doublePlusOne</span>(): number &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">counter</span> * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 访问其他getters</span></span><br><span class="line">    <span class="title function_">doubleCountPlusOne</span>():number &#123;</span><br><span class="line">      <span class="comment">// 自动完成 ✨</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">doubleCount</span> + <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 传递参数给getters</span></span><br><span class="line">    <span class="comment">// getters本身和计算属性一样，无法接收参数，但可以返回一个接收参数的函数。如下面的getUserById</span></span><br><span class="line">    <span class="attr">getUserById</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">userId</span>) =&gt;</span> state.<span class="property">users</span>.<span class="title function_">find</span>(<span class="function">(<span class="params">user</span>) =&gt;</span> user.<span class="property">id</span> === userId)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 访问其他Store的getters</span></span><br><span class="line">    <span class="comment">// 首先需要在顶部import其他Store</span></span><br><span class="line">    <span class="comment">// import &#123;useOtherStore&#125; from &#x27;./other-store&#x27;</span></span><br><span class="line">    <span class="title function_">getOtherStore</span>(<span class="params">state</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> otherStore = <span class="title function_">useOtherStore</span>()</span><br><span class="line">    <span class="keyword">return</span> state.<span class="property">count</span> + otherStore.<span class="property">count</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>可以直接访问Store的任何getter作为store的属性，就和state属性一样</p></blockquote><h2 id="3-Actions"><a href="#3-Actions" class="headerlink" title="3.Actions"></a>3.Actions</h2><blockquote><p>Actions 相当于组件中的 <strong>methods</strong>。 它们可以使用 defineStore() 中的 actions 属性定义，并且它们非常适合定义业务逻辑：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;main&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">counter</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">counter</span>++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">randomizeCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">counter</span> = <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">100</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>())</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><ol><li>和getters一样，在actions同样可以访问其他Store</li><li>可以定义异步方法</li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useAuthStore &#125; <span class="keyword">from</span> <span class="string">&#x27;./auth-store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useSettingsStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;settings&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">fetchUserPreferences</span>(<span class="params">preferences</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> auth = <span class="title function_">useAuthStore</span>()</span><br><span class="line">      <span class="keyword">if</span> (auth.<span class="property">isAuthenticated</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">preferences</span> = <span class="keyword">await</span> <span class="title function_">fetchPreferences</span>()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;User must be authenticated&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="订阅Actions"><a href="#订阅Actions" class="headerlink" title="订阅Actions"></a>订阅Actions</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unsubscribe = someStore.$onAction(</span><br><span class="line">  <span class="function">(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    name, // action 的名字</span></span></span><br><span class="line"><span class="params"><span class="function">    store, // store 实例</span></span></span><br><span class="line"><span class="params"><span class="function">    args, // 调用这个 action 的参数</span></span></span><br><span class="line"><span class="params"><span class="function">    after, // 在这个 action 执行完毕之后，执行这个函数</span></span></span><br><span class="line"><span class="params"><span class="function">    onError, // 在这个 action 抛出异常的时候，执行这个函数</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始的时间变量</span></span><br><span class="line">    <span class="keyword">const</span> startTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="comment">// 这将在 `store` 上的操作执行之前触发</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Start &quot;<span class="subst">$&#123;name&#125;</span>&quot; with params [<span class="subst">$&#123;args.join(<span class="string">&#x27;, &#x27;</span>)&#125;</span>].`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 action 成功并且完全运行后，after 将触发。</span></span><br><span class="line">    <span class="comment">// 它将等待任何返回的 promise</span></span><br><span class="line">    <span class="title function_">after</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">        <span class="string">`Finished &quot;<span class="subst">$&#123;name&#125;</span>&quot; after <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">          <span class="built_in">Date</span>.now() - startTime</span></span></span><br><span class="line"><span class="subst"><span class="string">        &#125;</span>ms.\nResult: <span class="subst">$&#123;result&#125;</span>.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 action 抛出或返回 Promise.reject ，onError 将触发</span></span><br><span class="line">    <span class="title function_">onError</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`Failed &quot;<span class="subst">$&#123;name&#125;</span>&quot; after <span class="subst">$&#123;<span class="built_in">Date</span>.now() - startTime&#125;</span>ms.\nError: <span class="subst">$&#123;error&#125;</span>.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动移除订阅</span></span><br><span class="line"><span class="title function_">unsubscribe</span>()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Obsidian基本使用</title>
      <link href="/posts/a7d785f0/"/>
      <url>/posts/a7d785f0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-字体"><a href="#1-字体" class="headerlink" title="1.字体"></a>1.字体</h1><h2 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h2><p>使用**&lt; content &gt;**</p><h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h2><p>使用*&lt; content &gt;*<br>使用_&lt; content &gt;_</p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><del>123</del></p><hr><h1 id="2-列表"><a href="#2-列表" class="headerlink" title="2.列表"></a>2.列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul><li>123</li><li>123</li></ul><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol><li>123<ol><li>123</li><li>456</li></ol></li><li>456</li><li>789</li></ol><h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><ul><li><input disabled="" type="checkbox"> todo1</li><li><input checked="" disabled="" type="checkbox"> todo2</li></ul><hr><h1 id="3-格式"><a href="#3-格式" class="headerlink" title="3.格式"></a>3.格式</h1><h2 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h2><blockquote><p>我是引用块1<br>我是引用块2<br>我是引用块3</p></blockquote><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">123456</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th>标题1</th><th>标题2</th></tr></thead><tbody><tr><td>行1列1</td><td>行1列2</td></tr><tr><td>行2列1</td><td>行2列2</td></tr></tbody></table><h1 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h1><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>![[Pasted image 20230911213917.png]]</p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>#写作<br>#写作&#x2F;记叙文<br>#写作&#x2F;议论文</p><p><img src="/../../img/Pasted%20image%2020231202172206.png"></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[[引用]]</p><p><a href="../../posts/4a17b156">obsidian基本使用.md</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> obsidian </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
